---
title: 算法视频第三天——数据结构
id: 3
date: 2019-11-2 20:00:00
tags: 数据结构与算法
comment: true
---

### 栈和队列深入

#### 栈（Stack）

在python里面，栈不需要我们自己定义，使用列表就可以：

进栈函数：append

出栈函数：pop(不加参数)

取栈顶（查看）：li[-1]

```python
#使用python列表的形式实现栈
class Stack:
	def __init__(self):
        self.li = []

 	def push(self, item):
 		self.li.append(item)

 	def pop(self):
 		return self.li.pop()

#用数组的形式实现栈
class Stack:
	def __init__(self, maxlen=100):
        #创建一个100个元素的空数组
		self.li = [None for _ in range(maxlen)]
		self.maxlen = maxlen
		self.i = 0

	def push(self, item):
		if self.is_full():
			raise IndexError("栈满")
		else:
			self.li[self.i] = item
			self.i += 1

	def pop(self):
		if self.is_empty():
			raise IndexError("栈空")
		else:
			self.i -= 1
			return self.li[self.i]

	def is_full(self):
		if self.i == self.maxlen:
			return True
		else:
			return False

	def is_empty(self):
		if self.i == 0:
			return True
		else:
			return False
```

实例应用：

```python
 []{[]()}：匹配
分析：[进]消{进[进]消(进)消}消
([{}])：匹配
{[()]})：不匹配
[(]：不匹配

def brace_match(s):
	stack = []
	d = {'(':')', '[':']', '{':'}'}
	for ch in s:
		if ch in {'(', '[', '{'}:
			stack.append(ch)
		elif len(stack) == 0:  #来的是右括号并且栈空
			return False	# 多右括号
		elif d[stack[-1]] ==  ch: #栈不空并且匹配
			stack.pop()
		else: # 不匹配
			return False	# 左右不匹配
	if len(stack) == 0:
		return True
	else:
		return False		# 多左括号
```

#### 对列（Queue）

双端队列：在队列的两端都允许进栈和出栈的操作。

```python
#使用数组的形式实现队列
class Queue:
	def __init__(self, maxlen=12):
		self.li = [None for _ in range(maxlen)]
		self.rear = 0  # 队尾
		self.front = 0	# 队首
		self.maxlen = maxlen

	def push(self, item):
		if self.is_full():
			raise IndexError('队满')
		else:
			self.rear = (self.rear + 1) % self.maxlen
			self.li[self.rear] = item

	def pop(self):
		if self.is_empty():
			raise IndexError('队空')
		else:
			self.front = (self.front + 1) % self.maxlen
			return self.li[self.front]

	def is_empty(self):
		return self.rear == self.front

	def is_full(self):
		return (self.rear + 1) % self.maxlen == self.front

```

扩容，比如我们的双十一，我们的队列满了难道就不然人排队么？不可能是吧，我们可以这样做，做一个动态的队列，当满了的时候就扩大一倍。

```python
from collections import deque
#无参数：产生一个空的队列
q = deque()
#支持四种操作
q.append(1)
print(q.popleft())
q.appendleft(2)
print(q.pop())

#有参数：一次性push5个数，最后一个限定了队列的长度，但是队列满了不会报错，而是把之前的数字顶掉
q = deque([1,2,3,4,5],3)
```

### 链表

```python
class Node:
	def __init__(self, data=None):
		self.data = data
		self.next = None

def create_linklist_head(li):
    #创建链表头部
	head = Node()
	for ele in li:
		p = Node(ele)
		p.next = head.next
		head.next = p
	return head

def create_linklist_tail(li):
    #创建链表尾部
	head = Node()
	tail = head
	for ele in li:
		p = Node(ele)
		tail.next = p
		tail = p
	return head

def traverse_linklist(head):
    #遍历链表
	p = head.next
	while p:
		print(p.data, end=',')
		p = p.next

def reverse_linklist(head):
    #反转链表
	if head.next == None or head.next.next == None:
		return head
	p = head.next
	q = p.next
	r = q.next
	p.next = None
	while True:
		q.next = p
		p = q
		q = r
		if r == None:
			break
		r = q.next
	head.next = p
	return head

def merge_linklist(l1, l2):
    #合并链表
	head = Node()
	tail = head
	i = l1.next
	j = l2.next
	while i and j:
		if i.data <= j.data:
			tail.next = i
			tail = i
			i = i.next
		else:
			tail.next = j
			tail = j
			j = j.next
	if i:
		tail.next = i
	else:
		tail.next = j
	return head



l1 = create_linklist_tail([1,5,6,8,9])
l2 = create_linklist_tail([2,4,6,10,13])
l = merge_linklist(l1, l2)
traverse_linklist(l)
# traverse_linklist(ll)
# ll = reverse_linklist(ll)
# print()
# traverse_linklist(ll)

# 哈希摘要 MD5 SHA1 SHA2 sha256
```

### 二叉树

```python
from collections import deque

class BiTreeNode:
    def __init__(self, data):
        self.data = data
        self.lchild = None
        self.rchild = None

a = BiTreeNode('A')
b = BiTreeNode('B')
c = BiTreeNode('C')
d = BiTreeNode('D')
e = BiTreeNode('E')
f = BiTreeNode('F')
g = BiTreeNode('G')

e.lchild = a
e.rchild = g
a.rchild = c
c.lchild = b
c.rchild = d
g.rchild = f

root = e

def pre_order(root):
    #前序遍历
	if root:
		print(root.data, end='')
		pre_order(root.lchild)
		pre_order(root.rchild)


def in_order(root):
    #中序遍历
	if root:
		in_order(root.lchild)
		print(root.data, end='')
		in_order(root.rchild)

def post_order(root):
    #后序遍历
	if root:
		post_order(root.lchild)
		post_order(root.rchild)
		print(root.data, end='')

def level_order(root):
    #层次遍历
	q = deque()
	q.append(root)
	while len(q) > 0:  # 当队不空时循环
		p = q.popleft()
		print(p.data, end='')
		if p.lchild:
			q.append(p.lchild)
		if p.rchild:
			q.append(p.rchild)

level_order(root)
```



