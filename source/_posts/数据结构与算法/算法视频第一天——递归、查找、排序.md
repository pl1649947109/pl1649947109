---
title: 算法视频第一天——递归、查找、排序
id: 1
date: 2019-10-19 20:00:00
tags: 数据结构与算法
comment: true
---

### 递归

两个特点：

- 调用自身
- 结束条件

```python
def func(x):
	if x>0:
        func(x-1)
        print (x)
```

<!----more---->

### 斐波那契数

```python
# O(2^n):最慢的,但是最经典的
def fibnacci(n):
	if n == 0 or n == 1:
		return 1
	else:
		return fibnacci(n-1) + fibnacci(n-2)
#上面的情况是不是看着非常的简单，但是这是一个非常的大的坑，因为它的复杂度是2^n,所以，就是我们计算的值是100，那计算时间也是一个非常大的，可能到我们死也计算不出来（计算机大概每秒计算10^9次方左右，而100的斐波那契大的计算次数是1267650600228229401496703205376）
    
# O(n):使用递归的方式求某一个斐波那契数
def fib(n):
	li = [-1 for _ in range(n+1)]
	li[0] = 1
	li[1] = 1
	def fibnacci(n):
		if li[n] == -1:
			x = fibnacci(n-1) + fibnacci(n-2)
			li[n] = x
		return li[n]
	return fibnacci(n)

# O(n)：求前n个斐波那契数
def fib2(n):
	li = [1, 1]
	for i in range(2, n+1): # i表示循环正在计算第i个数
		li.append(li[-1] + li[-2])
	return li[n]

#O(n)：求第n个斐波那契数
def fib3(n):
	a = 1
	b = 1
	c = 1
	for i in range(2, n+1): # i表示算出来的c就是第i个数
		c = a + b  # 算下一项
		a = b
		b = c
	return c

print(fib3(100))

#一般面试的时候写第一个，后面的能写几个就写几个
实际的栗子：一个人上一个n阶楼梯，他又两种走法，一次走一步或者两部，问有多少种走法？
1阶：1种
2阶：2种
3阶：3种
4阶：5种
...
看见没，把一阶前面加一个1，这就变成了一个斐波那契的问题。
```

### 汉诺塔

```python
def hanoi(n,A,B,C):
    if n > 0:
        hanoi(n-1,A,C,B)
        print('%s->%s' % (A,C))
        hanoi(n-1,B,AC)
```

### 列表带入

1，找出列表中只出现一个奇数个数的数字

```python
#抑或^的性质
a^b = b^a
a^b^c=a^(b^c)
a^a=0
0^a=a
0^0=0

li=[1,2,3,3,4,4,1,2,2]
def find_the_preson(li):
    res = 0
    for i in li:
        res = res ^ i
    return res
#0^1^2^3^3^4^1^2^2=0^0^0^0^0^2=2
注意：这种情况只能应付一个奇数个数的列表，要是有两个就不行
```

2，交换a,b的值，不使用python的语法实现,也不用中间变量

```python
a = 3
b = 5
a = a + b  #8
a = a - b  #3
b = a - b  #5
```

3，求超过一半次数的众数

```python
li = [1,2,3,4,5,1,2,2,1,2,2,2,2]
def find_the_num(li):
    num = li[0]
    t = 1
    for i in range(1,len(li)):
        if li[i] == num
        	t += 1
        else:
            t -= 1
        if t == 0:
            num = li[i]
     return num
思路：因为2出现的次数超过一半，所以，我们把2和其他的数字怼掉，剩下的就是那个数字。
```

### 二分查找

```python
#针对：列表数据应该是有序的
def binary_search(li,num):
    low = 0
    high = len(i) - 1
    while low < high:
        mid = (low+high) // 2
        if li[mid] == num:
            return mid
        elif li[mid] < num:
            low = mid + 1
        else:
            high = mid - 1
    return -1
```

### 排序（九大排序算法）

Low B三人组

#### 冒泡排序

![](http://9017499461.linshutu.top/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.gif)

```python
#需要n-1趟；每一趟把无序区每两个相邻的元素的大小关系交换
#第i趟：有序区有i个数，无序区的范围是[0,len(li)-i-1]
def bubble_sort(li):
	for i in range(len(li)-1):
        for j in range(len(li)-i-1):
            if li[j] > li[j+1]:
            	li[j],li[j+1] = li[j+1],li[j]
    return li
#时间复杂度：O(n^2)

#优化：前面的如果没有发生交换，直接停止（就是说无序区的数据是有序的）
from cal_time import cal_time
import random

@cal_time  #打印代码的运行时间
def bubble_sort(li):
	for i in range(len(li)-1):
		swapped = False
		for j in range(len(li)-i-1):
			if li[j] > li[j+1]:
				li[j], li[j+1] = li[j+1], li[j]
				swapped = True
		if swapped == False:
			return
```

#### 选择排序

![](http://9017499461.linshutu.top/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.gif)

```python
#难点：找最小数的位置
def find_min_pos(li):
    min_pos = 0
    for i in rnge(1,len(li)):
        if li[i] < li[min_pos]:
            min_pos = i
    return min

#第i趟开始时，有序区[0,n-1]
def select_sort(li):
    for i in range(len(li-1)):
        min_pos = i
        for j in range(i+1,len(li)):
            if li[j] < li[min_pos]:
                min_pos = j
        li[i],li[min_pos] = li[min_pos],li[i]
#时间复杂度：O(n^2)
```

#### 插入排序

![](http://9017499461.linshutu.top/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.gif)

```python
def insert_sort(li):
	for i in range(1, len(li)): #ｉ表示摸到的牌（要插入的数）的下标
		tmp = li[i]  # 把摸到的牌存起来
		j = i - 1 # j就是有序区要比较的数的下标
		while j >= 0 and li[j] > tmp:  # 决定什么时候停止循环，把tmp插入到对应位置上
			# 两个终止条件：1.j位置的值比tmp小; 2.j=-1 已经移动到最前面的
			li[j+1] = li[j]
			j -= 1
		li[j+1] = tmp
#时间复杂度：O(n^2)
```

#### 小结

- 快慢：选择排序>插入排序>冒泡排序
- 他们的时间复杂度都是O(n^2)
- 他们的空间复杂度都是O(1)

NB三人组

#### 快速排序(***)

思路：

- 取一个元素P（第一个元素），使元素p归位
- 列表被p分成两部分，左边都比p小，右边都比p大
- 递归完成排序

![](http://9017499461.linshutu.top/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F2.gif)

```python
import sys
import random
from cal_time import *

#原地排序
def partition(li, left, right):
	rand_i = random.randint(left, right)  #随机取数组中一个数第一个数字交换位置
	li[rand_i], li[left] = li[left], li[rand_i]
	tmp = li[left]
	while left < right:   
		while left < right and li[right] >= tmp:
			right -= 1
		li[left] = li[right]
		while left < right and li[left] <= tmp:
			left += 1
		li[right] = li[left]
	li[left] = tmp
	return left


def _quick_sort(li, left, right):
	if left < right: # 区域有两个及以上的元素
		mid = partition(li, left, right)
		_quick_sort(li, left, mid-1)
		_quick_sort(li, mid+1, right)
        
@cal_time
def quick_sort(li):
	_quick_sort(li, 0, len(li)-1)
   
li = list(range(100000))
random.shuffle(li)
quick_sort(li)

#时间复杂度：O(nlgn)
```

问题：

- 最坏情况：就是我们排的数组里面的顺序是倒序或者顺序的，那么它的时间复杂度就是O(n^2)。解决的思路就是，随机在数组中取一个数和第一个数进行互换位置，尽管不会完全消除最坏情况，但是在绝大多数情况不会出现上述的问题
- 递归，递归的层数是997，但是可以修改

```python
#python代码实现（空间复杂度高了）
def _quick_sort2(li):
    #递归
	if len(li) <= 1:
		return li
	p = li[0]
    #partition，这里开辟了新的空间
	left = [li[i] for i in range(1,len(li)) if li[i] <= p]
	right = [li[i] for i in range(1, len(li)) if li[i] > p]
	left = _quick_sort2(left)
	right = _quick_sort2(right)
    #加在一起
	return left + [p] + right

@cal_time
def quick_sort2(li):
	return _quick_sort2(li)

li = list(range(100000))
random.shuffle(li)
quick_sort2(li)
```

