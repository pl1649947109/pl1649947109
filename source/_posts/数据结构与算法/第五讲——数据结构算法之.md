---
title: 第五讲——数据结构算法之查找
id: 8
date: 2019-11-7 20:00:00
tags: 数据结构与算法
comment: true
---

### 查找概论

#### 静态查找表

解释：只作查找操作的查找表

- 查询某个特定的数据元素是否在查找表中
- 检索某个特定数据元素和各种属性

#### 动态查找表

解释：在查找过程中同时插入查找表中不存在的数据元素，或者从查找表中删除已经存在的某个数据元素

- 查找时插入数据元素
- 查找时删除数据元素

### 顺序查找

解释：顺序查找又叫做线性查找，是最基本的查找技术，它的查找过程是：从表中第一个（或最后一个）记录开始，逐个进行记录的关键字和给定值比较，若某个记录的关键字和给定值比较不等时，则表中没有所查找的记录，查找不成功。

时间复杂度为O(n)

缺点：顺序查找技术最大的缺点就是，n很大时，查找效率极为低下，不过有点还是有的，算法简单，对静态查找表的记录没有任何要求，在一些小型数据的查找时，是可以适用的。
<!----more---->
### 有序表查找

#### 二分查找

解释：它的前提是线性表中记录必须是关键码有序（通常是从小到大有序），线性表必须采用顺序储存。二分查找的基础思想是：有序表中，取中间记录作为比较对象，若给定值与中间记录的关键字相等，则查找成功；若给定值小于中间记录的关键字，则中间记录在左半区继续查找；若给定的值大于中间记录的关键字，则在中间记录的右半区继续查找。不断重复上述的过程，知道查找成功，或所有查找域无记录，查找失败为止。

#### 插值查找

解释：二分查找的方式是将数据折半，这个的意思就是想折多少就折多少。它使根据要查找的关键字key与查找表中最大最小记录的关键字比较后的查找方法，其核心计算格式是：

key-a[low]/a[hight]-a[low]

### 散列表查找

解释：散列技术是在记录的储存位置和它的关键字之间建立一个确定的对应关系f，使得每个关键字key对应一个储存位置f(key)。查找时，根据这个确定的对应关系找到给定值key的映射f(key)，若查找集合中存在这个记录，则必定在f(key)的位置上。

这里我们把这种对应关系 称为散列函数又称为哈希 Hash 函数。按这个思想， 采用散列技术将记录存储在一块连续的存储空间中，这块连续存储空间称为散列表或哈希表，那么关键字对应的记录存储位置我们称为散列地址。

#### 散列表查找步骤

第一步：在储存时，通过散列函数计算记录的散列地址，并按此散列地址储存该记录。总之，不管记录什么，我们都需要用同一个散列函数计算出地址再储存。

![](http://9017499461.linshutu.top/%E6%95%A3%E5%88%97%E5%9B%BE.JPG)

第二步：当查找记录时，我们通过同样的散列函数计算记录的散列地址，按此散列地址访问该记录。说起来简单，在哪里存，在哪里找，由于存取用的是同一个散列函数，因此结果也是相同的。

所以说：散列技术既是一种储存方法，也是一种查找方法。散列技术最适合的求解问题时查找给定值相等的记录。

但是，散列技术不具备很多常规数据结构的能力。比如范围查找

还有就是冲突的问题：我们时常会碰到两个关键字一样的情况，这种现象我们称之为冲突，它的不可避免的。

#### 散列函数的构造方法

##### 直接定址法

我们可以去取关键字的某个线性函数值为散列地址。

```
f(key) = a*key+b（a，b为常数）
```

比如：如果我们现在要统计的是 80 后出生年份的人口数，那么我们 对出生年份这个关键字可以用年份减去 1980 来作为地址。此时( key) =key-1980

##### 数字分析法

如果我们的关键字是位数较多的数字，比如我们的 11 手机号 

"130x:xxx1234 *n*，其中前3位是接入号，一般对应不同运营商公司的子品牌，如 130 是联通如意通、 136 是移动神州行、 153 是电信等; 中间四位是 HLR 识别号，表示用 户号的归属地;后四位才是真正的用户号。

若我们现在要存储某家公司员工登记表，如果用手机号作为关键字，那么极有可能前7位都是相同的。那么我们选择后面的四位成为散列地址就是不错的选择。如果 这样的抽取工作还是容易出现冲突问题，还可以对抽取出来的数字再进行反转(如 1234 改成 4321 、右环位移(如 1234 改成 4123) 在环位移、甚至前两数与后两数 叠加(如 1234 改成 12 +34=46) 方法。总的目的就是为了提供一个散列函数，能够合理地将关键字分配到散列表的各位置。

这里，我们提到了一个关键词——抽取。抽取方法使用关键字的一部分来计算散列储存位置的方法，这在散列函数中是常常用到的手段。

数字分析法通常适合处理关键字位数比较大的情况，如果事先知道关键字的分布 且关键字的若干位分布较均匀，就可以考虑用这个方法。

##### 平均取中法

这个方法计算很简单，假设关键字是 1234 那么它的平方就是 1522756 ，再抽取 中间的3位就是 227 ，用做散列地址 再比如关键字是 4321 ，那么包的平方就是 18671041 ，抽取中间的 位就可以是 671 ，也可以是 71 ，用做散列地址。

平方取中 法比较适合子不知道关键字的分布，而位数又不是很大的情况。

##### 折叠法

折叠法是将关键 从左到右分割成位数相等的几部分(注意最后 部分位数不够 时可以短些) ，然后将这几部分叠加求和，并按散列表表长，取后几位作为散列地址。

比如我们的关键 9876543210 ，散列表表长为3位，我们将它分为四组， 9871654132110 然后将它们叠加求和 987+654+321+0=1962 ，再求后 位得到散列 地址为 962

折叠法事先不需要知道关键字的分布，适合关键字位数较多的情况。

##### 除留余数法

此方法为最常用的构造散列函数方法。

对于散列裴长为 的散列函数公式为: 

```
f ( key) = key mod p (p<=m)
```

就是取模运算，事实上，这方法不仅可以对关键子之接取模，也 

可在折叠、 平方取中后再取模。

很显然，这种方法的关键就在在于选择合适的p，p如果选的不好，就可能会容易产生同义词。

因此，根据前辈们的经验，若散列表表长为m，通常p为小于或者等于表长（最好接近m）的最小质数或不包含小于20的质因子的合数。

##### 随机数法

选择一个随机数，取关键字的随机函数值为它的散列地址，也就是f(key)=random(key)。当关键字的长度不等时，采用这个方法构造散列函数是比较合适的

### 处理散列冲突的方法

从上面取模的例子中可以看出，设计的再好的散列函数也不完全可避免冲突，那么我们就要考虑去解决他们。

#### 开放地址法

解释：所谓的开放地址法就是一旦发生冲突，就去寻找下一个 空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记存入 。

公式:
$$
f_f(key) = (f(key)+d_i)MODm (d_i=1,2,3....m-1)
$$
比如说，我仍的关键字集合为{12, 67 ,56 ,16 ,25 ,37, 22 ,29 ,15，4 7,48,34} 表长为12,那么，我们用散列函数f(key) = key  mod 12.

![](http://9017499461.linshutu.top/%E5%BC%80%E6%94%BE%E5%9C%B0%E5%9D%80%E6%B3%951.JPG)

![](http://9017499461.linshutu.top/%E5%BC%80%E6%94%BE%E5%9C%B0%E5%9D%80%E6%B3%952.JPG)

**线性探测**这个例子我们也看到，我们在解决冲突的时候，还会碰到如 48 37 这种本来都不是同义词却要争夺一个地址的情况，称这种现象为堆积。很显然，堆积的出现，使得我们需要不断处理冲突，无论是存入还是查找效率都会大大降低。

因此，我们改进的方式：
$$
f_i(key) = (f(key)+d_i)MODm (d_i=1^2,2^2,3^2....m-1^2)
$$
可以在关键在找位置的时候从两端开始查找，这就增加了一定的速度。另外，增加平方运算的目的是为了不让关键字都聚集在某一块区域，我们称这种方法为**二次探测法**。

还有一种方法，在冲突的时候，对于位移量d_i采用随机函数计算得到，我们称之为**随机探测法**。（这里的随机是一种伪随机数的方式，用的是相同的随机种子，不然的话我们查询的时候不就是随机的么）

#### 再散列函数法

对于我们的散列表来说，我们事先准备多个散列函数：
$$
f_i ( key ) =RH_i( key) (i=1 ,2,…,k)
$$
在这个公式里，RHi就是不同的散列函数，我们可以把前面说的什么取模、折叠、平方都使用上，每当发生散列地址冲突时，就换一个散列函数计算，相信总有一个可以把冲突解决掉。

#### 链地址发

换一下之前的思路，为什么有冲突就要换地方呢，是吧，我们直接在原地想办法不也可以吗。

我们将所有关键字为同一词的记录储存在一个单链表中，我们成这种表为同义词子表，在散列表中只储存同义词子表的头指针。

#### 公共溢出区法

凡是冲突的都跟我走，我给你们这些冲突找个地儿待着。这就如同孤儿院收留所有无家可归的孩子样，我们为所有冲突的关键字建立了一个公共的溢出区来存放.

在查找时，对给定值通过散列函数计算出散列地址后，先与基本表的对应位置进行对比，如果想等，查找成功；如果不想等，则到溢出表去进行顺序查找。如果对于基本表而言，有冲突的数据很少的情况下，公共溢出区的结构对查找性能来说还是非常高的。

### 散列表查找性能分析

如果没有冲突，散列查找是我们这里面查找效率最高的，因为它的时间复杂度是O(1)，可惜，这是理想的情况，在实际应用中，冲突是不可避免的，那么散列查找的平均查找长度取决哪些因素？

其一：散列函数是否均匀

散列函数的好坏直接影响着出现冲突的频繁程度，不过，由于不同的散列函数对 同一组随机的关键字，产生冲突的可能性是相同的，因此我们可以不考虑它对平均查找长度的影响

其二：处理冲突的方法

相同的关键字、相同的散列函数，但处理冲突的方法不同，会使得平均查找长度 不同。比如线性探测处理冲突可能会产生堆积，显然就没有二次探测法好，而链地址 法处理冲突不会产生任何堆积，因而具有更佳的平均查找性能。

其三：散列表的装填因子

所谓的装填因子α=填入表中的记录个数/散列表长度。 标志着散列表的装满的程 度。当填入表中的记录越多，a就越大，产生的冲突可能性也就越大。不管记录个数n有多大，我们总可以选择一个合适的装填因子以便平均查找长度限定在一定范围内，此时，我们散列查找时间复杂度就真的是O(1)。

为了做到这一点，通常我们都是将散列表的空间设置得比查找集合大，此时虽然是浪费了一定的空间，但换来的是查找效率的大大提升。是一种空间换时间的典型案例。