---
title: 理论第四讲——数据结构算法之串、树、二叉树、图
id: 7
date: 2019-11-6 20:00:00
tags: 数据结构与算法
comment: true
---

### 串

解释：串（string）就是字符串。

串的抽象数据类型：串的逻辑结构和线性表很相似，不同之处在于串针对的是字符集，也就是串中的元素都是字符。但是，对于串的操作与线性表的操作是有很大的差别的。线性表更加关注的是单个元素的操作，对一个元素的增删查改，但是串中更多的是单个元素得到指定位置子串、替换子串等操作。

<!----more---->

### 串的储存结构

#### 串的顺序储存结构

解释：串的顺序储存结构是用一组地址连续的储存单元来储存串中的字符序列的。按照预定义的大小，为每个定义的串变量分配一个固定长度的储存区。一般是用定常数组来定义的。

#### 串的链式储存结构

解释：对于串的链式储存结构，与线性表是相似的，但由于串结构的特殊性，结构中的每个元素的数据是一个字符，如果也简单的应用链表储存串值，一个节点对应一个字符，就会存在很大的空间浪费，因此，一个节点也可以存放多个字符，最后一个节点若是未被占满，可以使用额数字符#等补全。

串的链式存储结掏除了在连接串与串操作时有 定方便之外，总的来说不如顺 序存储灵活 ，性能也不如顺序存储结构好。

### 树

解释：树是n(n>=0)个节点的有限集。n = 0时成为空树；在任意一颗非空树中：1，有且仅有一个特定的称为根节点；2，当n>1时，其余接待你可分为m(m>0)个互不相交的有限集，T1、T2...Tn，其中每一个集合本身又是一棵树，并且称为根的子树。

注意：

- n>0时根是唯一的。
- m>0时子树的个数没有限制，但他们一定是互不相交的

#### 结点的分类

节点拥有的子树数称为节点的度。度为0的节点称为叶节点或终端节点；度不为0的节点成为非终端节点或分支节点。

![](http://9017499461.linshutu.top/%E6%A0%911.JPG)

#### 结点间的关系

- 结点的子树的根称为该结点的孩子，相应的，该节点称为孩子的双亲。

- 同一双亲的孩子之间称为兄弟。

- 结点的祖先是从根到该结点所经分支上的所有结点。

- 以某结点为根的子树中任意一个结点都称为该结点的子孙。

#### 树的其他概念

树中结点的最大层数称为数的深度或者高度。

![](http://9017499461.linshutu.top/%E6%A0%912.JPG)

当前树的深度为4.

如果将树种结点的各子树看成从左至右是有次序的，不能互换的，则称该树为有序树，否则就叫做无序树。

#### 对比线性结构和树结构

线性结构：

- 第一个数据元素：无前驱
- 最后一个数据元素：无后继
- 中间元素：一个前驱一个后继

树结构：

- 根结点：无双亲，唯一
- 叶结点：无孩子，可以多个
- 中间结点：一个双亲，多个孩子

### 二叉树

解释：二叉树是n（n>=0）个结点的有限集合，该集合或者为空集，或者由一个根结点和两颗互不相交的、分别称为根结点的左子树和右子树的二叉树组成。

#### 二叉树的特点

- 每个结点最多有两颗子树（可以是一颗子树或没有子树），所以二叉树中不存在度大于2的结点
- 左子树和右子树是有顺序的，次序不能任意颠倒。
- 即使树中某节点只有一个子树，也要区分它是左子树还是右子树。

二叉树的五种基本形态：

![](http://9017499461.linshutu.top/%E4%BA%8C%E5%8F%89%E6%A0%911.JPG)

- 空二叉树
- 只有一个根节点：图2345
- 根结点只有左子数：图2
- 根结点只有右子数：图5
- 根节点既有左子数又有右子数：图1

#### 特殊二叉树

##### 斜树

解释：所有的结点都只有左子树的二叉树叫做左斜树；所有结点都是只有右子树的二叉树叫做右斜树，统称斜树。线性结构斜树，它是树的一种及其特殊的表现形式。

##### 满二叉树

解释：在一颗二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树。

特点：

- 叶子结点只能出现在最下面一层。
- 非叶子结点的度一定为2。
- 在同样深度的二叉树中，满二叉树的结点个数最多，叶子最多。

![](http://9017499461.linshutu.top/%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91.JPG)

##### 完全二叉树

解释：对一棵具有n个结点的二叉树按层序编号，如果编号为i(1<=i<=n)的节点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同，那么这棵二叉树就称作完全二叉树。

![](http://9017499461.linshutu.top/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91.JPG)

注意：满二叉树一定是一棵完全二叉树，但是完全二叉树不一定是满的。

完全二叉树特点：

- 叶子结点只能出现在最下面两层
- 最下层的叶子一定集中在左部连续位置
- 倒数二层，若有叶子结点，一定都在右部连续位置
- 如果结点深度为1，则该节点只有左孩子，即不存在只有右子树的情况
- 同样结点数的二叉树，完全二叉树的深度最小

判断一个完全二叉树：

看树的示意图，心中默默给每个结点按照满二叉树的结构足层顺序编号，若编号出现空挡，就说明不是完全二叉树，反之。

#### 二叉树的性质

##### 性质一

在二叉树的第i层上最多有2^i-1个结点（i>=1）

##### 性质二

深度为k的二叉树最多有2^k-1个结点(k>=1)

##### 性质三

对任何一个二叉树T，如果其终端结点数为n0,度为2的结点数为n2，则n0=n2+1

![](http://9017499461.linshutu.top/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%80%A7%E8%B4%A83.JPG)

##### 性质四

具有n个结点的完全二叉树的深度为log2n + 1 

### 二叉树的储存结构

##### 二叉树的顺序储存结构

解释：二叉树的顺序储存结构就是用一堆数组储存二叉树中的结点，并且节点的储存位置，也就是数组的下标要能体现结点之间的逻辑关系，比如双亲和孩子的关系，兄弟之间的关系。

完全二叉树储存：

![](http://9017499461.linshutu.top/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%82%A8%E5%AD%98%E7%BB%93%E6%9E%84.JPG)

一般二叉树的储存：

对于不存在的结点，设置"^"

![](http://9017499461.linshutu.top/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%82%A8%E5%AD%98%E7%BB%93%E6%9E%842.JPG)

结论：顺序储存结构一般只用于完全二叉树

##### 二叉树的链式储存结构

解释：二叉树每个结点最多有两个孩子，所以为它设计一个数据域和两个指针域是比较自然的想法，我们成这样的链表叫做二叉链表。

| 左孩子 | 数据域 | 右孩子 |
| :----: | :----: | :----: |
| lchild |  data  | rchild |

![](http://9017499461.linshutu.top/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%93%BE%E5%BC%8F%E5%82%A8%E5%AD%98.JPG)

### 遍历二叉树（***）

##### 二叉树遍历原理

解释：二叉树的遍历是指从根节点出发，按照某种**次序**依次**访问**二叉树中所有节点，使得每个节点被访问一次且被访问一次。

##### 二叉树遍历方法

###### 前序遍历

原理：二叉树为空，则空操作返回，否则先访问根结点，然后前序遍历左子树，再前序遍历右子树。

![](http://9017499461.linshutu.top/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86.JPG)

###### 中序遍历

原理：若树为空，则空操作返回，否则从根节点开始（非根节点才是访问），中序遍历根结点的左子树，然后访问根结点，追后中序遍历右子树。

![](http://9017499461.linshutu.top/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.JPG)

###### 后序遍历

原理：若树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历访问左右子树，最后访问根结点。

![](http://9017499461.linshutu.top/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86.JPG)

###### 层序遍历

原理：若树为空，则操作返回，否则从树的第一层，也就是根结点开始访问，从上而下足层遍历，在同一层中，按照从左到右的顺序对结点逐个访问。

![](http://9017499461.linshutu.top/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%20.JPG)

### 树、深林与二叉树的转换

##### 树转为二叉树

步骤：

1.加线。在多有兄弟结点之间加一条连线。

2.去线。对树中每个结点，只保留它与第一个孩子结点的连线，删除它与其他孩子结点之间的连线。

3.层次调整。以树的根结点为轴心，将整棵树顺序指针旋转一定的角度，使之结构层次分明。

![](http://9017499461.linshutu.top/%E6%A0%91%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91%20-%20%E5%89%AF%E6%9C%AC.JPG)

##### 森林转换为二叉树

步骤：

1.把每棵树转换成二叉树

2.第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根节点作为前棵二叉树的根结点的右孩子，用线连接起来。当所有的二叉树连接起来后 就得到了由森林转换来的二叉树。

![](http://9017499461.linshutu.top/%E6%A3%AE%E6%9E%97%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%A0%91%20-%20%E5%89%AF%E6%9C%AC.JPG)

##### 二叉树转换成树

步骤：

1.加线。若某结点的左孩子结点存在，则将这个左孩子的右孩子结点、右孩子的 右孩子结点、右孩子的右孩 的右孩子结点……哈，反正就是左孩子的n个右孩子结点都作为此结点的孩子。将该结点与这些右孩子结点用线连接起来。

2.去线。删除原 叉树中所有结点与其右孩子结点的连线。

3.层次分明。

![](http://9017499461.linshutu.top/%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BD%AC%E6%88%90%E6%A0%91%20-%20%E5%89%AF%E6%9C%AC.JPG)

##### 二叉树转换成森林

判断一棵二叉树能够转换成 棵树还是 林，标准很简单 那就是只要看这棵 二叉树的根结点有没有右孩子，有就是森林，没有就是 棵树.那么如果是转换成森 林，步骤如下 

1.从根结点开始 若右孩子存在，则把与右孩子结点的连线删除 ，再查看分离后 的二叉树，若右孩子存在，则连续 除……，直到所有右孩子连线都删除为 止，得到分离的 二叉树。

2.再将没棵分离后的二叉树转换成树即可。

![](http://9017499461.linshutu.top/%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BD%AC%E6%8D%A2%E6%88%90%E6%A3%AE%E6%9E%97%20-%20%E5%89%AF%E6%9C%AC.JPG)

### 赫夫曼树

解释：从树中一个节点到另一个结点之间的分支构成两个节点之间的路径，路径上的分支数目称作路径长度。

![](http://9017499461.linshutu.top/%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91.JPG)

上图中的二叉树a中，根节点到节点D的路径长度是4，二叉树b中根结点到结点D的路径长度是2.树的路径长度就是从树根到每一个结点的路径长度之和。

所以，二叉树a树路径长度就是1+1+2+2+3+3+4+4=20，

​			二叉树b树路径长度就是1+1+2+2+2+2+3+3=16.

如果考虑到带权的结点，结点的带权的路径长度为从该结点到树根之间的路径长度与结点上权的乘积。树的带权路径长度为树中所有叶子结点的戴荃路径长度之和。

假设有 个权值{W1，W2.... Wn} ，构造一棵有 叶子结点的二叉树，每个叶子结点带 Wk，每个叶子的路径长度为 1k ，则其中带权路径长度 WPL 最小的二叉树称做**赫夫曼树** 有不少书中也称为**最优二叉树**

所以，

```
二叉树a的WPL=5*1+15*2+40*3+30*4+10*4=315
二叉树b的WPL=2*10+2*30+2*40+3*15+3*5=220
```

至于构造就不讲了，比较麻烦。

### 图

解释：图是由定点的有穷非空集合和定点之间的集合组成，通常表示为：G(V,E),其中，G表示一个图，V表示图G中定点的集合，E是图中边的集合。

### 图的遍历

解释：我们希望从图中某一定点触发访遍图中其余顶点，且使每一个顶点仅被访问一次，这一过程叫做图的遍历。

#### 深度优先遍历

打个比喻：比如主 卧室，然后从房间的一个角开始，将房间内的墙角、床头柜、床上、床下、衣柜里、 衣柜上、前面的电视柜等挨个寻找， 做到不放过任何 个死角，所有的抽屉、储藏柜 中全部都找遍，形象比喻就是翻个底朝天，然后再寻找下一间，直到找到为止。

解释：从图中某个顶点v出发，访问此顶点，然后从v的未被访问的邻接点出发深度优先遍历图，直到图中多有和v有路径相通的顶点都被访问到；若图中尚有顶点未被访问，则另选图中一个未曾被访问的顶点作起始点，重复上述的过程，知道图中所有的顶点都被访问到为止

#### 广度优先遍历

打个比喻：还是以 找钥匙的例子为例。小孩子不太可能把钥匙丢到大衣柜顶上或厨房的抽烟机里去，深 度优先遍历意味着要彻底查找完一个房间才查找下 个房间，这未必是最佳方案 。所以不妨先把家里的所有房间简单看一遍，看看钥匙是不是就放在很显眼的位置， 如果全走 遍没有，再把小孩在每个房间玩得最多的地方或各个家俱的下面找一找， 如果还是没有，那看一下每个房间的抽屉，这样一步步扩大查找的范围，直到找到为止 。事实上，我在全屋查找的第 遍时就在抽水马桶后面的地板上找到了

这里还要再多说儿旬，对于深度和广度而言，已经不是简单的算法实现问题，完 全可以上升到方法论的角度。你求学是博览群书、不求甚解，还是深钻细研、鞭辟入 里;你旅摒是走马观花、蜻蜓点水，还是下马看花、深度体验;你交友是四海之内皆 兄弟，还是人生得 知巴足矣……其实都先对错之分，只视末同人的理解而有了不同 的诠释。我个人觉得深度和广度是既矛盾叉统 的两个方面，偏颇都不可取，还望大 家自己慢慢体会。