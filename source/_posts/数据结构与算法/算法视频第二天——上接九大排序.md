---
title: 算法视频第二天——上接九大排序、数据结构初始
id: 2
date: 2019-11-1 20:00:00
tags: 数据结构与算法
comment: true
---

#### 堆排序

树->二叉树->完全二叉树

堆：

大根堆：一棵完全二叉树，满足任一节点都比其孩子结点大（降序排列）

小根堆：一棵完全二叉树，满足任一节点都比其孩子结点小(升序排列)

```python
import random
from cal_time import *


def sift(li, low, high):
	tmp = li[low]
	i = low   # i 指向当前选举的空位
	j = 2 * i + 1 # ｊ和j+1是两个候选人
	while j <= high:  # 说明还有候选人 第2中退出条件: loser被一撸到底
		if j + 1 <= high and li[j+1] > li[j]: #如果右孩子存在并且比左孩子大
			j += 1      # j指向之上更高的候选人
		if li[j] > tmp: # 候选人上位
			li[i] = li[j] # 完成上位，产生了新的空位
			i = j
			j = 2 * i + 1
		else: # tmp >= li[j]  loser比候选人大，上位
			break #第一种退出条件：loser还能管一些人
	li[i] = tmp

@cal_time
def heap_sort(li):
	n = len(li)
	# 1. 建堆
	for low in range(n//2-1, -1, -1):
		sift(li, low, n-1)
	# 2. 挨个出数：退休，棋子，调整
	for high in range(n-1, 0, -1):
		li[0], li[high] = li[high], li[0] # 退休+棋子
		sift(li, 0, high-1)

li = list(range(100000))
random.shuffle(li)
heap_sort(li)
```

实例：

现在有n个数，设计算法找出前k大的数(k<n)

```
方法一：排序后切片(nlogn)
方法二:LowB三人组(做k趟就行，kn)
方法三：做一个k长的列表，往里插，比里面大就把里面的踢出去。
```



#### 归并排序

思路：

- 分解：将列表越分越小，直到分成一个元素。
- 终止条件：一个元素是有序的。
- 合并：将两个有序列表归并，列表越来越大。

![](http://9017499461.linshutu.top/%E5%BD%92%E5%B9%B6%E7%AE%97%E6%B3%95.JPG)

<!----more---->

```python
def merge(li, left, mid, right): #列表li[left:right+1]部分[left:mid+1][mid+1:right+1]两段有序
	i = left
	j = mid + 1
	li_tmp = []
	while i <= mid and j <= right:
		if li[i] <= li[j]:
			li_tmp.append(li[i])
			i += 1
		else:
			li_tmp.append(li[j])
			j += 1
	while i <= mid:
		li_tmp.append(li[i])
		i += 1
	while j <= right:
		li_tmp.append(li[j])
		j += 1
	# for k in range(0, right-left+1):
	# 	li[left+k] = li_tmp[k]
	for k in range(left, right+1):
		li[k] = li_tmp[k-left]


# 排序li的left~right部分
def _merge_sort(li, left, right):
	if left < right: # 一个元素有序，两个及以上的元素才排序
		mid = (left + right) // 2 # 列表两部分 left~mid mid+1~right # 分解
		# print(li[left:mid+1], li[mid+1:right+1])
		_merge_sort(li, left, mid)
		_merge_sort(li, mid+1, right)
		merge(li, left, mid, right)  # 合并
		# print(li[left:right+1])

@cal_time
def merge_sort(li):
	_merge_sort(li, 0, len(li)-1)

li = list(range(100000))
random.shuffle(li)
merge_sort(li)

#时间复杂度：O(nlgn)
#空间复杂度：O(n),使用了额外的空间
```

扩展：

稳定排序和不稳定排序：（比如快排就是一个不稳定排序，不能保证原来该数的位置还在原来的位置）

不常用的排序算法

![](http://9017499461.linshutu.top/%E6%8E%92%E5%BA%8F%E5%B0%8F%E7%BB%93.JPG)

#### 基数排序

```python
import random
from cal_time import *

@cal_time
def radix_sort(li):
	max_num = max(li) # 123
	i = 0
	while 10 ** i <= max_num:  # 10**i表示i位数里的最小的 i=0个位 i=1十位
		buckets = [[] for _ in range(10)]
		for val in li:
			digit = val // (10 ** i) % 10
			buckets[digit].append(val)
		li.clear()
		for bucket in buckets:
			for val in bucket:
				li.append(val)
		i += 1

li = list(range(100000))
random.shuffle(li)
sys_sort(li)

```

#### 希尔排序

希尔排序每趟并不是使某些元素有序，而是使整体数据越来越接近有序；最后一趟排序使得所有数据有序。

#### 桶排序

解释：首先将元素分在不同的桶里，再对每个桶中的元素排序。

桶排序的表现取决于数据的分布，也就是需要对不同数据排序采取不同的分桶策略。

平均情况：O(n+k)

最坏情况：O(n2k)

空间复杂度：O(nk)

