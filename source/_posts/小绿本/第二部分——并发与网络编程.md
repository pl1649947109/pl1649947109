---
title: 第二部分——并发与网络编程
id: 2
date: 2019-10-21 20:00:00
tags: 小绿本
toc: true
comment: true
---

### 1. 简述 OSI 七层协议。

![img](https://images2018.cnblogs.com/blog/1258691/201805/1258691-20180529095800367-902368750.png)

物理层：主要是基于电器特性发送高低电压（电信号），高电压对应数字1，低电压对应数字0

数据链路层：定义了电信号的分组方式

网路层：引入一套新的地址用来区分不同的广播域/子网，这套地址即网络地址

传输层：建立端口到端口的通信

会话层：建立客户端与服务端连接

表示层：对来自应用层的命令和数据进行解释，按照一定格式传给会话层。如编码、数据格式转换、加密解密、压缩解压
应用层：规定应用程序的数据格式

<!----more---->

### 2. 什么是C/S和B/S架构？

c/s架构，就是client（客户端）与server（服务端）即：客户端与服务端的架构。

b/s架构，就是brosver（浏览器端）与sever（服务端）即：浏览器端与服务端架构

优点：统一了所有应用程序的入口、方便、轻量级

### 3. 简述 三次握手、四次挥手的流程。

```
三次握手：
    第一次握手
1：客户端先向服务端发起一次询问建立连接的请求，并随机生成一个值作为标识
    第二次握手
2：服务端向客户端先回应第一个标识，再重新发一个确认标识
    第三次握手
3：客户端确认标识，建立连接，开始传输数据
    
```

```
四次挥手 ---> 断开连接
第一次挥手
    客户端向服务端发起请求断开连接的请求
第二次挥手
    服务端向客户端确认请求
第三次挥手
    服务端向客户端发起断开连接请求
第四次挥手
    客户端向服务端确认断开请求
```

### 4. TCP和UDP的区别？

```
TCP/UDP区别
 TCP协议是面向连接，保证高可靠性传输层协议
 UDP：数据丢失，无秩序的传输层协议（qq基于udp协议）
```

### 5. 为何基于tcp协议的通信比基于udp协议的通信更可靠？

```
tcp：可靠，因为只要对方回了确认收到信息，才发下一个，如果没收到确认信息就重发
UDP：不可靠，它是一直发数据，不需要对方回应
流式协议： TCP协议，可靠传输
数据报协议: UDP协议，不可传输
```

### 6. 什么是socket？简述基于tcp协议的套接字通信流程。

```
Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部。

服务端：创建socket对象，绑定ip端口bind(), 设置最大链接数listen(),  accept()与客户端的connect()创建双向管道，等到联接， send(), recv(), 收发数据close()

客户端：创建socket对象，connect()与服务端accept()创建双向管道 ,  send(), recv(),close()
```

### 7. 什么是粘包？ socket 中造成粘包的原因是什什么？ 哪些情况会发生粘包现象？

```
只有TCP有粘包现象，UDP永远不会粘包粘包：在获取数据时,出现数据的内容不是本应该接收的数据,如:对方第一次发送hello,第二次发送world,　　我方接收时,应该收两次,一次是hello,一次是world,但事实上是一次收到helloworld,一次收到空,这种现象叫粘包

原因
粘包问题主要还是因为接收方不知道消息之间的界限，不知道一次性提取多少字节的数据所造成的。

什么情况会发生：
1、发送端需要等缓冲区满才发送出去，造成粘包（发送数据时间间隔很短，数据了很小，会合到一起，产生粘包）

2、接收方不及时接收缓冲区的包，造成多个包接收（客户端发送了一段数据，服务端只收了一小部分，服务端下次再收的时候还是从缓冲区拿上次遗留的数据，产生粘包）
```

### 8. IO多路复的作用？

socketserver，多个客户端连接，单线程下实现并发效果，就叫多路复用。

与多进程和多线程技术相比，I/O多路复用技术的最大优势是系统开销小，系统不必创建进程/线程，也不必维护这些进程/线程，从而大大减小了系统的开销。

### 9.select、poll、epoll 模型的区别？（属于多路复用IO的模型)

```
都是i/o多路复用的机制，监视多个socket是否发生变化，本质上都是同步i/o
    select,poll实现需要自己不断轮询所有监测对象，直到对象发生变化，在这个阶段中，可能要睡眠和唤醒多次交替，而epoll也需要调用epoll_wait不断轮询就绪链表，但是当对象发生变化时，会调用回调函数，将变化的对象放入就绪链接表中，并唤醒在epoll_wait中进入睡眠的进程。虽然都会睡眠和唤醒，但是select和poll在被唤醒的时候要遍历整个监测对象集合，而epoll只要判断就绪链表是否为空即可，节省了大量cpu的时间
```

```
 select、poll、epoll都是IO多路复用的机制，但select，poll，epoll本质上都是同步I/O，
 因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的.

FD(文件描述符)
select模型
优点：
    1：可移植性好，在某些Unix系统不支持poll()
    2：对于超时值提供了更好的精度：微妙，而poll是毫秒
缺点：
    1:最大并发数限制，因为一个进程所打开的 FD （文件描述符）是有限制的，由 FD_SETSIZE 设置，默认值是 1024/2048 ，因此 Select 模型的最大并发数就被相应限制了。
    2：效率问题，select每次调用都会线性扫描全部的FD集合，所以将FD_SETSIZE 改大，会越慢
    3：需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大。 

poll本质上和select 没有区别，它将用户传入的数组拷贝到内核空间，
它没有最大连接数的限制，原因是它基于链表来存储的但是同样有一个缺点：
大量的fd的数组被整体复制于用户态和内核地址空间，而不管这样的复制是不是有意义
```

### 10. 什么是防火墙以及作用？

```
防火墙是一个分离器、一个限制器，也是一个分析器，有效地监控了内部网和Internet之间的任何活动，保证了内部网络的安全

作用
防火墙是网络安全的屏障
可以强化网络安全策略
对网络存取和访问进行监控审计
防止内部信息的外泄
除了安全作用，防火墙还支持具有Internet服务特性的企业内部网络技术体系VPN（虚拟专用网）。
```

### 11. 简述 进程、线程、协程的区别 以及应用场景?

```
线程是指进程内的一个执行单元，
# 进程
进程拥有自己独立的堆和栈，既不共享堆，亦不共享栈，进程由操作系统调度。
# 线程
线程拥有自己独立的栈和共享的堆，共享堆，不共享栈，线程亦由操作系统调度
# 协程和线程
协程避免了无意义的调度，由此可以提高性能；但同时协程也失去了线程使用多CPU的能力

进程与线程的区别
（1）地址空间：线程是进程内的一个执行单位，进程内至少有一个线程，他们共享进程的地址空间，而进程有自己独立的地址空间
（2）资源拥有：进程是资源分配和拥有的单位，同一个进程内线程共享进程的资源
（3）线程是处理器调度的基本单位，但进程不是
（4）二者均可并发执行
（5）每个独立的线程有一个程序运行的入口

协程与线程
（1）一个线程可以有多个协程，一个进程也可以单独拥有多个协程，这样Python中则能使用多核CPU
（2）线程进程都是同步机制，而协程是异步
（3）协程能保留上一次调用时的状态
```

### 12. GIL锁是什么？

GIL本质就是一把互斥锁，既然是互斥锁，所有互斥锁的本质都一样，都是将并发运行变成串行，以此来控制同一时间内共享数据只能被一个任务所修改，进而保证数据安全。

GIL保护的是解释器级的数据，保护用户自己的数据则需要自己加锁处理

```
应用（总结）：
多线程用于IO密集型，如socket，爬虫，web
多进程用于计算密集型，如金融分析
  1. 每个cpython进程内都有一个GIL
  2. GIL导致同一进程内多个进程同一时间只能有一个运行
  3. 之所以有GIL，是因为Cpython的内存管理不是线程安全的
  4. 对于计算密集型用多进程，多IO密集型用多线程
```

### 13. Python中如何使用线程池和进程池？

```
什么时候用池：
	-池的功能是限制启动的进程数或线程数，当并发的任务数远远超过了计算机的承受能力时，即无法一次性开启过多的进程数或线程数时，就应该用池的概念将开启的进程数或线程数限制在计算机可承受的范围内。
```

###  14. threading.local的作用？

```
实现线程局部变量的传递。

ThreadLocal 最常用的地方：
	-为每个线程绑定一个资源（数据库连接，HTTP请求，用户身份信息等），这样一个线程的所有调用到的处理函数都可以非常方便地访问这些资源。
```

### 15. 进程之间如何进行通信？

3种方式，但是只讲了两种：

```
基于文件的通信
基于队列的通信
基于管道的通信
```

https://chpl.top/2019/08/21/%E4%B9%A6/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/%E7%AC%AC%E4%B8%89%E5%8D%81%E4%BA%8C%E8%AE%B2%E2%80%94%E2%80%94%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E3%80%81%E4%BA%92%E6%96%A5%E9%94%81/

###  16. 什么是并发和并行？

```
# 并发：同一时刻只能处理一个任务，但一个时段内可以对多个任务进行交替处理(一个处理器同时处理多个任务)
# 并行：同一时刻可以处理多个任务(多个处理器或者是多核的处理器同时处理多个不同的任务)
# 类比：并发是一个人同时吃三个馒头，而并行是三个人同时吃三个馒头。 
```

### 17. 进程锁和线程锁的作用？

```
在这里就是保证进程之间数据的共享，但是我们不能让他们乱来，要让他们一个一个的串行使用，所以互斥锁就是实现这个功能的一个工具。（线程锁同理）
```

###  18. 解释什么是异步非阻塞？

```
非阻塞：不等待
即：遇到IO阻塞不等待(setblooking=False),（可能会报错->捕捉异常）
        - sk=socket.socket()
        - sk.setblooking(False)
异步：回调，当达到某个指定的状态之后，自动调用特定函数

实例
nb_async.py   实现异步非阻塞的模块
```

```
异步体现在回调上，回调就是有消息返回时告知一声儿进程进行处理。非阻塞就是不等待，不需要进程等待下去，继续执行其他操作，不管其他进程的状态。
```

### 19. 路由器和交换机的区别

```
1：交换机：是负责内网里面的数据传递（arp协议）根据MAC地址寻址
   路由器：在网络层，路由器根据路由表，寻找该ip的网段
2：路由器可以处理TCP/IP协议
3：路由器可以把一个IP分配给很多个主机使用，这些主机对外只表现出一个IP。
   交换机可以把很多主机连起来，这些主机对外各有各的IP。
4：交换机是做端口扩展的，也就是让局域网可以连进来更多的电脑。
  路由器是用来做网络连接，也就是；连接不同的网络
```

### 20.什么是域名解析？

```
在互联网上，所有的地址都是ip地址，现阶段主要是IPv4（比如：110.110.110.110）。
但是这些ip地址太难记了，所以就出现了域名（比如http://baidu.com）。
域名解析就是将域名，转换为ip地址的这样一种行为。
```

### 21.如何修改本地hosts件？

```
Hosts是一个没有扩展名的系统文件，可以用记事本等工具打开，其作用就是将一些常用的网址域名与其对应的IP地址建立一个关联“数据库”，当用户在浏览器中输入一个需要登录的网址时，系统会首先自动从Hosts文件中寻找对应的IP地址，一旦找到，系统会立即打开对应网页，如果没有找到，则系统会再将网址提交DNS域名解析服务器进行IP地址的解析。

浏览器访问网站，要首先通过DNS服务器把要访问的网站域名解析成一个唯一的IP地址，之后，浏览器才能对此网站进行定位并且访问其数据。

文件路径：C:\WINDOWS\system32\drivers\etc。
将127.0.0.1   www.163.com  添加在最下面
修改后用浏览器访问“www.163.com”会被解析到127.0.0.1，导致无法显示该网页。
```

### 22.生产者消费者模型应用场景及优势？

```
生产者与消费者模式是通过一个容器来解决生产者与消费者的强耦合关系，生产者与消费者之间不直接进行通讯，而是利用阻塞队列来进行通讯，生产者生成数据后直接丢给阻塞队列，消费者需要数据则从阻塞队列获取，实际应用中，生产者与消费者模式则主要解决生产者与消费者生产与消费的速率不一致的问题，达到平衡生产者与消费者的处理能力，而阻塞队列则相当于缓冲区。

应用场景：用户提交订单，订单进入引擎的阻塞队列中，由专门的线程从阻塞队列中获取数据并处理

优势：
1；解耦
假设生产者和消费者分别是两个类。如果让生产者直接调用消费者的某个方法，那么生产者对于消费者就会产生依赖（也就是耦合）。
将来如果消费者的代码发生变化，可能会影响到生产者。而如果两者都依赖于某个缓冲区，两者之间不直接依赖，耦合也就相应降低了。
2：支持并发
生产者直接调用消费者的某个方法，还有另一个弊端。由于函数调用是同步的（或者叫阻塞的），在消费者的方法没有返回之前，生产者只能一直等着
而使用这个模型，生产者把制造出来的数据只需要放在缓冲区即可，不需要等待消费者来取

3：支持忙闲不均
缓冲区还有另一个好处。如果制造数据的速度时快时慢，缓冲区的好处就体现出来了。
当数据制造快的时候，消费者来不及处理，未处理的数据可以暂时存在缓冲区中。等生产者的制造速度慢下来，消费者再慢慢处理掉。30.简述 asynio模块的作用和应用场景。
```


23.简述 gevent模块的作用和应用场景。

https://blog.csdn.net/qq_40890660/article/details/100173367

24.twisted框架的使用和应用

```
Twisted是一个事件驱动型的网络模型。事件驱动模型编程是一种范式，这里程序的执行流由外部决定。特点是：包含一个事件循环，当外部事件发生时，使用回调机制来触发相应的处理。
```

25.通过yield如何实现一个协程？

```python
import time
def consume():
    r = ''
    while True:
        n = yield r
        if not n:
            return
        print('[consumer] consuming %s...' % n)
        time.sleep(1)
        r = 'well received'

def produce(c):
    next(c)
    n = 0
    while n < 5:
        n = n + 1
        print('[producer] producing %s...' % n)
        r = c.send(n)
        print('[producer] consumer return: %s' % r)
    c.close()
    
if __name__=='__main__':
    c = consume()
    produce(c)
    
1.首先调用consume函数，consume函数的返回是一个生成器，把这个生成器传入produce函数。
2.produce函数中调用next(c)启动生成器。
3..计算 n = n+1 生成数据，一旦生产了数据，调用 c.send(n) 切换到consume执行。
4.consume函数中拿到数据后赋值给n，继续执行yield后面的语句。
5.consume函数中打印消费的数据，并设置返回值r，又回到循环的开始，通过yield把结果传回。
6.produce拿到consume返回的值，继续生产下一个数据。
7.5个数据生产完毕后，循环结束，通过c.close()关闭consume，结束全过程。
```

26.async/await关键字？

https://blog.csdn.net/qq_40890660/article/details/100173367

27.socket长连接是什么意思？

```
长连接是整个通讯的过程，客户端和服务端只用一个Socket对象，长期保持Socket的连接；
短连接就是每次请求，都会新建一个Socket，处理完一个请求就直接关闭掉Socket。
```

28.time_wait过多的原因是因为什么？

```
TIME_WAIT 是什么：
	-关闭 TCP 连接过程中，第 4 次挥手时，服务器发送了 ACK 报文段之后，服务器会进入 TIME_WAIT 状态，这是为了确保客户机能够正确地关闭、释放资源。TIME_WAIT状态将持续2个MSL(Max Segment Lifetime)，TIME_WAIT状态下的socket不能被回收使用。
	
TIME_WAIT 过多的原因：
	-对于一个处理大量短连接的服务器，如果是由服务器主动关闭客户端的连接，将导致服务器存在大量的处于TIME_WAIT状态的socket，严重影响服务器的处理能力，甚至耗尽可用的socket。
```

