### python基础

### socket和并发编程

### 数据库

### 前端

### django

### drf

<!----more---->

#### APIView视图方式

```python
class ArticleView(APIView):
    def get(self,request,*args,**kwargs):
        pk = kwargs.get('pk')
        if not pk:
            queryset = models.Article.objects.all()
            ser = serializer.ArticleSerializer(instance=queryset,many=True)
            return Response(ser.data)
        article_object = models.Article.objects.filter(id=pk).first()
        ser = serializer.ArticleSerializer(instance=article_object, many=False)
        return Response(ser.data)

    def post(self,request,*args,**kwargs):
        ser = serializer.ArticleSerializer(data=request.data)
        if ser.is_valid():
            ser.save()
            return Response(ser.data)
        return Response(ser.errors)

    def put(self,request,*args,**kwargs):
        """全部更新"""
        pk = kwargs.get('pk')
        article_object = models.Article.objects.filter(id=pk).first()
        ser = serializer.ArticleSerializer(instance=article_object,data=request.data)
        if ser.is_valid():
            ser.save()
            return Response(ser.data)
        return Response(ser.errors)

    def patch(self,request,*args,**kwargs):
        """局部"""
        pk = kwargs.get('pk')
        article_object = models.Article.objects.filter(id=pk).first()
        ser = serializer.ArticleSerializer(instance=article_object, data=request.data,partial=True)
        if ser.is_valid():
            ser.save()
            return Response(ser.data)
        return Response(ser.errors)

    def delete(self,request,*args,**kwargs):
        pk = kwargs.get('pk')
        models.Article.objects.filter(id=pk).delete()
        return Response('删除成功')
```

#### 序列化与关联表数据的展示

```python
#外键关联的表的数据的展示

#方式一
class
ArticleSerializer(serializers.ModelSerializer):
	class Meta:
    	model = models.Article
        fields = "__all__"
        #这个意思就是展示深度，默认展示的深度是0,就是只展示我们的第一张表的信息，它的范围是0-10，最多关联10张表的展示，但是不推荐使用这种方式，因为这种方式展示的不需要的东西太多。
        depth = 1

#方式二
class
ArticleSerializer(serializers.ModelSerializer):
    #这种方式就是使用这个方法里面的source源，用它就可以跨表查询我们需要的字段，后面的required=True这里是我们在写入数据不需要传值，不然就会报错
	    category_txt = serializers.CharField(source='category.name',required=False)
    class Meta:
    	model = models.Article
        fields = ['title'...'category_txt']

#方式三
class
ArticleSerializer(serializers.ModelSerializer):
    x1 = serializers.SerializerMethodField()
    class Meta:
    	model = models.Article
        fields = ['title'...'category_txt']
        
    def get_x1(self,obj):
        #这种方式和上面的一样，这个obj就是我们针对表数据一条条的查，这里的obj就是Article，obj查到category，它就是一个跨表的category对象
        return obj.category.name
    
#本表内choice字段类型数据的展示
from rest_framework import serializers
from api import models
class ArticleSerializer(serializers.ModelSerializer):
    #上面的方式二：这里也是使用之前的方式，但是没有加括号：因为drf为我们做了一步，检测到它是一个方法就加括号执行，没有检测到就找对应的属性
    status_txt = serializers.CharField(source='get_status_display',required=False)

    x2 = serializers.SerializerMethodField()
    class Meta:
        model = models.Article
        fields = ['id','title','summary','content','category',,'status_txt',,'x2']

    #上面的方式三：这个就正常了，直接加括号
    def get_x2(self,obj):
        return obj.get_status_display()  #这个是不是和我们的ModelForm一样，对呀这就是人家开发出来的app的优势之一，使用的统一性和兼容性
    
#对于跨表多对多数据的展示
class NewArticleSerializer(serializers.ModelSerializer): 
    tag_info = serializers.SerializerMethodField() 
    class Meta: 
        model = models.Article 
        fields = ['title','summary','tag_info'] 
        def get_tag_info(self,obj): 
            #对于多对多的跨表数据展示，使用钩子函数的方式，我们的obj.tag.all()取得是一个queryset()对象，在这我们就可以使用列表推导式的方式自己构建字典或者直接使用values方法，返回的就是一个字典。这和我们ORM查询时一样的正向查找使用万能的点，反向查找使用小写的表名（反向查询还可以使用xx_set的方式）
            return [row for row in obj.tag.all().values('id','title')]
```

#### 分页（APIView里面）

```python
#在使用APIView视图里面还需要我们手动去设置分页相关的
from rest_framework.pagination import PageNumberPagination
    def get(APIView):
		page_object = PageNumberPagination()   #实例化分页
		result = page_object.paginate_queryset(queryset, request, self)  #和数据绑定
		ser = PageArticleSerializer(instance=result, many=True)  #序列化数据
		return Response({'count': page_object.page.paginator.count, 'result': ser.data})
```

#### 分页（ListAPIView里面）

```
这个是APIView的子类，它里面帮助我们实现了这个分页的功能，它是在GenericAPIView()类里面帮我们实现的，它里面还帮助我们实现了很多的功能，我们后面会说到，它也是ListAPIView继承的类之一。
```

#### 筛选和视图（APIView这类）

```python
#序列化类
class ArticleSerializer(serializers.ModelSerializer):
	comment_count = serializers.SerializerMethodField()

	class Meta:
		model = models.Article
		# fields = "__all__"
		exclude = ['author']

	def get_comment_count(self, obj):
		# xx_set反向查表
		return obj.comment_set.count()
    
class PageArticleSerializer(serializers.ModelSerializer):
    #反向查表
	content = serializers.CharField(source="articledetail.content")
	author = serializers.CharField(source="author.username")
    #choice选择
	category = serializers.CharField(source="get_category_display")
    #定义时间钩子，显示固定的格式
	date = serializers.SerializerMethodField()

	class Meta:
		model = models.Article
		fields = "__all__"

	def get_date(self, obj):
		return obj.create_at.strftime('%Y-%m-%d %H:%M')
    
#同时保存文章和文章内容两张表内容（这两张表是外键关联的关系，这里就是一对一的关系）
ser = seriailzer.ArticleSerializer(data=request.data)
		ser_detail = seriailzer.ArticleDetailSerializer(data=request.data)
		# 注意一点，我们post数据的时候一定要把两张表的该填的数据填上
		if ser.is_valid() and ser_detail.is_valid():
			# 文章表保存之后返回的是一个对象，它里面包含了ser的所有信息
			article_object = ser.save(author_id=1)
			# ser_detail.save(article.id=article_object.id)
			# 可以使用上面的方式给我们的文章内容表的article字段加内容，也可是使用下面的方式给我们的
			# 文章外键加内容，都是可以的
			ser_detail.save(article=article_object)
			return Response("保存成功")
		return Response("失败")
    
    
#筛选也需要自己写
from rest_framework.filters import BaseFilterBackend
class MyFilterBackend(BaseFilterBackend):

    def filter_queryset(self, request, queryset, view):
        val = request.query_params.get('cagetory')
        return queryset.filter(category_id=val)  #返回过滤后的对象
```

#### 视图（ListAPIView）

```python
ListAPIView（展示所有）,
CreateAPIView（创建）,
RetrieveAPIView（单条数据展示）,
UpdateAPIView（更新）,
DestroyAPIView（删除）

class TagSer(serializers.ModelSerializer):
    class Meta:
        model = models.Tag
        fields = "__all__"

class TagView(ListAPIView,CreateAPIView):
	"""
	展示所有的数据和添加数据,这里面定义的方法都是继承的CreateAPIView类里面实现的，具体的我们后面说
	"""
    queryset = models.Tag.objects.all()
    serializer_class = TagSer

    def get_serializer_class(self):
        """
        重写父类的方法，定制展示和提交数据时的serializer
        """
        if self.request.method == 'GET':
            return TagSer
        elif self.request.method == 'POST':
            return OtherTagSer
    def perform_create(self,serializer):
        """
        重写父类里面的方式，自定制保存的数据
        """
        serializer.save(author=1)

class TagDetailView(RetrieveAPIView,UpdateAPIView,DestroyAPIView):
    """
    展示单条信息，更新个删除数据：为什么和上面的分开？因为单条的展示和多条数据的展示是有冲突的
    因为，他们里面都定义了get方法，所以我们在使用的时候把他们分开并且可定制不同的serializer
    """
    queryset = models.Tag.objects.all()
    serializer_class = TagSer
    
    
#GenericAPIView里面提供的属性和方法
属性：
查询和序列化
	-queryset 列表视图的查询集
	-serializer_class 视图使用的序列化器
分页和过滤
	-pagination_class 分页控制类
	-filter_backends 过滤控制后端
详情页视图使用（单条数据的处理）
	-lookup_field 查询单一数据库对象时使用的条件字段，默认为’pk‘
    
方法:
    -get_queryset(self)  缓存queryset
    -get_object(self)  返回视图显示的对象
    -get_serializer_class(self)返回序列化类
    -get_serializer(self, args, *kwargs)用于验证和序列化输入输出
    -filter_queryset(self)  对给定的queryset进行过滤筛选（在这种模式下也需要自定制过滤类，重写这个方法）
    -还有一些和分页相关的
```



### flask

### redis

### linux

### git

### 计算机操作系统

### 数据结构与算法

#### 斐波那契数列（递归）

```python
# O(2^n):最慢的,但是最经典的
def fibnacci(n):
	if n == 1 or n == 2:
		return 1
	else:
		return fibnacci(n-1) + fibnacci(n-2)
#注意，这种是利用斐波那契数列的公式实现的，它的时间复杂度就近似等于2^n，这种方式看似简单，但是有一个非常大的坑，当我们计算第100个斐波那契数的时候，可能到我们死也计算不出来（计算机大概每秒计算10^9次方左右，而100的斐波那契大的计算次数是1267650600228229401496703205376），所以它并不实用

#下面的几种方式的时间复杂度都是O(n)
#改良版递归实现斐波那契数列
def fib(n):
    li = [1,1] + [-1 for _ in range(n-2)]
    def fibnacci(n):
        if li[n-1] == -1:
            li[n-1] = fibnacci(n-1) + fibnacci(n-2)
        return li[n-1]
    return fibnacci(n)
print (fib(5)) >>>5
#这种方式的实现是开辟了一个新的列表空间来间接储存新产生的数据，所以说它的时间复杂度是O(n)，算是以时间换取空间的案例吧

#使用python的生成器的方式实现
def fibnacci(n):
    a,b = 1,1
    while n > 0:
        n -= 1
        yield a
        a,b = b,a+b
print ([i for i in fibnacci(5)]) >>>[1, 1, 2, 3, 5]
#注意，这种方式不能打印b，只能打印a

#使用python的append的方式
def fibnacci(n):
    li = [1,1]
    for i in range(2,n):
        li.append(li[-1]+li[-2])
    return li
print (fibnacci(5)) >>>[1, 1, 2, 3, 5]
#这种方式也额外开辟了一快空间，但是借助python的列表的方法来实现是非常简单的
```

#### 不使用python语法实现a,b值得交换

```python
a = 1
b = 2
a = a + b
a = a - b
b = a - b
print (a,b) >>>2,1
```

#### 二分查找

```python
def binary_search(li,num):
    low = 0
    hight = len(l1) - 1
    while low < hight:
        mid = (low+hight) // 2
        if li[mid] == num:
            return mid
        elif li[mid] < num:
            low = mid + 1
        else:
            hight = mid - 1
    return (f"{num} not in this list")
```

#### 冒泡查询(O(n^2))

```python
def bubble_sort(li):
    for i in range(len(li)-1):  #n-1趟，就是走的多少趟
        for j in range(len(li)-1-i): #-i的原因是后面有序区的数据就不需要比较了
            if li[j] > li[j+1]:
                li[j],li[j+1] = li[j+1],li[j]
    return li
#它的原理就是每一趟把无序区的最大的数字推到有序区，这样遍历n-1趟就可以把顺序排出来。比较相邻的两个数字，如果前面的数字比后面的数字大就交换数字，也就是把无序区的数字往有序区推的过程。

#优化一点点，就是所谓的无序区是有序的，那么就不需要再进行后面的比较了，这里使用了标记的方式实现的
def bubble_sort(li):
	for i in range(len(li)-1):
		swapped = False
		for j in range(len(li)-i-1):
			if li[j] > li[j+1]:
				li[j], li[j+1] = li[j+1], li[j]
				swapped = True  #如果有交换的话，就不退出，继续遍历交换
		if swapped == False:
			return
```

#### 选择排序(O(n^2))

```python
#选择排序的思想就是有序区在前面，从后面的数据遍历，找到后面无序区最小的插到最前面，变成有序区最大的值。
def selest_sort(li):
	for i in range(len(li)-1): #遍历n-1趟
		mos_id = i #这个就是紧邻有序区的数字，待交换
		for j in range(mos_id+1,len(li)): #遍历找到最小值
			if li[j] < li[mos_id]:
				mos_id = j  #无序区有最小值交换
		li[mos_id],li[i] = li[i],li[mos_id]
	return li
```

#### 插入排序(O(n^2))

```python
#这个的原理也是以左边的区域为有序区，遍历右面无序区的数据，把他们取到之后和有序区的数字进行比较，然后在合适的位置插入进去
def insert_sort(li):
	for i in range(1, len(li)):  # i表示要插入的数的下标
		tmp = li[i]  # 把取得的数存起来
		j = i - 1  # j就是有序取要比较的数的下标
		while j >= 0 and li[j] > tmp:  # 决定什么时候停止循环，把tmp插入到对应的位置上。两个终止条件：1，j的位置的值比tmp小，2，j=-1已经移动到最前面的
			li[j + 1] = li[j]
			j -= 1
		li[j + 1] = tmp
	return li

li = [1, 2132, 43, 31, 534, 31, 13, 4, 543, 132, 15, 34, 31, 3, 165, 34, 31, 3, 15, 3, 132, 13, 1, 3, 3]
print (insert_sort(li))
```

#### 快速排序(nlogn)

```

```

### 爬虫

### 项目