---
title: 第六讲——并发编程之进程间的通信、互斥锁
id: 6
date: 2019-8-21 20:00:00
tags: socket和并发编程

comment: true
---

### 学习大纲

- 僵尸进程和孤儿进程
- 互斥锁
- 进程之间的通信
  - 基于文件通信
  - 基于队列通信（重要）
  - 基于管道通信
- 生产者消费者模型
- 练习

<!-----more----->

### 僵尸进程和孤儿进程

```python
#面试会问道

基于unix环境(linux/macOS)

#问题：
一、主进程需要等待子进程结束之后，主进程才结束。
	1，主进程时刻检测子进程的运行状态，当子进程结束后，一段时间内，将子进程进行回收。
    
二、为什么主进程不在子进程结束后马上对其进行回收？
	1，主进程与子进程的异步关系，主进程无法在捕获子进程就立刻结束。
    2，如果子进程结束之后马上在内存中释放资源，主进程就没有办法检	 测子进程的状态了。
    
#解决问题：
unix针对于上面的问题，提供一个机制：
	所有的子进程结束之后，立马会释放掉文件操作连接，内存的大部分数据，但是会保留一些内容：进程号，结束时】间，运行状态，等待主进程检测，回收。
	
    
#僵尸进程（有害）
	所有的子进程结束之后，在被主进程回收之前，都会进入僵尸进程状态。子进程结束，没有被父进程回收的进程属于僵尸进程。
    
#僵尸进程有什么危害？
	如果父进程不对僵尸进程进行回收(wait/waitpid)，产生大量的僵尸进程，这样就会占用内存，占用进程pid号。
	
	
#孤儿进程（无害）
	父进程由于某种原因结束了，但是你的子进程还在运行中，这样你的子进程就成了孤儿进程。你的父进程如果结束了，你的所有的孤儿进程就会被init进程回收，init就变成了你的父进程，对你进行回收。
    
#僵尸进程如何解决？
	一、父进程产生大量的子进程，但是不回收，就会形成大量的僵尸进程，解决的方式就是直接杀死父进程，将所有的僵尸进程变成孤儿进程，由init进行回收。
    二、对开启的子进程记得加join，join会回收僵尸进程
```

### 互斥锁（保证数据安全，自己加锁容易出现死锁）

什么是互斥锁(锁、死锁)：

```
官方：
在编程中，引入了对象互斥锁的概念，来保证共享数据操作的完整性。每个对象都对应于一个可称为 互斥锁 的标记，这个标记用来保证在任一时刻，只能有一个线程访问该对象。
个人理解：
在这里就是保证进程之间数据的共享，但是我们不能让他们乱来，要让他们一个一个的串行使用，所以互斥锁就是实现这个功能的一个工具。
```

需求带入：

我们有三个同学，同时使用一个打印机打印内容。三个进程模拟三个同时，输出平台模拟打印机。

```python
#版本一
def task1(p):

	print (f"{p}开始打印了")
	time.sleep(random.randint(1,3))
	print (f"{p}打印结束了")


def task2(p):

	print (f"{p}开始打印了")
	time.sleep(random.randint(1,3))
	print (f"{p}打印结束了")


def task3(p):

	print (f"{p}开始打印了")
	time.sleep(random.randint(1,3))
	print (f"{p}打印结束了")


if __name__ == '__main__':

	p1 = Process(target=task1,args=('p1',))
	p2 = Process(target=task1, args=('p2',))
	p3 = Process(target=task1, args=('p3',))

	p1.start()
	p2.start()
	p3.start()
#现在是所有的进程都并发的抢占打印机，并发是以效率优先的，但是目前我们的需求是：顺序优先，多进程共享资源时，要保证顺序优先：就是串行，一个完成了另一个再来。
```

```python
#版本二（join）
def task1(p):

	print (f"{p}开始打印了")
	time.sleep(random.randint(1,3))
	print (f"{p}打印结束了")


def task2(p):

	print (f"{p}开始打印了")
	time.sleep(random.randint(1,3))
	print (f"{p}打印结束了")


def task3(p):

	print (f"{p}开始打印了")
	time.sleep(random.randint(1,3))
	print (f"{p}打印结束了")


if __name__ == '__main__':

	p1 = Process(target=task1,args=('p1',))
	p2 = Process(target=task1, args=('p2',))
	p3 = Process(target=task1, args=('p3',))

	p1.start()
	p1.join()
	p2.start()
	p2.join()
	p3.start()
	p3.join()
#我们利用join解决串行的问题，保证了顺序优先，但是谁先谁后是固定的，也就是我们手动设置的，这样在现实中是不合理的，也是不公平的，这个应该是谁先抢到就是谁先使用。
```

```python
#版本三（lock）
def task1(lock,p):
    #注意：一把锁不能连续锁两次
	lock.acquire()
    #lock.acquire()
	print (f"{p}开始打印了")
	time.sleep(random.randint(1,3))
	print (f"{p}打印结束了")
	lock.release()

def task2(lock,p):
	lock.acquire()
	print (f"{p}开始打印了")
	time.sleep(random.randint(1,3))
	print (f"{p}打印结束了")
	lock.release()

def task3(lock,p):
	lock.acquire()
	print (f"{p}开始打印了")
	time.sleep(random.randint(1,3))
	print (f"{p}打印结束了")
	lock.release()

if __name__ == '__main__':
	mutex = Lock()
    p1 = Process(target=task1,args=(mutex,'p1'),
name='p1')
	p2 = Process(target=task2, args=(mutex,'p2'), name='p2')
	p3 = Process(target=task3, args=(mutex,'p3'), name='p3')

	p1.start()
	p2.start()
	p3.start()
```

![img](http://9017499461.linshutu.top/lock.png)

小结：

lock与join的区别：

相同点：他们都可以把并发变成串行，保证了顺序。

不同点：join是人为的设定执行顺序，lock是让其争抢执行顺序，保证了公平性。

### 进程之间的通信

**基于文件的通信**

基于抢票系统讲解

![img](http://9017499461.linshutu.top/file.png)

```python
#流程：首先进行查票，这些都属于并发，然后进行买票，这就需要串行，服务端卖出一张票就将票的总数减一。
import os
import random
import time
import json
from multiprocessing import Process
from multiprocessing import Lock

def search():
    #模拟网络延时
	time.sleep(random.randint(1,3))
	with open('ticket.json','r',encoding='utf-8') as f1:
		dic = json.load(f1)
		print (f"{os.getpid()}查看了票数，剩余{dic['count']}")

def paid():
	with open('ticket.json','r',encoding='utf-8') as f1:
		dic = json.load(f1)
		if dic["count"] > 0:
			dic["count"] -= 1
            #模拟网络延时
			time.sleep(random.randint(1,3))
			with open('ticket.json', 'w', encoding='utf-8') as f1:
				json.dump(dic,f1)
			print (f"{os.getpid()}购买成功")

def task(lock):
	search()
	lock.acquire()
	paid()
	lock.release()

if __name__ == '__main__':
	mutex = Lock()
	for i in range(6): 
        #产生6个进程，用来模拟6个用户
		p = Process(target=task,args=(mutex,))
		p.start()
'''
小结：
当很多进程共享一个资源时，你要保证访问的顺序（就是数据的安全），所以就一定要串行。
互斥锁：可以公平性的保证顺序以及数据的安全。
'''
```

总结：基于文件的进程之间的通信

-  效率低。
- 自己加锁麻烦而且容易出现死锁。

**基于队列的通信**（工作中用的最多）

- 队列

  ```
  队列：线程间最常用的数据交换的形式。在python中，多个线程之间的数据是共享的，多个线程进行数据交换的时候，不能够保证数据的安全性和一致性，这个时候队列就出现了，它完美的解决了线程间数据的交换，安全和一致性的问题。
  ```

- 创建队列的类Queue(maxsize)

- 方法

  ```python
  q = Queue(maxsize)
  参数解析：
  maxsize是队列中允许最大项数，省略则无大小限制。  
  
  方法：
  #q.put([bloock,[timeout]])
  功能：插入数据到队列中。
  block：True(默认)+timeout：正值-->>>阻塞timeout指定的时间，直到该队列有剩余的空间，如果超时，抛出Queue.full异常。
  block：False+timeout：正值-->>>该队列已满，立刻抛出Queue.full异常。
  
  #q.get()
  功能：从队列中读取一个并且删除一个元素。
  参数：
  block：True(默认)+timeout：正值-->>>那么在等待时间内没有取到任何元素，会抛出Queue.Empty异常。
  block：False+timeout：正值-->>>Queue有一个值可用，则立刻返回值。否则，立刻抛出Queue.Empty异常。
  
  #q.put_nowait()
  功能：同q.put(False)
  #q.get_nowait()
  功能：同q.get(False)
  
  #q.empty()
  功能：如果队列为空，返回True，反之False
  #q.full()
  功能：如果队列满了，返回True，反之False
  
  #q.qsize()
  功能：返回队列中目前项目的正确数量。
  
  #q.task_done()
  功能：在完成一项工作之后，该方法向任务已经完成的队列发送一个信号。
  
  #q.clear()
  功能：清空队列。
  
  #q.close()
  功能：关闭队列，防止队列中加入更多数据。调用此方法，后台线程将继续写入那些已经入队列但尚未写入的数据，但将在此方法完成时马上关闭。如果q被垃圾收集，将调用此方法。关闭队列不会在队列使用者中产生任何类型的数据结束信号或异常。例如，如果某个使用者正在被阻塞在get()操作上，关闭生产者中的队列不会导致get()方法返回错误。
  #q.join_thread()
  #q.cancel_join_thread()
  ```

- 队列的特性：先进先出，FIFO

![img](http://9017499461.linshutu.top/FIFO.png)

基于队列实现抢票系统

```python
def search(q,name):
	#模拟网络延时
	time.sleep(random.randint(1, 3))
	print (f"{name}查询了票数，剩余{q.qsize()}张")

def paid(q,name):
	#模拟网络延时
	time.sleep(random.randint(1, 3))
	#查询队列是否为空
	if not q.empty():
		#get取票，取一个就少一个
		q.get()
		print (f"{name}购票成功，剩余{q.qsize()}张")
	else:
		print(f"{name}购票失败，剩余{q.qsize()}张")


def task(lock,q,name):
	search(q,name)
	lock.acquire()
	paid(q,name)
	lock.release()


#基于队列
if __name__ == '__main__':
	#生成队列
	q = Queue()
	#产生4张票，就是往里面put4个数据
	for i in range(4):
		q.put(1)

	mutex = Lock()
	#产生6个进程，模拟客户
	for i in range(6):
		name = 'pl'+str(i)
		p = Process(target=task, args=(mutex, q,name))
		p.start()
```

**基于管道的通信**

### 生产者消费者模型

- 生产者消费者模型

  在并发编程中使用生产者消费者模式能够解决绝大所数并发的问题。该模式通过平衡生产线程和消费线程的工作能力来提高程序的整体处理数据的速度。

- 为什么要使用生产者消费者模式？

  在线程世界里，生产者就是生产数据的线程，消费者就是消费数据的线程。

  在多线程开发当中，如果生产者处理速度快，而消费者处理速度慢，那么生产者就必须等待消费者处理完，才能继续生产数据。同样的道理，如果消费者的处理能力大于生产者，那么消费者就必须等待消费者。为了解决这个问题，于是就引入了生产者消费者模式。

-  生么是生产者消费者模式？

  **生产者消费者模式是通过一个容器来解决生产者和消费者的强耦合问题。生产者和消费者彼此之间不直接通讯，而是通过阻塞队列进行通讯，所以生产者消费者彼此之间不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从队列里面取，阻塞队列就相当于一个缓冲区，平衡了生产者消费者的处理能力。**

实例(基于队列的单个生产者和消费者)

```python
def producer(q,name):
	for i in range(1,6):
		time.sleep(random.randint(1,2))
		q.put(i)
		print (f"生产者{name}生产了{i}号包子")

def consumer(q,name):
	while 1:
		try:
			food = q.get(timeout=3)  #超时报错
			time.sleep(random.randint(1,3))
			print (f"消费者{name}吃了{food}号包子")
		except Exception:
			return

if __name__ == '__main__':
	q = Queue()

	p1 = Process(target=producer,args=(q,'p'))
	p2 = Process(target=consumer,args=(q,'c'))

	p1.start()
	p2.start()
```

### 练习

```python
#解释一下什么是僵尸进程与孤儿进程，哪个更有危害？为什么？
僵尸进程：所有的子进程结束之后，在被主进程回收之前，都会进入僵尸进程状态。
    
孤儿进程：父进程由于某种原因结束了，但是你的子进程还在运行中，这样你的子进程就成了孤儿进程。你的父进程如果结束了，你的所有的孤儿进程就会被init进程回收，init就变成了你的父进程，对你进行回收。


僵尸进程危害更大：
如果父进程不对僵尸进程进行回收(wait/waitpid)，产生大量的僵尸进程，这样就会占用内存，占用进程pid号。
```

```python
#什么是互斥锁？使用互斥锁需要注意什么？
互斥锁：
官方：
在编程中，引入了对象互斥锁的概念，来保证共享数据操作的完整性。每个对象都对应于一个可称为 互斥锁 的标记，这个标记用来保证在任一时刻，只能有一个线程访问该对象。
个人理解：
在这里就是保证进程之间数据的共享，但是我们不能让他们乱来，要让他们一个一个的串行使用，所以互斥锁就是实现这个功能的一个工具。

注意：
加锁的时候不能加两个及两次以上，不然就一直阻塞。
防止死锁。
```

```python
#进程之间的通信方式有哪些？你平时用什么？为什么？
基于文件的通信
基于队列的通信
基于管道的通信

平时我常使用队列，相比较其他的两种方式，队列更加（和文件比较）的快而且稳定（和管道比较）。
```

```python
'''
利用队列Queue改进选票系统作业。
票数放入队列中存储。
开启多个进程进行选票，查票为并发效果，买票为串行效果。
购买成功、失败都需要提示。
'''
import random
import time
from multiprocessing import Process
from multiprocessing import Lock
from multiprocessing import Queue

def search(q,name):
	#模拟网络延时
	time.sleep(random.randint(1, 3))
	print (f"{name}查询了票数，剩余{q.qsize()}张")

def paid(q,name):
	#模拟网络延时
	time.sleep(random.randint(1, 3))
	#查询队列是否为空
	if not q.empty():
		#get取票，取一个就少一个
		q.get()
		print (f"{name}购票成功，剩余{q.qsize()}张")
	else:
		print(f"{name}购票失败，剩余{q.qsize()}张")


def task(lock,q,name):
	search(q,name)
	lock.acquire()
	paid(q,name)
	lock.release()


#基于队列
if __name__ == '__main__':
	#生成队列
	q = Queue()
	#产生4张票，就是往里面put4个数据
	for i in range(4):
		q.put(1)

	mutex = Lock()
	#产生6个进程，模拟客户
	for i in range(6):
		name = 'pl'+str(i)
		p = Process(target=task, args=(mutex, q,name))
		p.start()
```

```python
模拟双十一排队抢小米手机，多用户抢购，只能选取前10个用户。

开启多个用户抢购买手机。
只能限定10人购买。
最终将10个用户的排名展示出来。
提示：不用想的很复杂，就是围绕着队列和进程pid做文章。

def line_up():
	print (f"{os.getpid()}正在排队.....")

def winners(q,name):
	try:
		q.put(os.getpid(),block=False)
	except Exception:
		return

def task(lock,q,name):
	line_up()
	lock.acquire()
	winners(q,name)
	lock.release()



if __name__ == '__main__':
	q = Queue(10)

	mutex = Lock()
	for i in range(100):
		name = 'pl'+str(i)
		p = Process(target=task, args=(mutex,q,name))
		p.start()
	for i in range(10):
		print (q.get())
```




