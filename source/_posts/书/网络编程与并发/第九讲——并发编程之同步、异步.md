---
title: 第九讲——并发编程之同步、异步
id: 9
date: 2019-8-25 20:00:00
tags: socket和并发编程
comment: true
---

### 学习大纲

- 阻塞、非阻塞、同步、异步
- 同步调用、异步调用
- 异步调用+回调函数

### 阻塞、非阻塞、同步、异步

程序运行的三种状态：运行、就绪、阻塞

**执行的角度**

阻塞：程序运行时，遇到了IO，程序挂起，cpu被切走。

非阻塞：理论上程序运行没有遇到IO，但是程序遇到IO，然后我们通过某种手段，让cpu强行运行我的程序。

**提交任务的角度**

同步：提交一个任务，自任务开始运行直到此任务结束（可能有IO），返回值之后，我们提交下一个任务。

异步：一次提交多个任务，然后我就执行下一行代码。

<!----more---->

### 同步调用、异步调用

同步调用

```python
from concurrent.futures import ProcessPoolExecutor,ThreadPoolExecutor
import time
import random
import os
#
def task(i):
	print (f"{os.getpid()}开始任务！")
	time.sleep(random.randint(1,3))
	print(f"{os.getpid()}结束任务！")
	return i

if __name__ == '__main__':
	#同步调用
	pool = ProcessPoolExecutor()
	for i in range(10):
        #发布4个任务到进程池
		obj = pool.submit(task,i)

		#obj是一个动态对象，返回当前的对象的状态，有可能运行中，也可能阻塞，还可能结束了。
		#obj.result()必须等到 这个任务完成后，返回了结果之后再执行下一个任务。
        #串行执行进程池里面的任务
		print (f"任务结束:{obj.result()}")

    #等进程池里面的任务执行完之后再往里面添加
	pool.shutdown(wait=True)
	#shutdown:让我的主进程池中所有的子进程都结束任务之后再执行，优点类似join
	#shutdoown：在上一个进程池没有完成所有的任务之前，不允许添加新的任务
	#一个任务是通过一个函数实现的，任务完成了，它的返回值就是函数的返回值
	print ("===主")
```

异步调用

```python
def task(i):
	print (f"{os.getpid()}开始任务！")
	time.sleep(random.randint(1,3))
	print(f"{os.getpid()}结束任务！")
	return i

if __name__ == '__main__':
	#同步调用
	pool = ProcessPoolExecutor()
	l1 = []
	for i in range(10):
        #把10个任务都添加到进程池
		obj = pool.submit(task,i)
		l1.append(obj)
	#异步执行进程池中的任务
	print (f"任务结束:{obj.result()}")

	pool.shutdown(wait=True)
	print (l1)
	for i in l1:
		print (i.result())
	print ("===主")
```

总结：异步一次发布多个任务，继续执行下面的代码，怎么收取结果？

- 将所有的任务的结果统一回收。
- 完成一个任务，返回一个结果。

### 异步调用+回调函数

```python
版本一：
from concurrent.futures import  ProcessPoolExecutor,ThreadPoolExecutor
import time
import random
import os
import requests

def task(url):
	'''模拟的就是爬取多个源代码，一定有IO操作'''
	ret = requests.get(url)
	if ret.status_code == 200:
		return parse(ret.text)
def parse(content):
	''''模拟对数据进行分析，一般没有IO'''
	return len(content)

if __name__ == '__main__':
	# 开启线程池,并发并行的执行
	url_list = [
        'http://www.baidu.com',
        'http://www.JD.com',
        'http://www.JD.com',
        'http://www.JD.com',
        'http://www.taobao.com',
        'https://www.cnblogs.com/jin-xin/articles/7459977.html',
        'https://www.luffycity.com/',
        'https://www.cnblogs.com/jin-xin/articles/9811379.html',
        'https://www.cnblogs.com/jin-xin/articles/11245654.html',
        'https://www.sina.com.cn/']
	pool = ThreadPoolExecutor(4)
	obj_list = []
	for i in url_list:
		obj = pool.submit(task,i)
		obj_list.append(obj)

	pool.shutdown(wait=True)
	for i in obj_list:
#线程池设置了4个线程，异步发起10个任务，每个任务都是获取网页源码+数据分析（获取网页源码的长度），并发执行，最后将所有的结果展示出来。
这种程序增强了耦合性。
```

```python
版本二：（异步调用+回调函数）
'''
基于异步调用回收所有任务的结果，我们要做到实时回收结果，并发
执行任务，每个任务只是处理IO阻塞的，不能增加新的功能
'''
def task(url):
	'''模拟的就是爬取多个网页源码，一定有IO操作'''
	ret = requests.get(url)
	if ret.status_code == 200:
		return ret.text

def parse(obj):
	'''模拟对数据进行分析，一般没有IO'''
	print (len(obj.result()))

if __name__ == '__main__':
	# 开启线程池,并发并行的执行
	url_list = [
		'http://www.baidu.com',
	    'http://www.JD.com',
	    'http://www.JD.com', 
	    'http://www.JD.com',
		'http://www.taobao.com',
		'https://www.cnblogs.com/jin-xin/articles/7459977.html',
		'https://www.luffycity.com/',
		'https://www.cnblogs.com/jin-xin/articles/9811379.html',
		'https://www.cnblogs.com/jin-xin/articles/11245654.html',
		'https://www.sina.com.cn/']
	pool = ThreadPoolExecutor(4)
	for url in url_list:
		obj = pool.submit(task,url)
		obj.add_done_callback(parse)
'''
线程池设置4个线程，异步发起10个任务，每个任务是通过网页获取源码，并发的执行，
当一个任务完成之后，将parse这个分析代码的任务交由剩余的空闲的线程去执行，这个线程继续去处理
其他任务，如果进程池+回调：回调函数由主进程去执行
		  如果线程池+回调：回到函数由空闲的线程去执行
'''
```

**异步回调是怎么一回事？**

异步是站在发布任务的角度，回调是站在接收结果的角度。回调函数，按顺序接收每个任务的结果，进行下一步处理。

异步+回调：异步处理IO类型，回调处理非IO类型。

区别：

- 多进程：由主线程执行回调函数的代码。
- 多线程：由空闲的线程执行回调函数的代码。

**补充**

map(self,fn,*iterables,timeout=None)

功能：返回与map（fn，iter）等效的迭代器。在

参数说明：

fn：一个接收尽可能多的参数的可调用文件。

*iterables：通过了Iterables。

返回：等价于：map（func，*iterables）的迭代器，但调用可能

评估不正常。

```python
import random
import time
from concurrent.futures.thread import ThreadPoolExecutor
from threading import current_thread


def func(n): # 注意这个n
    print('%s is runing' % current_thread().ident)
    time.sleep(random.randint(1, 3))


if __name__ == '__main__':
    pool = ThreadPoolExecutor(3)  #创建线程池并开启3个线程
    pool.map(func, range(5))  #这个map和内置函数一样，返回的是一个生成器对象，这里的map第一个参数是可执行的函数，函数必须有参数，即使这个参数不使用，后面的第二个参数可以是参数，同时也是控制执行的任务的次数。
    print('主')
结果：
6288 is runing
5744 is runing
5532 is runing
主
6288 is runing
6288 is runing

第二种
def func(n): # 注意这个n
    print('%s is runing' % current_thread().ident)
    time.sleep(random.randint(1, 3))


if __name__ == '__main__':
    pool = ThreadPoolExecutor(3)
    pool.map(func, range(5))   #map参数必须是可迭代的，异步提交任务，自带join功能。
    pool.shutdown() #map不自带关闭功能
    print('主')
结果：
10360 is runing
16888 is runing
12844 is runing
10360 is runing
16888 is runing
主
```

