---
title: 第七讲——并发编程之线程一
id: 7
date: 2019-8-22 20:00:00
tags: socket和并发编程
comment: true
---

### 学习大纲

- 线程的理论知识
- 开启线程的两种方式
- 线程进程对比
- 线程的其他方法
- join和守护线程（重要）
- 互斥锁（重要）

<!-----more----->

### 线程的理论知识

线程

- 什么是进程和线程？

进程就是资源单位，线程就是执行单位。（在回答问题的时候，抓住重点，把最重要的先回答再扩展），在开启一个程序的时候，进程在内存空间中加载一片资源空间，线程去执行里面的代码。

- 对比进程：在内存中开启一个进程空间，然后将主进程的所有资源数据复制一份，然后调用线程去执行这些代码。

- 结论：进程是资源单位，线程是执行单位。

线程VS进程

- 开启进程的开销非常大，比开启线程的开销大几十倍甚至几百倍。

- 开启线程的速度非常快，要快几十倍甚至几百倍。

- 线程与线程之间可以共享数据，进程与进程之间需要借助队列等方法实现通信。

线程的应用

- 并发：一个cpu看起来像是同时执行多个任务。

- 单个进程开启三个线程，并发的执行任务

- 开启三个进程并发的执行任务

- 实例

  文本编辑器：

  输入文字

  在屏幕上显示

  保存到磁盘

  开启多线程就非常好：开销小，速度快，数据共享

主线程子线程没有地位之分，但是一个进程谁干活？

- 一个主线程干活，当活干完了，就得等待其他线程干完活之后，才能结束本进程。

### 开启线程的两种方式

```python
# 线程的创建（方式一：函数式）
from threading import Thread

def task(name):
	print (f"{name} is running")
	time.sleep(1)
	print (f'{name} is gone')

if __name__ == '__main__':
	t1 = Thread(target=task,args=("pl",))
	t1.start()
	print ("主线程")  #线程没有主次之分
```

```python
# 线程的创建（方式二：类）
class MyThread(Thread):
	def __init__(self,name,l1,s1,i):
		super().__init__()
		self.name = name
		self.l1 = l1
		self.s1 = s1
		self.i = i

	def run(self):
		print(f"{self.name} is running{i}")
		time.sleep(1)
		print(f'{self.name} is gone')
if __name__ == '__main__':
	for i in range(1,100000):
		t1 = MyThread("pl",[1,2,3],18,i)
		t1.start()
	print ("主线程")  #线程没有主次之分
```

### 线程进程对比（代码说话）

- 开启速度

```python
#进程（慢）
from Threading import Thread
from multiprocessing import Process
import os

def work():
    print('hello')

if __name__ == '__main__':
    t=Process(target=work)
    t.start()
    print('主线程/主进程')

#线程（几乎是同时）
from threading import Thread
import time

def task(name):
    print(f'{name} is running')
    time.sleep(1)
    print(f'{name} is gone')

if __name__ == '__main__':
    t1 = Thread(target=task,args=('海狗',))
    t1.start()
    print('===主线程')  # 线程是没有主次之分的.
```

- 对比pid

```python
#进程
from multiprocessing import Process
import time
import os
def task(name):
    print(f'子进程: {os.getpid()}')
    print(f'主进程: {os.getppid()}')


if __name__ == '__main__':

    p1 = Process(target=task,args=('pl',))  # 创建一个进程对象
    p2 = Process(target=task,args=('pl',))  # 创建一个进程对象
    p1.start()
    p2.start()
    print(f'==主{os.getpid()}')
结果：
==主5568
子进程: 6976
主进程: 5568
子进程: 7908
主进程: 5568

#线程
from threading import Thread
import time

def task():
    print(os.getpid())

if __name__ == '__main__':

    t1 = Thread(target=task)
    t2 = Thread(target=task)
    t1.start()
    t2.start()
    print(f'===主线程{os.getpid()}')
结果：
16200
16200
===主线程16200
```

- 同一个进程内线程共享内部数据

```python
# 同一进程内的资源数据对于这个进程的多个线程来说是共享的.
from threading import Thread
import os

x = 3
def task():
    global x
    x = 100

if __name__ == '__main__':

    t1 = Thread(target=task)
    t1.start()
    t1.join()
    print(f'===主线程{x}')
结果：
===主线程100
```

### 线程的相关的其他方法

```python
from threading import currentThread
from threading import enumerate
from threading import activeCount

x = 3
def task():
	print (currentThread())
	#<Thread(线程1, started 14584)>
	#<Thread(线程2, started 1712)>
	time.sleep(1)
	print("666")
	#666
	#666

if __name__ == '__main__':
	t1 = Thread(target=task,name="线程1")
	t2 = Thread(target=task,name="线程2")

#属性
	t1.start()
	t2.start()
	time.sleep(2)
	print (t1.isAlive())  #判断线程是否存活
	#False
	print (t1.getName())  #获取线程名
	#线程1
	t1.setName("子线程-1")  #设置线程名
	print (t1.name)   #获取线程名  *****
	#子线程-1
#方法
	print (currentThread())  #获取当前线程的对象  
	#<_MainThread(MainThread, started 8952)>
	print (enumerate())  #返回一个列表，包涵所有的线程对象
	#[<_MainThread(MainThread, started 8952)>]
	print (activeCount())   #获取线程的个数  *****
	#1
	print (f"主线程{os.getpid()}")
	#主线程6544
```

### join与守护进程（重要）

守护线程

```python
#守护线程
from threading import Thread
import time

def sayhi(name):
	print("hello!")
	time.sleep(2)
	print ("%s say 你好." %name)

if __name__ == '__main__':
	t = Thread(target=sayhi,args=("pl",))
	t.daemon = True
	t.start()

	print ("我是主线程！")
	
#hello!我是主线程！ 
我们可以看见打印的速度是非常的快的，就在一行。所以说线程的开启是非常的快的。
```

重点：主线程什么时候结束？

守护线程等待非守护子线程以及主线程结束之后，再结束。（如果守护线程的生命周期小于其他线程，则它肯定先结束）。

```python
情况一:
from threading import Thread
import time


def foo():
	print (123)
	time.sleep(1)
	print ("end123")

def bar():
	print (456)
	time.sleep(3)
	print("end456")

if __name__ == '__main__':
	t1 = Thread(target=foo)
	t2 = Thread(target=bar)

	t1.daemon = True
	t1.start()
	t2.start()
	print ("main----")
结果：
123
456
main----
end123
end456
#分析：首先开启线程，执行foo和bar打印123和456，然后执行main----，(这个时候看似主线程结束了，但是还没有“结束”)foo睡了1秒，然后执行end123，接着执行end4566
```

```python
情况二
from threading import Thread
import time


def foo():
	print (123)
	time.sleep(3)
	print ("end123")

def bar():
	print (456)
	time.sleep(1)
	print("end456")

if __name__ == '__main__':
	t1 = Thread(target=foo)
	t2 = Thread(target=bar)

	t1.daemon = True
	t1.start()
	t2.start()
	print ("main----")
结果：
123
456
main----
end456
#分析：首先开启线程，执行foo和bar打印123和456，然后执行main----，bar睡了1秒，然后执行end456，这个时候，主线程结束了，守护线程foo就跟着结束，所以没有打印end123
```

### 互斥锁（重要）

多个任务共抢一个数据，保证说的安全的目的，要让其串行：

```python
from threading import Thread
from threading import Lock
import time
import random
x = 100

def task(lock):

    lock.acquire()
    # time.sleep(random.randint(1,2))
    global x
    temp = x
    time.sleep(0.01)
    temp = temp - 1
    x = temp
    lock.release()


if __name__ == '__main__':
    mutex = Lock()
    l1 = []
    for i in range(100):
        t = Thread(target=task,args=(mutex,))
        l1.append(t)
        t.start()

    time.sleep(3)
    print(f'主线程{x}')
```

