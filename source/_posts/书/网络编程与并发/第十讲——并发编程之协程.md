---
title: 第十讲——并发编程之协程
id: 10
date: 2019-8-27 20:00:00
tags: socket和并发编程
comment: true
---

### 学习大纲

- 线程queue
- 事件Event
- 协程

### 线程queue

多线程抢占资源，只能让其串行。

- 互斥锁
- 队列

```python
import queue
#后进后出 LIFO推栈
q = queue.LifoQueue(4)
q.put(1)
q.put(2)
q.put('pl')

print (q.get())
print (q.get())
print (q.get())

#优先级队列
q = queue.PriorityQueue(4)
q.put((3,'pl'))
q.put((-2,3))
q.put((0,'彭'))

print(q.get())
print(q.get())
print(q.get())
结果：
3
彭
pl
```

<!----more---->

### 事件Event

应用：开启两个线程，一个线程运行到中间的某个阶段，触发另一个线程执行。增加两个线程的耦合性。

源码说明:实现事件对象的类。事件管理可使用set()方法设置true的标志位；重置使用clear()方法，则返回false.wait()方法将一直阻塞，直到标志位是true。标志最初为false。

方法：

- is_set():Return true if and only if the internal flag is true.
  - isSet = is_set
- set():Set the internal flag to true.
- clear():Reset the internal flag to false.
- wait(timeout):Block until the internal flag is true.

```python
版本一:引子
#如果程序中的其他线程需要通过判断某个线程的状态来确定自己下一步的操作。
from thread
flag = False
def check():
	print (f"{current_thread().name} 监测服务器是否开启...")
	time.sleep(3)
	global flag
	flag = True
	print ("服务器已经开启...")
def connect():
	while 1:
		print (f"{current_thread().name} 等待连接...")
		time.sleep(0.5)
		if flag:
			print (f"{current_thread().name} 连接成功")
			break
t1 = Thread(target=check,)
t2 = Thread(target=connect,)
t1.start()
t2.start()
'''
结果：
Thread-1 监测服务器是否开启...
Thread-2 等待连接...
Thread-2 等待连接...
Thread-2 等待连接...
Thread-2 等待连接...
Thread-2 等待连接...
Thread-2 等待连接...
服务器已经开启...
Thread-2 连接成功
'''
```

```python
版本二：例子带入
#需求：一个线程检测服务器是否开启，另一个线程判断如果开始来了，则显示连接成功
#此线程只尝试连接3次，1秒一次。如果超过3次还没有连接成功，则表示连接失败。

# 事件
event = Event()
def check():
	print (f"{current_thread().name} 检测服务器是否开启...")
	time.sleep(2)
	event.set()
	print ("服务器已经开启...")


def connect():
	count = 1
	while not event.is_set():  #event.is_set：判断标标志位event.set()是否为True
		if count == 4:
			print (f"连接次数过多，已断开")
			break
		# event.wait()  阻塞直到event.set()方法之后
		event.wait(1) #只阻塞1秒，1秒之后如果还没与进行set，直接进行下一步的操作
		print (f"{current_thread().name}尝试连接{count}次")
		count += 1
	else:
		print (f"{current_thread().name} 连接成功.")

t1 = Thread(target=check,)
t2 = Thread(target=connect,)
t1.start()
t2.start()
'''
结果：
Thread-1 检测服务器是否开启...
Thread-2尝试连接1次
服务器已经开启...
Thread-2尝试连接2次
Thread-2 连接成功.
'''
```

### 协程

CSDN：https://blog.csdn.net/qq_40890660/article/details/100055706

一、什么是协程？

- 单个线程并发的处理多个任务。程序控制协程的切换+保持状态。

二、多线程的并发？

- 3个线程处理10个任务,如果线程1处理的这个任务,遇到阻塞,cpu被操作系统切换到另一个线程,

![](http://9017499461.linshutu.top/%E5%8D%8F%E7%A8%8B1.png)

三、一个线程能否并发处理任务？

- 当然是可以的

![](http://9017499461.linshutu.top/%E5%8D%8F%E7%A8%8B2.png)

四、单个cpu：10个任务，我们有哪些方法并发执行这10个任务？

方式一：开启多进程并发执行，操作系统切换+保持状态。

方式二：开启多线程并发执行，操作系统+保持状态。

方式三：开启协会并发执行，自己的程序把控着cpu在3个任务之间来回切换+保持状态。（协程切换的速度非常快，蒙蔽了操作系统的眼睛，让操作系统认为cpu一直在运行这一个程序。）

五、协程为什么好：

- 开销小。
- 运行速度快。
- 协程长期霸占cpu只执行我的程序里面的所有的任务。

六、并发的本质：切换+保持状态。

七、**协程处理IO密集型。**

八、协程的特点

- 必须在只有一个单线程里实现并发。
- 修改共享数据需要加锁。
- 用户程序里自己保存多个控制流的上下文栈（保持状态）。
- 一个协程遇到IO操作自动切换到其他协程。

九、工作中

一般在工作中我们都是进程+线程+协程的方式来实现并发，以达到最好的并发效果，如果是4核的cpu，一般起5个进程，每个进程中20个线程（5倍cpu数量），每个线程可以起500个协程，大规模爬取页面的时候，等待网络延迟的时间的时候，我们就可以用协程去实现并发。 并发数量 = 5 * 20 * 500 = 50000个并发，这是一般一个4cpu的机器最大的并发数。nginx在负载均衡的时候最大承载量就是5w个

实例代码

**greenlet模块**

```python
切换+保持状态（遇到IO不会主动切换）
from greenlet import greenlet
import time
def eat(name):
    print('%s eat 1' %name)  # 2
    # g2.switch('taibai')  # 3
    time.sleep(3)
    print('%s eat 2' %name)  # 6
    g2.switch()  # 7

def play(name):
    print('%s play 1' %name)  # 4
    g1.switch()  # 5
    print('%s play 2' %name)  # 8

g1=greenlet(eat)
g2=greenlet(play)

g1.switch('taibai')  # 1 切换到eat任务
```

**gevent模块**

```python
#模拟的阻塞，不是真正的阻塞
import gevent
from threading import current_thread
def eat(name):
    print('%s eat 1' %name)
    print(current_thread().name)
    # gevent.sleep(2)
    time.sleep(2)
    print('%s eat 2' %name)

def play(name):
    print('%s play 1' %name)
    print(current_thread().name)
    # gevent.sleep(1)
    time.sleep(1)
    print('%s play 2' %name)


g1 = gevent.spawn(eat,'egon')
g2 = gevent.spawn(play,name='egon')
print(f'主{current_thread().name}')
g1.join()
g2.join()
结果：
主MainThread

egon eat 1
MainThread
egon eat 2

egon play 1
MainThread
egon play 2
```

**monkey模块**

```python
最终版本
import gevent
from gevent import monkey
monkey.patch_all()  #打补丁：将下面的所有的任务的阻塞都打上补丁
def eat(name):
	print (name*1)
	time.sleep(2)
	print (name*2)
def play(name):
	print (name*1)
	time.sleep(2)
	print (name*2)
g1 = gevent.spawn(eat,'pl')
g2 = gevent.spawn(play,'pl1')
gevent.joinall([g1,g2])
结果：
pl
pl1
plpl
pl1pl1
```