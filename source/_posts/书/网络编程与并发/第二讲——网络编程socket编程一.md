---
title: 第二讲——socket编程一
id: 2
date: 2019-8-15 20:00:00
tags: socket和并发编程
comment: true
---

### 学习大纲

- socket初始
- 知识扩展
- socket函数大全

<!-----more----->

### socket初始

1，什么是socket？

- 自己理解的：Socket又称作套接字，应用程序通常通过套接字向网络发出请求或者应答请求，使主机或者一台计算机上的进程间进行通讯。它是处于应用层和传输层之间的抽象层，他是一组操作起来非常简单的接口，此接口接收数据之后，交由操作系统，在python中它封装成了一个模块。
- 比较官方的：socket就是一组接口，在设计模式中，socket其实就是一个门面模式，它把复杂的TCP/IP协议簇隐藏在socket接口后面，对于客户来说，一组到你的接口就是全部，让socke去组织数据，以符合指定的协议。

2，为什么存在socket？

- 如果从应用层把数据直接交给操作系统，这样交付非常麻烦，繁琐，socket对这些繁琐的操作高度的封装，简化。

3，下面我们来以图例的形式看看我们的socket在协议簇中的位置

![img](http://9017499461.linshutu.top/socket.png)

4，实现一个简单的服务端和客户端的数据交互实例

```python
#server端
import socket

bind_ip = "127.0.0.1"
bind_port = 9999
Addr = (bind_ip,bind_port)
BUFFERSIZE = 1024

ss = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
#绑定地址
ss.bind(Addr)
#建立连接数
ss.listen(5)
#阻塞，直到和客服端建立数据传输的管道
conn,addr = ss.accept()
#接收数据
print(conn.recv(BUFFERSIZE).decode("utf-8"))
#发送数据
conn.send("ok".encode('utf-8'))
#管道连接关闭
conn.close()
#连接关闭
ss.close()
```

```python
#client端
import socket

bind_ip = "127.0.0.1"
bind_port = 9999
Addr = (bind_ip,bind_port)
BUFFERSIZE = 1024

cs = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
#建立和服务端管道的连接
cs.connect(Addr)
#发送数据
cs.send('https://github.com/jobbole/awesome-python-cn'.encode('utf-8'))
#接收数据
s = cs.recv(BUFFERSIZE)
#解码
print (s.decode("utf-8"))
#关闭连接
cs.close()
```

5，下面我们通过图例来了解socket的通信原理

![img](http://9017499461.linshutu.top/scoket%E5%8E%9F%E7%90%86%E5%9B%BE.png)

- 解释服务端：
  - 服务端初始化socket，选择协议
  - 把一个地址簇中的特定地址，端口赋给socket
  - 监听socket描述字和相应的可排队的最大连接数(默认从0开始计，最大可连接n+1个客户端)，后面详讲。
  - 服务器TCP监听到请求之后，就会带你用accept()函数接收请求。后面详讲。
- 解释客户端：
  - 初始化socket
  - 通过connect函数和TCP服务端建立连接

6，深入了解socket的原理

- 网络中进程之间是如何进行通信的？
  - 在网络的本地进程通信中，可以分为4类：消息传递、同步、共享内存、远程过程调用。但是这些东西不是我们需要掌握的东西，进程间的通信首先需要解决的就是如何唯一标识一个进程，在我们本地中可以通过PID来唯一标识一个进程。但是在网络中这样是行不通的。那么，我们就只能通过传输层的协议+端口来唯一标识主机中的应用程序。也就是利用三元组（ip地址、协议、端口）来标识网络中的进程。

7，socket的起源

- socket起源于Unix/Linux,他们的哲学就是“一切皆文件”，也就是'open——读写——close‘的模式来操作，所以socket就是该模式的一个实现，那么socket就是一种特殊的文件。

8，scoket的基本操作，就是提供的接口函数

- Socket（）函数

- 官方结构：socket(domin,type,protocol)

- 参数解释：

  - domin:协议簇，常用的有

    - AF_INET（ipv4）
    - AF_INET6（ipv6）

  - type：指定socket的类型，常用的有

    - socket.SOCK_STREAM:流式socket，for TCP

    - socket.SOCK_DGRAM：数据包式socket，for UDP

    - socket.SOCK_RAM:

      ```
      原始套接字，普通的套接字无法处理ICMP、IGMP等网络报文，而SOCK_RAW可以；其次，SOCK_RAW也可以处理特殊的IPv4报文；此外，利用原始套接字，可以通过IP_HDRINCL套接字选项由用户构造IP头。
      ```

    - socket.SOCK_SEQPACKET:可靠的连续数据包服务

  - protocol：可选参数，指定协议，不赘述。

- 注意：我们都知道，通常服务器在启动的时候都会绑定一个众所周知的地址，用于提供服务，而客户端不需要。Bind()就是在服务端绑定的那个众所周知的地址。而在客户端，其会调用connect()由系统随机生成一个。

### 知识扩展

1，网络字节序与主机字节序（大端模式和小端模式）：

```python
#网络字节序与主机字节序
主机字节序就是我们平常说的大端和小端模式：不同的CPU有不同的字节序类型，这些字节序是指整数在内存中保存的顺序，这个叫做主机序。引用标准的Big-Endian和Little-Endian的定义如下：
　　a) Little-Endian就是低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。
　　b) Big-Endian就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。
网络字节序：4个字节的32 bit值以下面的次序传输：首先是0～7bit，其次8～15bit，然后16～23bit，最后是24~31bit。这种传输次序称作大端字节序。由于TCP/IP首部中所有的二进制整数在网络中传输时都要求以这种次序，因此它又称作网络字节序。字节序，顾名思义字节的顺序，就是大于一个字节类型的数据在内存中的存放顺序，一个字节的数据没有顺序的问题了。
所以： 在将一个地址绑定到socket的时候，请先将主机字节序转换成为网络字节序，而不要假定主机字节序跟网络字节序一样使用的是Big-Endian。由于 这个问题曾引发过血案！公司项目代码中由于存在这个问题，导致了很多莫名其妙的问题，所以请谨记对主机字节序不要做任何假定，务必将其转化为网络字
```

2，socket的长连接和短连接

- 概念：长连接是整个通讯的过程，客户端和服务端只用一个Socket对象，长期保持Socket的连接；短连接就是每次请求，都会新建一个Socket，处理完一个请求就直接关闭掉Socket。
- 长连接的实现：客户端自动退出读取的动作。我们可以在服务端每发完一段消息并且刷新前就进行一个写入结束符号的标识，客户端解析到结束符时，便可以直接退出read的循环操作，避免一直阻塞。
- 短连接和长连接有不同的用途
  - 对于某次服务只需要一次会话的业务，使用短连接非常的简单
  - 如果该次服务需要很多交互式的操作通信，那么还是长连接比较高性能，毕竟，Socket的打开和关闭都是很耗性能的。

3，Socket的长连接和心跳

- 如何让长连接保活（应用层的心跳包）

  - 什么是心跳包：就是客户端会开启一个定时的任务，定时对已经建立连接的对端应用发送请求（这里的请求就是特殊的心跳请求），服务端需要特殊处理该请求，返回响应。如果心跳持续多次没有收到响应，客户端就会认为连接不可用，主动断开连接。不同的服务治理框架对心跳，连接.......都有不同的策略，但是大多数的服务治理框架都会在应用层做心跳。

- 长连接保活（KeepAlive）的三种实践方案

  - 默认情况下使用KeepAlive周期为两个小时，如不不选择更改，属于无用范畴，造成资源浪费：内核会为每个连接都打开保活计时器，N个连接会打开N个保活计时器。优势很明显：

    1,TCP 协议层面保活探测机制，系统内核完全替上层应用自动给做好了

    2,内核层面计时器相比上层应用，更为高效

    3,上层应用只需要处理数据收发、连接异常通知即可

    4,数据包将更为紧凑

  - 关闭TCP的KeepLive，完全使用应用层心跳保活机制。由应用掌管心跳，更加灵活可控，比如可以在应用级别设置心跳周期，适配私有协议。

  - 业务心跳+TCPKeepLive一起使用，互相作为补充，但是TCP保活探测周期和应用的心跳要协调，以互相补充，不过不能差距过大，否则将达不到设想的结果。

### socket函数大全

一、套接字对象的内置方法大全

- 服务端套接字函数
  - s.bind():绑定地址到套接字
  - s.listen():开始TCP监听
  - s.accept():被动接受TCP客户端连接，（阻塞式）等待连接的到来

- 客户端套接字函数
  - s.connect():主动初始化TCP服务器连接
  - s.connect_ex():connect()函数的扩展版本，出错时返回出错码，而不是抛出异常

- 公共用途的套接字函数
  - s.recv()：接收TCP数据
  - s.send():发送TCP数据
  - s.sendall()：完整发送TCP数据
  - s.recvfrom():接收UDP数据
  - s.sendto():发送UDP数据
  - s.getpeername():连接到当前套接字的远端地址（TCP连接）
  - s.getsockname():当前套接字的地址
  - s.getsockopt():返回指定套接字的参数
  - s.setsockopt():设定指定套机字的参数
  - s.close():关闭套接字

- 面向模块的套接字函数
  - s.settimeout():设置阻塞套接字操作的超时时间
  - s.gettimout():得到阻塞套接字操作的超时时间
  - s.setblocking():设置套接字的阻塞与非阻塞模式

- 面向文件的套接字函数
  - s.fileno():套机字的文件描述符
  - s.makefile():创建一个与该套接字关联的文件对象

二、socket模块的属性（用的时候查一下就可以）

| **属性名称**                              | **描述**                                                     |
| ----------------------------------------- | ------------------------------------------------------------ |
| **数据属性**                              |                                                              |
| **AF_UNIX、AF_INET、AFINET6、**           | **Python中支持的套接字地址家族**                             |
| **SO_STREAM、SO_DGRAM**                   | **套接字类型（TCP=流，UDP=数据报）**                         |
| **has_ipv6**                              | **是否支持IPv6的布尔标记**                                   |
| **异常**                                  |                                                              |
| **error**                                 | **套接字相关错误**                                           |
| **herror**                                | **主机和地址相关错误**                                       |
| **gaierror**                              | **地址相关错误**                                             |
| **timeout**                               | **超时时间**                                                 |
| **函数**                                  |                                                              |
| **socket()**                              | **以给定的地址家族、套接字类型和协议类型（可选）创建一个套接字对象** |
| **socketpair()**                          | **以给定的地址家族、套接字类型和协议类型（可选）创建一对套接字对象** |
| **create_connection()**                   | **常规函数，它接收一个地址（主机名，端口号）对，返回套接字对象** |
| **fromfd()**                              | **以一个打开的文件描述创建一个套接字对象**                   |
| **ssl()**                                 | **通过套接字启动一个安全套接字层连接；不执行证书验证**       |
| **getnameinfo()**                         | **给定一个套接字地址，返回（主机名，端口号）二元组**         |
| **getaddrinfo()**                         | **获取一个五元组序列形式的地址信息**                         |
| **getfqdn()**                             | **返回完整域名**                                             |
| **gethostname()**                         | **返回当前主机名**                                           |
| **gethostbyname()**                       | **将一个主机名映射到它的IP地址**                             |
| **gethostbyname_ex()**                    | **gethostbyname()的扩展版本，返回主机名，别名主机集合和IP地址列表** |
| **gethostbyaddr()**                       | **将一个IP地址映射到DNS信息；返回与gethostbyname_ex()相同的3元组** |
| **getprotobyname()**                      | **将一个协议名映射到一个数字**                               |
| **getservbyname()/getservbyport()**       | **将一个服务名映射到一个端口号，或者反过来；对于任何一个函数来说，协议名都是可选的。** |
| **ntohl()/ntohs()**                       | **将来自网络的整数转换为主机字节顺序**                       |
| **htonl()/htons()**                       | **将来自主机的整数转换为网络字节顺序**                       |
| **inet_aton()/inet_ntoa()**               | **将IP地址八进制字符串转换成32位的包格式，或者反过来（仅适用于IPv4）** |
| **inet_pton()/inet_ntop()**               | **将IP地址字符串转换成打包的二进制格式，或者反过来**         |
| **getdefaulttimeout()/setdefaulttimeout** | **以秒（浮点数）为单位返回默认套接字超时时间；或者设置其时间** |

