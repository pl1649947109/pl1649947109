---
title: 第五讲——并发编程之进程的创建
id: 5
date: 2019-8-20 20:00:00
tags: socket和并发编程
comment: true
---

### 学习大纲

- multiprocessing模块的介绍
- 进程对象的属性和方法
- 进程创建的两种方式
- 进程pid
- 验证进程之间的空间隔离
- 进程对象join方法
- 守护进程

请看blog:https://blog.csdn.net/qq_40890660/article/details/99867885

<!-----more----->

### multiprocessing模块的介绍

```
   python中的多线程无法利用多核优势，如果想要充分地使用多核CPU的资源（os.cpu_count()查看），在python中大部分情况需要使用多进程。Python提供了multiprocessing。
    multiprocessing模块用来开启子进程，并在子进程中执行我们定制的任务（比如函数），该模块与多线程模块threading的编程接口类似。

　 multiprocessing模块的功能众多：支持子进程、通信和共享数据、执行不同形式的同步，提供了Process、Queue、Pipe、Lock等组件。

    需要再次强调的一点是：与线程不同，进程没有任何共享状态，进程修改的数据，改动仅限于该进程内。
```

### 进程对象其他属性和方法

**方法**

```
p.start():启动进程并调用该子进程中的p.run()

p.run():进程启动时运行的方法，正是它去调用target指定的函数，我们自定义类中一定要实现该方法

p.terminate():强制终止进程p，不会进行任何清理操作，如果p创建了子进程，该子进程就成了僵尸进程，使用该方法需要特别的小心。如果p保存了一个锁那么也将不会被释放，进而导致死锁。

p.is_alive():如果p仍然运行，返回True

p.join([timeout]):主线程等待p终止（强调：是主线程处于等的状态，而p是处于运行的状态）。timeout是可选的超时时间，需要强调的是，p.join只能join住start开启的进程，而不能join住run开启的进程  

```

**属性**

```
p.daemon:默认值为False,如果设置为True，代表p为后台运行的守护进程，当p的父进程终止时，p也随之终止，并且设定为True后，p不能创建自己的新进程，必须在p.start()之前设置

p.name:进程的名字

p.pid:进程的id

p.authkey:进程的身份验证
```

### 进程创建的两种方式

```
Process类的构造函数：
__init__(self,group=None,target=None,name=None,args=(),kwargs={})
group:参数未使用，值始终为None
target:表示调用对象，即子进程要执行的任务
name:别名，就是子进程的名字，可自定义
args:调用对象的位置参数，是一个元组
kwargs:调用对象的关键字参数，是一个字典
```

方式一：最常用的（函数式的）

```python
from multiprocessing import Process
import time
def task(name):
	print (f"{name} is runing")
	time.sleep(2)
	print (f'{name} is gone')

if __name__ == '__main__':
	p = Process(target=task,args=("pl",))
    #运行流程
	#1，p.start()只是向系统发出一个开辟子进程的信号，然后就执行下一行
	#2，这个信号操作被系统接收到之后，会从内存中开辟一个子进程空间，然后再将主进程所有数据copy加载到子进程
    #3，然后调用cpu去执行
	p.start()
	print ("主进程开始")
注：
	#在windows环境下，开启进程必须在__name__ == '__main__'下面
    #开辟子进程的开销是很大的
结果：
主进程开始   #在开辟子进程的空间的时候，先去执行主进程中的任务，就是print()这个函数，时间是很短的（这就是并发）
pl is runing
pl is gone
```

方式二：

```python
from multiprocessing import Process
import time
class MyProcess(Process):
	def __init__(self,name):
        #调用父类的__init__
		super().__init__()
		self.name = name
	def run(self):
		print (f"{self.name} is running")
		time.sleep(2)
		print (f"{self.name} is gone")
if __name__ == '__main__':
	p = MyProcess("pl")
	p.start()
	print ("主进程")
结果：
主进程开始
pl is runing
pl is gone
```

### 进程pid

```
如何区分内存中的进程？
	--命令行获取所有的进程的pid  tasklist
	--代码级别获取一个进程的pid  os.getpid()
如何获取父进程（主进程）的pid？
	--os.getppid()
```

### 验证进程之间的空间隔离

```python
#验证进程之间的空间隔离
from multiprocessing import Process
import time
name = "pl"

def task():
	global name
	name = "pl1"
	print (f"子进程：{name}")

if __name__ == '__main__':
	p = Process(target=task)
	p.start()
	time.sleep(2)
	print (f"主进程：{name}")
结果：
pl1
pl #在子进程中改变的全局变量并没有影响主进程中的name，因为
#进程之间的数据是隔离的，子进程改的其实还是他自己空间中的name
#因为它copy了主空间中的资源
```

### 进程对象join方法

```python
#join([timeout])子进程结束再执行下一步
from multiprocessing import Process
import time
def task(sec):
	print ("is running")
	time.sleep(sec)
	print ("is gone")

if __name__ == '__main__':
	start_time = time.time()
	p1 = Process(target=task,args=(1,))
	p2 = Process(target=task, args=(2,))
	p3 = Process(target=task, args=(3,))
#他们开始的时候看似一起执行，但是
	p1.start()
	p2.start()
	p3.start()
	p1.join()
    print(1)
	p2.join()
    print (2)
	p3.join()
    print (3)

	print ("主进程:",time.time()-start_time)
结果：
is running
is running
is running
is gone
1
is gone
2
is gone
3
主进程: 3.69486403465271

#优化上述代码：
lst = []
for i in range(1,4):
    p = Process(target=task,args=(i,))
    lst.append(p)
    p.start()
for i in lst:
    i.join()
    print(lst.index(i)+1)
print("主进程:", time.time() - start_time)
结果：
is running
is running
is running
is gone
1
is gone
2
is gone
3
主进程: 3.6863744258880615
总结：
join就是阻塞，主进程有join，主进程下面的代码一律不执行，直到子进程执行完毕再执行
```

### 守护进程

主进程创建守护进程

　	其一：守护进程会在主进程代码执行结束后就终止

　　其二：守护进程内无法再开启子进程,否则抛出异常：AssertionError: daemonic processes are not allowed to have children

```python
#主进程代码运行完毕,守护进程就会结束
from multiprocessing import Process
from threading import Thread
import time
def foo():
    print(123)
    time.sleep(1)
    print("end123")

def bar():
    print(456)
    time.sleep(3)
    print("end456")


p1=Process(target=foo)
p2=Process(target=bar)

p1.daemon=True
p1.start()
p2.start()
print("main-------") #打印该行则主进程代码结束,则守护进程p1应该被终止,可能会有p1任务执行的打印信息123,因为主进程打印main----时,p1也执行了,但是随即被终止
```

注：p.daemon = True  一定要在子进程start()之前设置

