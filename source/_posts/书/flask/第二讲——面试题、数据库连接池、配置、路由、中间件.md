---
title: 第二讲——面试题、数据库连接池
id: 3
date: 2019-11-20 20:00:00
tags: flask
toc: true
comment: true
---

## 面试题

1.编程语言及他们之间的区别？

```
C/C++ ,很多语言的底层实现都是与C，代码执行效率高，自己做内存管理，对代码要求比较高，很多功
能需要手动试下。
Java，比较好的编程语言，很多企业级应用都会选择java。
C#，是微软开始的编程语言，部署时需要放在windown server 上，最大弊端是window系统花钱。
PHP，一般用于快速搭建网站。
Python，简洁且入门简单，很少的代码就可以做很多事情。
Golang，语法和C比较接近，处理并发时比较有优势 + docker。
```

2.构造函数和析构函数

```python
构造函数，用于创建对象的函数。
析构函数，用于销毁对象的函数。
class Foo(object):
def __new__(self,*args,**kwargs): # 构造函数
pass
def __del__(self,*args,**kwargs): # 析构函数
pass
obj = Foo()
del obj
```

<!----more---->

3.重写和重载的区别?

```python
class Foo(object):
def f1(self,int a1):
return 123
def f1(self,string a1):
pass
重载，函数名相同而参数类型/个数/返回值不同。
class Foo(object):
def f1(self):
print(123)
class Bar(Foo):
def f1(self):
print(666)
重写，在子类中对父类中的方法进行重写。
```

4.什么是接口？

```python
Interface IPerson:
    def f1(self,a1)
    def f2(self,a1)
public interface Predator {
    boolean chasePrey(Prey p);
    void eatPrey(Prey p);
}
接口是以interface关键字开头，内部可以定义方法，但方法中不用写具体实现，他的作用：专门用于
约束实现他的类，Python中没有接口类型。
class UserInfo(IPerson): # UserInfo类实现了IPerson接口
    def f1(self,a1):
    	return 123
    
    def f2(self,a1):
        print(123123)
		return 666
```

5.Python的类执行多继承/ 其他语言不支持多继承

```python
# Python 
class Foo(Base,NewBase): 
	pass 
# 其他 
class Base: 
	pass 
class NewBase(Base): 
	pass 
class Foo(NewBase): 
	pass
```

6.在其他语言中 可以实现多个接口 / 不可以继承多个类

```java
# Java 
interface IBase: 
	def f1(sef) 
interface INewBase: 
	def f2(sef) 
class Foo(IBase,INewBase): 
	def f1(self): 
		pass 
def f2(self): 
	pass
```

7.抽象类和抽象方法

```java
#java 
abstrac class Base(object): # 抽象类 
	def f1(self): # 普通方法 
		print(123) 
	def abstract f2(self): # 抽象方法，内部不能写任何代码 
		pass 
class Foo(Base): 
	def f2(sef): 
		print(123) 
obj = Foo() 
obj.f2() 
obj.f1()
```

8.总结

```
- 重载 
- 重写 
- 构造函数 
	Python
	class Foo: 
		def __new__(self): 
			pass 
	public class Foo{ 
	# 函数和类名相同 
	public void Foo(){ 
		} 
	} 
- 析构函数 
	__del__ 
	finalize 
- 接口 
- 抽象类/抽象方法
```

9.三元运算

10.lambda 表达式

11.yield关键字

12.进程和线程的区别?

13.数据库 

```mysql
数据库设计：博客系统 / 呼啦圈 

SQL语句： 
	select * from user left join depart on user.depart_id = depart.id 
	select * from user left join depart on user.depart_id = depart.id order by id desc 
	inner join 和 left join的区别？ 
	select gender,count(1) from user group by gender 
	select gender,count(1) from user group by gender having count(1) > 2 

视图：是一个虚拟的表。 
	为某个sql语句取名字： select * from user where id<100 ====> t1 
	select * from t1 where name = '成说'、 

存储过程：是大堆存储在数据库中的SQL语句。 
	create producer pro(x1): 
	update ... 
	delete ... 
	select ... 

触发器：存储在数据中的一个特殊的东西。
	create trigger x1 before insert 表: 
	.... 
	create trigger x1 after insert 表: 
```

14.在浏览器上输入 www.xxx.com 发生了什么？

```
- dns解析：www.xxx.com 解析成 IP 
- 本质通过socket进行通信 
- 请求到达框架，以django框架为例：.....
```

15.http和https的区别？

```
http,默认端口：80 
https，默认端口：443 

http的数据是基于明文传输。 
https的数据是基于密文传输。
```

https://www.cnblogs.com/wupeiqi/articles/11647089.html

16.cookie和session的区别？ 

17.get和post的区别？

18.数据结构 

- 链表 

  - 单项 

  - 双向 

- 树 

  - 二叉树前序遍历 

  - 二叉树中序遍历 

  - 二叉树后序遍历 

- 面试题 

  - 伪代码实现一个链表 

  - 对链表进行反转（逆置） 

  - 两个队列生成一个栈 

  - 前序遍历 / 中序遍历 / 后序遍历 

    https://www.cnblogs.com/wupeiqi/p/11604077.html

19.算法 

- 冒泡排序 
- 快速排序 
- 二分查找



## 数据库的连接池

解释：python编程中可以使用pymysql进行数据库连接及增删改查操作，但每次连接mysql请求时，都是独立的去请求访问，比较浪费资源，而且访问数量达到一定数量时，对mysql的性能会产生较大的影响。因此实际使用中，通常会使用数据库的连接池技术，来访问数据库达到资源复用。

**使用的工具**：DBUtils

它提供两种外部接口：

- PersistentDB：提供线程专用的数据库连接，并自动管理连接。
- PooledDB：提供线程间可共享的数据库连接，并自动管理连接。 

**对比**

未使用连接池

```python
def getconn(host, user, passwd, db, sql, port=3306,charset='utf8'):
    conn = pymysql.connect(host=host, user=user, passwd=passwd, port=port, db=db, charset=charset)  #建立连接
    cur = conn.cursor(cursor=pymysql.cursors.DictCursor)        #建立游标并指定游标类型
    cur.execute(sql)                                            #执行sql
    if sql.startswith('select'):                                #判断sql是否是select
        res = cur.fetchone()
    else:
        conn.commit()                                           #insert\delete\update语句执行完毕后需要进行commit
        res = 88
    cur.close()                                                 #关闭游标
    conn.close()                                                #关闭连接
    return res
```

使用数据池：两种模式

模式一

```python
POOL = PersistentDB(
    creator=pymysql,  # 使用链接数据库的模块
    maxusage=None,  # 一个链接最多被重复使用的次数，None表示无限制
    setsession=[],  # 开始会话前执行的命令列表。如：["set datestyle to ...", "set time zone ..."]
    ping=0,
    # ping MySQL服务端，检查是否服务可用。# 如：0 = None = never, 1 = default = whenever it is requested, 2 = when a cursor is created, 4 = when a query is executed, 7 = always
    closeable=False,
    # 如果为False时， conn.close() 实际上被忽略，供下次使用，再线程关闭时，才会自动关闭链接。如果为True时， conn.close()则关闭链接，那么再次调用pool.connection时就会报错，因为已经真的关闭了连接（pool.steady_connection()可以获取一个新的链接）
    threadlocal=None,  # 本线程独享值得对象，用于保存链接对象，如果链接对象被重置
    host='127.0.0.1',
    port=3306,
    user='root',
    password='123',
    database='pooldb',
    charset='utf8'
)

def func():
    conn = POOL.connection(shareable=False)
    cursor = conn.cursor()
    cursor.execute('select * from tb1')
    result = cursor.fetchall()
    cursor.close()
    conn.close()

func()
```

模式二：

```python
import time
import pymysql
import threading
from DBUtils.PooledDB import PooledDB, SharedDBConnection
POOL = PooledDB(
    creator=pymysql,  # 使用链接数据库的模块
    maxconnections=6,  # 连接池允许的最大连接数，0和None表示不限制连接数
    mincached=2,  # 初始化时，链接池中至少创建的空闲的链接，0表示不创建
    maxcached=5,  # 链接池中最多闲置的链接，0和None不限制
    maxshared=3,  # 链接池中最多共享的链接数量，0和None表示全部共享。PS: 无用，因为pymysql和MySQLdb等模块的 threadsafety都为1，所有值无论设置为多少，_maxcached永远为0，所以永远是所有链接都共享。
    blocking=True,  # 连接池中如果没有可用连接后，是否阻塞等待。True，等待；False，不等待然后报错
    maxusage=None,  # 一个链接最多被重复使用的次数，None表示无限制
    setsession=[],  # 开始会话前执行的命令列表。如：["set datestyle to ...", "set time zone ..."]
    ping=0,
    # ping MySQL服务端，检查是否服务可用。# 如：0 = None = never, 1 = default = whenever it is requested, 2 = when a cursor is created, 4 = when a query is executed, 7 = always
    host='127.0.0.1',
    port=3306,
    user='root',
    password='123',
    database='pooldb',
    charset='utf8'
)


def func():
    # 检测当前正在运行连接数的是否小于最大链接数，如果不小于则：等待或报raise TooManyConnections异常
    # 否则
    # 则优先去初始化时创建的链接中获取链接 SteadyDBConnection。
    # 然后将SteadyDBConnection对象封装到PooledDedicatedDBConnection中并返回。
    # 如果最开始创建的链接没有链接，则去创建一个SteadyDBConnection对象，再封装到PooledDedicatedDBConnection中并返回。
    # 一旦关闭链接后，连接就返回到连接池让后续线程继续使用。
    conn = POOL.connection()

    # print(th, '链接被拿走了', conn1._con)
    # print(th, '池子里目前有', pool._idle_cache, '\r\n')

    cursor = conn.cursor()
    cursor.execute('select * from tb1')
    result = cursor.fetchall()
    conn.close()

func()
```

进阶：使用pymysql和DBUtils连接数据库

```python
class OPMysql(object):

    __pool = None

    def __init__(self):
        # 构造函数，创建数据库连接、游标
        self.coon = OPMysql.getmysqlconn()
        self.cur = self.coon.cursor(cursor=pymysql.cursors.DictCursor)


    # 数据库连接池连接
    @staticmethod
    def getmysqlconn():
        if OPMysql.__pool is None:
            __pool = PooledDB(creator=pymysql, mincached=1, maxcached=20, host=mysqlInfo['host'], user=mysqlInfo['user'], passwd=mysqlInfo['passwd'], db=mysqlInfo['db'], port=mysqlInfo['port'], charset=mysqlInfo['charset'])
            print(__pool)
        return __pool.connection()

    # 插入\更新\删除sql
    def op_insert(self, sql):
        print('op_insert', sql)
        insert_num = self.cur.execute(sql)
        print('mysql sucess ', insert_num)
        self.coon.commit()
        return insert_num

    # 查询
    def op_select(self, sql):
        print('op_select', sql)
        self.cur.execute(sql)  # 执行sql
        select_res = self.cur.fetchone()  # 返回结果为字典
        print('op_select', select_res)
        return select_res

    #释放资源
    def dispose(self):
        self.coon.close()
        self.cur.close()
```

参数解释：

- mincached，最少的空闲连接数，如果空闲连接数小于这个数，pool会创建一个新的连接。
- maxcached，最大的空闲连接数，如果空闲连接数大于这个数，pool会关闭空闲连接。
- maxconnections，最大的连接数，进程中最大可创建的线程数。
- blocking， 当连接数达到最大连接数时，再次请求时，如果这个值是True，请求连接的程序会一直等待，直到当前连接数小于最大连接数；如果这个值为False，会报错。
- masxshared，当连接数达到这个数时，新请求的连接会分享已经分配出去的连接。

**连接池对性能的提升**

- 在程序创建连接的时候，可以从一个空闲的连接中获取，不需要重新初始化连接，提升获取连接的速度。
- 关闭连接的时候，把连接放回连接池，而不是真正的关闭，所以可以减少频繁的打开和关闭连接。

**加锁**

```python
import pymysql
import threading
from threading import RLock

LOCK = RLock()
CONN = pymysql.connect(host='127.0.0.1',
                       port=3306,
                       user='root',
                       password='123',
                       database='pooldb',
                       charset='utf8')


def task(arg):
    with LOCK:    #没有锁就会报错
        cursor = CONN.cursor()
        cursor.execute('select * from tb1')
        result = cursor.fetchall()
        cursor.close()

        print(result)


for i in range(10):
    t = threading.Thread(target=task, args=(i,))
    t.start()

```

**封装成函数**

```python
import pymysql
from DBUtils.PooledDB import PooledDB

POOL = PooledDB(
    creator=pymysql,  # 使用链接数据库的模块
    maxconnections=6,  # 连接池允许的最大连接数，0和None表示不限制连接数
    mincached=2,  # 初始化时，链接池中至少创建的链接，0表示不创建
    blocking=True,  # 连接池中如果没有可用连接后，是否阻塞等待。True，等待；False，不等待然后报错
    ping=0, # ping MySQL服务端，检查是否服务可用。# 如：0 = None = never, 1 = default = whenever it is requested, 2 = when a cursor is created, 4 = when a query is executed, 7 = always

    host='127.0.0.1',
    port=3306,
    user='root',
    password='222',
    database='cmdb',
    charset='utf8'
)

def fetchall(sql,*args):
    """ 获取所有数据 """
    conn = POOL.connection()
    cursor = conn.cursor()
    cursor.execute(sql,args)
    result = cursor.fetchall()
    cursor.close()
    conn.close()

    return result

def fetchone(sql, *args):
    """ 获取单挑数据 """
    conn = POOL.connection()
    cursor = conn.cursor()
    cursor.execute(sql, args)
    result = cursor.fetchone()
    cursor.close()
    conn.close()

    return result
```

**封装成类**

```python
import pymysql
from DBUtils.PooledDB import PooledDB

class SqlHelper(object):
    def __init__(self):
        self.pool = PooledDB(
            creator=pymysql,  # 使用链接数据库的模块
            maxconnections=6,  # 连接池允许的最大连接数，0和None表示不限制连接数
            mincached=2,  # 初始化时，链接池中至少创建的链接，0表示不创建
            blocking=True,  # 连接池中如果没有可用连接后，是否阻塞等待。True，等待；False，不等待然后报错
            ping=0,
            # ping MySQL服务端，检查是否服务可用。# 如：0 = None = never, 1 = default = whenever it is requested, 2 = when a cursor is created, 4 = when a query is executed, 7 = always
            host='127.0.0.1',
            port=3306,
            user='root',
            password='222',
            database='cmdb',
            charset='utf8'
        )

    def open(self):
        conn = self.pool.connection()
        cursor = conn.cursor()
        return conn,cursor

    def close(self,cursor,conn):
        cursor.close()
        conn.close()

    def fetchall(self,sql, *args):
        """ 获取所有数据 """
        conn,cursor = self.open()
        cursor.execute(sql, args)
        result = cursor.fetchall()
        self.close(conn,cursor)
        return result

    def fetchone(self,sql, *args):
        """ 获取所有数据 """
        conn, cursor = self.open()
        cursor.execute(sql, args)
        result = cursor.fetchone()
        self.close(conn, cursor)
        return result


db = SqlHelper()
```





















































