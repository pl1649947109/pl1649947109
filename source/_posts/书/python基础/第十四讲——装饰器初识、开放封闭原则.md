---
title: 第十四讲——装饰器初识、开放封闭原则
id: 14
date: 2019-8-2 20:00:00
tags: Python
comment: true
---

### 今日学习大纲：

- 开放封闭原则

- 初识装饰器
- 练习

<!-----more----->

### 开放封闭原则

一、 什么是 开放封闭原则？
   - 对扩展开放
     - 我们的软件一旦上线之后（比如你的软件主要是多个函数组成的）,那么这个软件对功能的扩展应该是开放的，比如你的游戏一直在迭代更新，推出新的玩法，新功能。
   - 对修改封闭
     - 对于源代码的修改是封闭的。你就拿函数举例，如果你的游戏源代码中有一个函数是闪躲的功能，那么你这个函数肯定是被多个地方调用的，比如对方扔雷，对方开枪，对方用刀，你都会调用你的闪躲功能，那么如果你的闪躲功能源码改变了，或者调用方式改变了，当对方发起相应的动作，你在调用你的闪躲功能，就会发生问题。
二、什么是装饰器
   - 从字面上来说，我们可以得到两个信息。一个是装饰，装饰是什么，就是添加新的东西，对吧。器，器乃工具也，所以说，装饰器就是在原来的基础上添加新的功能的一种工具。今天哦我们讲的装饰器就是以功能为向导的，就是一个函数。
   - 装饰器的定义：在不改变原被装饰的函数的源代码以及调用方式下，为其添加额外的共功能。

### 初识装饰器

```python
#__*__coding:utf-8__*__
import time
#装饰器
#装饰器带入一
def times(f):
	def inner():
		start_time = time.time()
		f()
		print (time.time() - start_time)
	return inner
def foo():
	time.sleep(1)
	print ("我是装饰器。")
foo = times(foo)
#执行流程：把foo函数的名称当作参数传给times函数中，现在times函数初始化inner函数，并
#返回inner函数的地址，并把它当作变量赋值给foo。
foo()
#现在的foo就是inner，foo()就是执行inner里面的代码，现在执行到f()就是foo()函数。

#装饰器带入二
def wrapper(f):
	def inner():
		print (f())
	return inner
def func():
	print("这是一个func函数。")
func = wrapper(func)
#简述：wrapper函数执行并接收func函数名作为参数，并返回inner函数名给func变量。
func()
#func()实际执行的是inner()，但是inner()函数里面调用了func()函数。
#总结：首先调用增加功能的函数，并给他传入需要增加功能的函数，返回的是一个嵌套的函数名，
# 进一步调用返回的函数，就是触发调用需要增加功能的函数。


#现在，我们初步了解了装饰器的功能，那么怎么实现它呢。下面我们详细讲一讲：
#low版的装饰器
def wrapper(f):
	def inner(*args,**kwargs):
		#被装饰前
		start_time  = time.time()
		f(*args,**kwargs)
		print (time.time() - start_time)
	return inner  #切记。返回的是函数名，而非函数，所以不要加()
def func(*args,**kwargs):
	print (f"这是{args}函数。")  #接收的数据是一元组的形式保存的
	time.sleep(2)
func = wrapper(func)
func("装饰器的low版")

#高级版的装饰器
def wrapper(f):
	def inner(*args,**kwargs):
		#被装饰前
		start_time  = time.time()
		f(*args,**kwargs)
		print (time.time() - start_time)
		#被装饰后
	return inner
@wrapper  #这行代码就等价于func = wrapper(func)
def func(*args,**kwargs):
	print (f"这是{args}函数。")
	time.sleep(2)
@wrapper  #这行代码就等价于foo = wrapper(foo)
def foo(*args,**kwargs):
	print (f"这是{args}函数。")
	time.sleep(3)
func("func","func")
foo("foo","foo")
#分析：@wrapper()就叫做语法糖。语法糖必须凡在被装饰函数的正上方。

#实例：（需求分析：现在我们模拟博客园，当我们没有登陆想去评论或者点击收藏等操作时，都自动的
#跳转到登陆的界面，当登陆成功之后就自动的跳转到刚才来登陆之前的界面。 ）
login_dic = {
	"username":None,
	"flag":False
}
#这个就是我们增加功能的函数，就相当于一个桥梁函数，就是以它为媒介做的跳转
def auth(f):
	def inner(*args,**kwargs):
		if login_dic["flag"]:
			return f()
		else:
			return login()
	return inner

def login():
	print("这是一个登录页面")
	user = input("username:")
	pwd = input("password:")
	if user == "pl" and pwd == "123":
		login_dic["flag"] = True
		login_dic["username"] = user
		return "登录成功!"
@auth
def comment():
	print(f"这是{login_dic['username']}评论")
@auth
def index():
	print(f"这是{login_dic['username']}主页")
	return "主页没有内容。"
#我们首先看看有没有登陆，没有登陆就跳转登陆
while not login_dic["flag"]:
	if comment() == "登录成功!":
		comment()
```
### 练习

```python
#2写一个登录返回评论的系统
login_dic = {
	"username":None,
	"flag":False
}
#这个就是我们增加功能的函数，就相当于一个桥梁函数，就是以它为媒介做的跳转
def auth(f):
	def inner(*args,**kwargs):
		if login_dic["flag"]:
			return f()
		else:
			return login()
	return inner

def login():
	print("这是一个登录页面")
	user = input("username:")
	pwd = input("password:")
	if user == "pl" and pwd == "123":
		login_dic["flag"] = True
		login_dic["username"] = user
		print ("登陆成功!")
		return "登录成功!"
@auth
def comment():
	print(f"这是{login_dic['username']}评论")
@auth
def index():
	print(f"这是{login_dic['username']}主页")
	return "主页没有内容。"
#我们首先看看有没有登陆，没有登陆就跳转登陆
while not login_dic["flag"]:
	print (tabulate.tabulate([[1,2,3],["登陆","评论","主页"]],tablefmt="grid"))
	id = input("按照指引输入：")
	if id.isdecimal():
		if int(id) == 1:
			login()
		if int(id) == 2:
			if comment() == "登录成功!":
				comment()
		if 	int(id) == 3:
			if index() == "登录成功!":
				index()
```

```python
#为函数写一个装饰器，把函数的返回值 +100 然后再返回。
def wrapper(f):
	def inner():
		return f() + 100
	return inner

@wrapper
def func():
	return 7

result = func()
print(result)

```

```python
#看代码写结果：
# def wrapper(f):
#     def inner(*args,**kwargs):
#         print(111)
#         ret = f(*args,**kwargs)
#         print(222)
#         return ret
#     return inner
#
# def func():
#     print(333)
#
# print(444)
# func()
# print(555)
# #>>>444 333 555
```

```python
# 4,编写装饰器,在每次执行被装饰函数之前打印一句’每次执行被装饰函数之前都得先经过这里’。
def wrapper(f):
	def inner():
		print("每次执行被装饰函数之前都得先经过这里。")
		f()
	return inner
@wrapper  #func = wrapper(func)  func==inner
def func():
	print ("我是一个被装饰的函数。")
func()
```

```python
#请实现一个装饰器，通过一次调用使被装饰的函数重复执行5次。
def wrapper(f):
	def inner():
		for i in range(5):
			f()
	return inner
@wrapper
def func():
	print ("我执行一下。")

func()
```

```python
#请实现一个装饰器，每次调用函数时，将被装饰的函数名以及调用被装饰函数
# 的时间节点写入文件中。可用代码：
# struct_time = time.localtime()
# print(time.strftime("%Y-%m-%d %H:%M:%S",struct_time)) # 获取当前时间节点

def func():
	print(func.__name__())
# 函数名通过： 函数名.__name__获取。
def wrapper(f):
	def inner():
		struct_time = time.localtime()
		print(time.strftime("%Y-%m-%d %H:%M:%S", struct_time))  # 获取当前时间节点
		f()
		func_name = f.__name__
		with open('./text','a',encoding='utf-8') as fp:
			fp.write(str(time.strftime("%Y-%m-%d %H:%M:%S", struct_time))+":"+func_name+"\n")
	return inner
@wrapper
def func():
	time.sleep(2)
	print ("函数名：func")
@wrapper
def foo():
	time.sleep(2)
	print ("函数名：foo")
@wrapper
def ret():
	time.sleep(2)
	print ("函数名：ret")

for i in range(5):
	func()
	foo()
	ret()
```



