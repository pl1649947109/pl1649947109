---
title: 第二十一讲——面向对象之空间角度研究类、类和类的关系
id: 21
date: 2019-8-9 20:00:00
tags: Python
comment: true
---

### 学习大纲

- 从空间角度研究类
  - 何处可以添加对象属性
  - 何处可以添加类的属性
  - 对象空间和类空间的关系（对象查找的顺序）
- self详讲
- 类和类之间的关系
- 浅谈类命名空间
- 练习

<!-----more----->

### 从空间角度研究类

**何处可以添加对象的属性**

- 在__init__中可以添加

- 在类方法中也可以添加

- 实例化对象之后在类的外部添加

- 实例

   ```python
   class Human:
   	def __init__(self,name):
   		self.name = name  #在init中添加对象的属性
   	def func(self,body):
   		self.body = body
   		print (self.name)
   man = Human("pl")  #__dict__查看对象的所有属性
   print (man.__dict__)
   # {'name': 'pl'}
   man.age = 20  #实例化对象之后类的外部添加
   print(man.__dict__)
   # {'name': 'pl', 'age': 20}
   man.func("打球")   #在类方法中添加对象的属性
   print(man.__dict__)
   # {'name': 'pl', 'age': 20, 'body': '打球'}
   ```

**何处可以添加类的属性**

- 在类的内部添加类的属性（就是类的方法里面添加类的属性）

- 在类的外部添加类的属性

- 实例

   ```python
   class Human:
   	name = "pl"
   	def func(argv):
   		Human.argv = argv #在类的方法里面添加类的属性（类的内部添加）
   		print (Human.name)
   Human.func("打球")
   print(Human.__dict__)
   #  'argv': '打球'}
   Human.age = 12   #在类的外部添加类的属性
   print (Human.__dict__)
   # 'argv': '打球', 'age': 12}
   ```

**类和对象的关系（对象查找的顺序）**

- 当对象空间和类空间具有相同的名字时（对象.名字）。该去怎么查找？
- 查找顺序
   - 对象.名字:先去对象空间中查找》-----通过类对象指针----》类空间找》父类空间找》最后到object类中查找

   - 类名.名字:类空间找》父类空间找》最后到object类中查找

   - 实例

      ```python
      class Human:
      	name = "pl"
      	def __init__(self,age):
      		self.age = age
      	#这个例子就是在对象中没有name这个属性，最后在调用的时候就去类属性里面去寻找
      	def foo(self):
      		print (self.name)
      p1 = Human(12) 
      p1.foo()
      #>>>pl
      ```


### self详讲

1. 在我们学习定义类的过程中，无论是显示创建类的构造方法，还是向类中添加实例方法，都要将self当作第一个参数，这只是python程序员约定俗称的一种习惯，会使程序具有更好的可读性。
2. self参数的具体作用是什么呢？
   - 同一个类可以产生多个对象，当某个对象调用类方法时，该对象会把自身的引用作为第一个参数自动传给该方法，换句话说，Python会自动绑定类方法的第一个参数指向调用该方法的对象。

### 类和类的关系

- 类和类在python里面有3种关系：


1. 依赖关系：将一个类的类名或对象传入另一个类的方法中。（有主从之分）
2. 组合关系：将一个类名或类的对象封装到另一个类的属性中。（以后在工作中常用）
3. 继承关系（这一节先讲前两种）

##### 依赖关系

```python
class Elephant:

	def __init__(self,name):
		self.name = name

	def open(self,obj):
		print (f"{self.name}默念三声123，开门。")
		obj.bx_open()
	def close(self,obj):
		print (f"{self.name}默念三声321，关门。")
		obj.bx_close()

class binxiang:

	def __init__(self,name):
		self.name = name

	def bx_open(self):
		print (f"{self.name}冰箱被打开了。")
	def bx_close(self):
		print (f"{self.name}冰箱被关闭了。")

qiqi = Elephant("琪琪")
haier = binxiang("海尔")
qiqi.open(haier) #把haier这个实例化的对象传给了qiqi，的对象者的一切。
qiqi.close(haier)
```

##### 组合关系

```python
class Boy:
	def __init__(self,name,grilfriend=None):
		self.name = name
		self.grilfriend = grilfriend

	def have_a_drinner(self):
		if self.grilfriend:
			print (f"{self.name}请他的{self.grilfriend.age}岁的,{self.grilfriend.body}的女朋友{self.grilfriend.name}一起烛光晚餐。")
		else:
			print (f"{self.name}是个单身狗。")

	def gril_skill(self):
		print (f"{self.name}的女朋友的技能：")
		self.grilfriend.skill()

class Gril:
	def __init__(self,name,age,body):
		self.name = name
		self.age = age
		self.body = body

	def skill(self):
		print (f"{self.name}会用萝莉音直播.")

boy = Boy('pl')
gril = Gril("qili",20,"可爱")
boy.grilfriend = gril  #把实例话的gril对象传给boy对象中充当属性，通过它一样可以得到一切。
boy.have_a_drinner()
boy.gril_skill()
```

##### 依赖+组合

```python
class GameRole:

	def __init__(self,name,ad,hp):
		self.name = name
		self.ad = ad
		self.hp = hp

	def attack(self,pl):
		pl.hp = pl.hp - self.ad
		print (f"{self.name}攻击{pl.name},谁掉了{self.ad}血，还剩{pl.hp}血")
		print (f"{pl.name}的血量{pl.hp}")

	def equipment_wre(self,wre):
		self.weapon = wre  #组合关系，把武器这个对象封装到人物类的方法中，也就成为了人物动态的属性

class Weapon:

	def __init__(self,name,ad):
		self.name = name
		self.ad = ad

	def weapon_attackk(self,p1,p2):  #依赖关系
		p2.hp = p2.hp - self.ad
		print (f"{p1.name}利用{self.name}给了{p2.name}一下子，{p2.name}掉了{self.ad}血，还剩{p2.hp}血")

galen = GameRole("盖伦",10,100)
xin = GameRole("赵信",20,80)
jian = Weapon("大宝剑",10)
qiang = Weapon("红缨枪",25)
#给人物封装武器类属性
galen.equipment_wre(jian)
#人物调用它下面的方法得到武器类的对象，操作武器类下面的攻击方法（调用人物）。
galen.weapon.weapon_attackk(galen,xin)
```

总结:依赖和组合的关系会实际的使用，依赖和组合就是让类和类产生关系，增强他们之间的耦合性。

### 练习

### 练习

```python
'''
暴力摩托程序（完成下列需求）：
创建三个游戏人物，分别是：
	苍井井，女，18，攻击力ad为20，血量200
	东尼木木，男，20，攻击力ad为30，血量150
	波多多，女，19，攻击力ad为50，血量80
创建三个游戏武器，分别是：
 平底锅，ad为20
	斧子，ad为50
	双节棍，ad为65
创建三个游戏摩托车，分别是：
	小踏板，速度60迈
	雅马哈，速度80迈
	宝马，速度120迈。
	完成下列需求（利用武器打人掉的血量为武器的ad + 人的ad）：
	（1）苍井井骑着小踏板开着60迈的车行驶在赛道上。
	（2）东尼木木骑着宝马开着120迈的车行驶在赛道上。
	（3）波多多骑着雅马哈开着80迈的车行驶在赛道上。
	（4）苍井井赤手空拳打了波多多20滴血，波多多还剩xx血。
	（5）东尼木木赤手空拳打了波多多30滴血，波多多还剩xx血。
	（6）波多多利用平底锅打了苍井井一平底锅，苍井井还剩xx血。
	（7）波多多利用斧子打了东尼木木一斧子，东尼木木还剩xx血。
	（8）苍井井骑着宝马打了骑着小踏板的东尼木木一双节棍，东尼木木哭了，还剩xx血。（选做）
	（9）波多多骑着小踏板打了骑着雅马哈的东尼木木一斧子，东尼木木哭了，还剩xx血。（选做）
'''
class Human:
	def __init__(self,name,sex,age,ad,hp):
		self.name = name
		self.sex = sex
		self.age = age
		self.ad =ad
		self.hp = hp

	def func(self,m):
		print (f"{self.name}骑着{m.name}开着{m.speed}迈的车行驶在赛道上。")
	def fight(self,h):
		h.hp -= self.ad
		print (f"{self.name}赤手空拳打了{h.name}{self.ad}滴血，{h.name}还剩{h.hp}血。")
	def fight1(self,h,a):
		h.hp = h.hp -(self.ad+a.ad)
		print (f"{self.name}利用{a.name}打了{h.name}一{a.name}，{h.name}还剩{h.hp}血。")
	def fight2(self,h,m,m1,a):
		h.hp = h.hp - (a.ad+self.ad)
		print (f"{self.name}骑着{m.name}打了骑着{m1.name}的{h.name}一{a.name}，{h.name}哭了，还剩{h.hp}血。")

class Arms:
	def __init__(self,name,ad):
		self.name = name
		self.ad =ad

class Motorcycle:
	def __init__(self,name,speed):
		self.name = name
		self.speed = speed

h1 = Human(	'苍井井','女',18,20,200)
h2 = Human(	'东尼木木','男',20,30,150)
h3 = Human(	'波多多','女',19,50,80)
a1 = Arms('平底锅',20)
a2 = Arms('斧子',50)
a3 = Arms('双节棍',65)
m1 = Motorcycle("小踏板",60)
m2 = Motorcycle("雅马哈",80)
m3 = Motorcycle("宝马",120)
# h1.func(m1)
# h2.func(m3)
# h3.func(m2)
# h1.fight(h3)
# h2.fight(h3)
# h3.fight1(h1,a1)
# h3.fight1(h2,a2)
# h1.fight2(h2,m3,m1,a3)
# h3.fight2(h2,m1,m2,a2)
```

```
# 2定义一个类，计算圆的周长和面积。
class Circular:
	PI = 3.1415926

	def __init__(self,radius):
		self.radius = radius

	def area(self):
		return Circular.PI*(self.radius**2)

	def perimeter(self):
		return 2*Circular.PI*self.radius

	def run(self):
		print (f"面积：{Circular.area(self)}\n周长：{Circular.perimeter(self)}")

a = Circular(2)
a.run()
```

```python
# 定义一个圆环类，计算圆环的周长和面积（升级题）。
class Ring:
	PI = 3.1415926

	def __init__(self,inside_radius,external_radius):
		self.inside_radius = inside_radius
		self.external_radius = external_radius

	def perimeter(self):
		return 2*Circular.PI*(self.inside_radius+self.external_radius)

	def area(self):
		return Circular.PI*((self.external_radius)**2-(self.inside_radius)**2)

	def run(self):
		print (f"面积：{Ring.area(self)}\n周长：{Ring.perimeter(self)}")

a = Ring(2,5)
a.run()
```

```python
"""
定义一个学校类，一个老师类。

学校类要求：

学校类封装学校名称，学校地址，以及相关老师（以列表形式存放老师对象）的属性。

name: 学校名称。
address: 具体地址。
teacher_list: []。
学校类设置添加老师对象的方法。

老师类封装姓名，教授学科，以及所属学校的具体对象。

name: 老师名。
course: 学科。
school: 具体学校对象。
实例化2个校区：

北京校区，美丽的沙河；
深圳校区，南山区。
实例化6个老师：

太白，Python, 北京校区对象。
吴超，linux, 北京校区对象。
宝元，python, 北京校区对象。
苑昊，python, 深圳校区对象。
小虎，linux, 深圳校区对象。
小王，Python，深圳校区对象。
完成以下具体需求：

获取太白所属学校名称。

获取太白所属学校的学校地址。

将所有属于北京校区的所有老师名展示出来，并添加到一个列表中。

将所有属于深圳校区的所有老师以及所负责的学科展示出来。

将两个校区的负责Python学科的所有老师对象添加到一个列表中。

将两个校区的负责linux学科的所有老师对象添加到一个列表中并循环展示出来。

将北京校区这个对象利用pickle写入文件中，然后读取出来，并展示出所属于北京校区的老师姓名。
"""
class School:
	def __init__(self,name,address,teacher_list=None):
		self.name = name
		self.address = address
		self.teacher_list = teacher_list


class Teacher:
	def __init__(self,name,course,school):
		self.name = name
		self.course = course
		self.school = school
	def func(self,obj):
		self.obj = obj
	def address(self):
		return self.obj.address
	def test3(self,*args):
		lst = []
		for i in args:
			if i.school == "北京校区":
				lst.append(i.name)
		print (lst)
	def test4(self,*args):
		lst1 = []
		for i in args:
			if i.school == "深圳校区":
				lst1.append(i.course)
		print (lst1)
	def test5(self,*args):
		lst2 = []
		for i in args:
			if i.course == "Python":
				lst2.append(i)
		print(lst2)
	def test6(self,*args):
		lst3 = []
		for i in args:
			if i.course == "linux":
				lst3.append(i)
		print(lst3)

s1 = School("北京校区","美丽的沙河")
s2 = School("深圳校区","南山区")
t1 = Teacher('太白','Python','北京校区')
t2 = Teacher('吴超','linux','北京校区')
t3 = Teacher('宝元','Python','北京校区')
t4 = Teacher('苑昊','Python','深圳校区')
t5 = Teacher('小虎','linux','深圳校区')
t6 = Teacher('小王','Python','深圳校区')
# print (t1.school)
# t1.func(s1)
# print (t1.address())
Teacher.test3(None,t1,t2,t3,t4,t5,t6)
Teacher.test4(None,t1,t2,t3,t4,t5,t6)
Teacher.test5(None,t1,t2,t3,t4,t5,t6)
Teacher.test6(None,t1,t2,t3,t4,t5,t6)
s1.teacher_list = [t1,t2,t3,t4,t5,t6]
with open('./aaa','wb') as f:
	pickle.dump(s1,f)
with open('./aaa','rb') as f:
	s = pickle.load(f)
for i in s.teacher_list:
	if i.school == "北京校区":
		print (i.name)
```