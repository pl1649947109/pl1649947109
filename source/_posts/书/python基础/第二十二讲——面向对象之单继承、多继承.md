---
title: 第二十二讲——面向对象之单继承、多继承
id: 22
date: 2019-8-10 20:00:00
tags: Python
comment: true
---

### 学习大纲

- 初始继承
- 继承的优点
- 单继承
  - 类名、对象执行父类的属性、方法。
  - 执行的顺序
  - 同时执行类以及父类的方法
- 多继承
- 练习

<!-----more----->

### 初始继承

1. 什么是继承？
   1. 继承就是子乘父业，子类继承父类的一切东西，包括属性和方法。
   2. 专业角度：B类继承A类。（B就是子类或者派生类，A类就是父类、基类或者超类）
2. 面向对象的三大特征：
   1. 继承：实现代码的重用，相同的代码不需要重复的编写。
   2. 封装：根据职责将属性和方法封装到一个抽象的类中。
   3. 多态：不同的对象调用相同的方法，产生不同的执行结果增加代码的灵活度。

### 继承的优点

1. 减少重复的代码。
2. 增加类之间的耦合性。
3. 使得代码更加规范化，合理化。

### 单继承

**类名、对象执行父类的属性、方法。**

```python
#一、类名、对象执行父类的属性和方法
# 1，类名执行父类属性、方法
class Animal:
	live = "有生命的"

	def __init__(self,name,sex,age):
		self.name = name
		self.sex = sex
		self.age = age

	def eat(self):
		print ("动物都需要进食。")

class Human(Animal):
	live = "有思想的活着。"

class Human(Animal):
	live = "有思想的活着。"

print (Human.live)
Human.eat(None)

#2，子类对象 执行父类的属性、方法
class Animal:
	live = "有生命的"

	def __init__(self,name,sex,age):
		self.name = name
		self.sex = sex
		self.age = age

	def eat(self):
		print (self)
		#<__main__.Human object at 0x000001A771BC9B70> self的对象时Human
		print ("动物都需要进食。")

class Human(Animal):
	body ="有头有脸"

obj = Human ("pl","man",23)
# a1 = Animal("pl","man",23)
# print (a1.body)   报错  父类不能使用子类的属性方法
print (obj.live)
print (obj.eat())
```

**执行的顺序**

```python
#二、执行的顺序
class Aniaml(object):
	type_name = "动物类"
	def __init__(self,name,sex,age):
		self.name = name
		self.sex = sex
		self.age = age
		print(self)
		#<__main__.Person object at 0x000001CBF26C9B70>

	def eat(self):
		print (self)
		print ("吃东西")

class Person(Aniaml):
	def eat(self):
		print (self)
		#<__main__.Person object at 0x000001CBF26C9B70>
		print ("%s吃饭"%self.name)

class Cat(Aniaml):
	pass

#实例化对象必须执行__init__方法，类中没有，就去父类中找，父类中没有，就去object类中找
p1 = Person("pl","男",23)
p1.eat()
#pl吃饭
```

**同时执行类以及父类的方法**

```python
#既要执行子类的方法，又要执行父类的方法(自己没有的属性实例化通过两种方法传给父类，同时自己也可以使用）
#方法一：不依赖继承的
# 实例一
class Animal:
	def __init__(self,name,sex,age):
		self.name = name
		self.sex = sex
		self.age = age

class Human():
	def __init__(self,name,sex,age,hobby):
		Animal.__init__(self,name,sex,age)  #self == Human
		self.hobby = hobby

obj = Human('pl','nan',23,"打球")
print(obj.__dict__)
# {'name': 'pl', 'sex': 'nan', 'age': 23, 'hobby': '打球'}
# 实例二
class Aniaml(object):
	type_name = "动物类"
	def __init__(self,name,sex,age): #4
		self.name = name
		self.sex = sex
		self.age = age
		print (self.__dict__)
		#{'name': 'pl', 'sex': '男', 'age': 23}

	def eat(self):
		print ("吃东西")

class Person():
	def __init__(self,name,sex,age,mind): #2
		Aniaml .__init__(self,name,sex,age) #3
		self.mind = mind #5

	def eat(self):
		print ("%s吃饭"%self.name)

p1 = Person('pl','男',23,"有思想的") #1
print (p1.__dict__)
#{'name': 'pl', 'sex': '男', 'age': 23, 'mind': '有思想的'}
print(Aniaml.eat(None))
#吃东西：执行的是Animal的方法
# None
print (p1.eat())
# pl吃饭
# None

#方法二:依赖于继承
# 例子一
class Animal:
	def __init__(self,name,sex,age):
		self.name = name
		self.sex = sex
		self.age = age
		print (self)
		#<__main__.Human object at 0x000001B915DC6048>

class Human(Animal):
	def __init__(self,name,sex,age,hobby):
		# super(Human,self).__init__(name,sex,age)  完整的写法
		super().__init__(name,sex,age)  #执行父类的__init__方法，重构父类方法
		self.hobby = hobby

obj = Human('pl','nan',23,"打球")
print(obj.__dict__)
#{'name': 'pl', 'sex': 'nan', 'age': 23, 'hobby': '打球'}

# 例子二
class Animal:
	def __init__(self,name,sex,age):
		self.name = name
		self.sex = sex
		self.age = age

	def eat(self):
		print("我是爹")

class Human(Animal):
	def __init__(self,name,sex,age,hobby):
		#Animal.__init__(self,name,sex,age)
		# super(Human,self).__init__(name,sex,age)  完整的写法
		super().__init__(name,sex,age)  #执行父类的__init__方法，重构父类方法
		self.hobby = hobby


	def eat(self):
		Animal.eat(None)
		print("我是崽")

obj = Human('pl','nan',23,"打球")
obj.eat()
```

```python
实例练习
#1
class Base:
    def __init__(self, num): #2
        self.num = num #3
    def func1(self):#5
        print(self.num) #6

class Foo(Base):
    pass
obj = Foo(123) #1
obj.func1() # 123 运⾏的是Base中的func1   #4

# 2
class Base:#1
    def __init__(self, num): #2#6
        self.num = num#7
    def func1(self):#3
        print(self.num)
class Foo(Base):#4
    def func1(self):#5#9
        print("Foo. func1", self.num)#10
obj = Foo(123)#6
obj.func1() # Foo. func1 123 运⾏的是Foo中的func1 #8

# 3
class Base:#1
    def __init__(self, num):#2#8
        self.num = num#9
    def func1(self):#3#12
        print(self.num)#13
        self.func2()#14
    def func2(self):#4
        print("Base.func2")
class Foo(Base):#5
    def func2(self):#6#15
        print("Foo.func2")#16
obj = Foo(123)#7#10
obj.func1() # 123 Foo.func2 func1是Base中的 func2是⼦类中的  #11

# 4
class Base:
    def __init__(self, num):
        self.num = num
    def func1(self):
        print(self.num)
        self.func2()
    def func2(self):
        print(111, self.num)
class Foo(Base):
    def func2(self):
        print(222, self.num)
#这个列表里面装的就是Base类的实例，在下面的for循环中就是将他们每一个实例化
lst = [Base(1), Base(2), Foo(3)]
for obj in lst:
    obj.func2()
# 111 1 | 111 2 | 222 3

# 5
class Base:
    def __init__(self, num):
        self.num = num
    def func1(self):
        print(self.num)
        self.func2()
    def func2(self):
        print(111, self.num)
class Foo(Base):
    def func2(self):
        print(222, self.num)
lst = [Base(1), Base(2), Foo(3)]
for obj in lst:
 obj.func1()
```

### 多继承

一、python的类分为两种：

- 经典类：在python2.2之前。不继承object类，遵循深度优先原则。
- 新式类：在python2.2之后。继承object类，遵循mro(C3)算法。

- 在3.0之后就只有一种类了就是新式类。

二、实例

```python
class O:
    name = '太白'

class D(O):
    pass

class E(O):
    name = '李业'
    # pass
class F(O):
    name = '宝元'

class B(D,E):
    pass

class C(E,F):
    pass

class A(B,C):
    pass

obj = A()
print(obj.name)
print (A.mro())  #这个就是C3算法的方法
#[<class '__main__.A'>, <class '__main__.B'>, <class '__main__.D'>, <class '__main__.C'>, <class '__main__.E'>, <class '__main__.F'>, <class '__main__.O'>, <class 'object'>]
#计算
#实例一
mro(C(E,F) = [C] + merge([E,O],[F,O],[E,F])
mro(C(E,F) = [C,E] + merge([O],[F,O],[F])
mro(C(E,F) = [C,E,F] + merge([O],[O])
mro(C(E,F) = [C,E,F,O]
#实例二：
原式= [A] + merge( [B,D,E,O], [C,E,F,O], [B,C])
    = [A,B] + merge( [D,E,O], [C,E,F,O],   [C])
    = [A,B,D] + merge( [E,O], [C,E,F,O],   [C])  # 跳过E
    = [A,B,D,C] + merge([E,O],  [E,F,O])
    = [A,B,D,C,E] + merge([O],    [F,O])  # 跳过O
    = [A,B,D,C,E,F] + merge([O],    [O])
    = [A,B,D,C,E,F,O]
```

**补充：**

```python
Python中类的初始化都是__init__(), 所以父类和子类的初始化方式都是__init__(), 但是如果子类初始化时没有这个函数，那么他将直接调用父类的__init__(); 如果子类指定了__init__(), 就会覆盖父类的初始化函数__init__()，如果想在进行子类的初始化的同时也继承父类的__init__(), 就需要在子类中显示地通过super()来调用父类的__init__()函数。
super()在单继承中的应用：

举个例子：

class Animal:  # 定义一个父类
    def __init__(self):  # 父类的初始化
        self.name = 'animal'
        self.role = 'parent'
        print('I am father')
 
class Dog(Animal):  # 定一个继承Animal的子类
    def __init__(self):  # 子类的初始化函数，此时会覆盖父类Animal类的初始化函数
        super(Dog, self).__init__()  # 在子类进行初始化时，也想继承父类的__init__()就通过super()实现,此时会对self.name= 'animal'
        print('I am son')
        self.name = 'dog'  # 定义子类的name属性,并且会把刚才的self.name= 'animal'更新为'dog'
# animal = Animal()#I am father
xbai = Dog()#I am father,I am son
print(xbai.name)#'dog'
print(xbai.role)#'parent'
说明：super(Dog,self)也可以写成super()，可以理解成super(Dog,self).__init__() == Animal.__init__(self)，( super(Dog,self) == Animal ) 即其返回的是当前类的继承顺序中（针对多继承）Dog后的一个类（也即类Animal）

self 和 super的区别：

    self会首先调用自己的方法或者属性，当自身没有目标属性或方法时，再去父类中寻找；super会直接去父类中寻找目标属性或方法。如上述代码中定义完第十行后，self.name的返回值为’dog’，而super().name的返回值为’animal’;
    self是类，super是预编译指令
```

### 总结：

- 通常推荐不要使用多继承，尽量使用单继承。

### 练习

```python
# 简答题：
#
# 1面向对象的三大特性是什么？
# 封装、继承、多态
# 2什么是面向对象的新式类？什么是经典类？
# 继承object的类的是新式类，不继承object的是经典类
# 3面向对象为什么要有继承？继承的好处是什么？
# 这是因为为了满足开发的需要
# 优点：减少重复的代码
# 	  提高了代码之间的耦合性
# 	  规范化程序的结构，让代码更清晰
# 4面向对象中super的作用。
# 重构父类中的方法
```

```python
# 代码题(通过具体代码完成下列要求)：

class A:
    def func(self):
        print('in A')

class B:
    def func(self):
        print('in B')

class C(A):
    def func(self):
        super().func()
        print('in C')
        
# 	可以改动上上面代码，完成下列需求：对C类实例化一个对象产生一个c1，然后c1.func()

# # 	1. 让其执行C类中的func
# c1 = C()
# c1.func()
# # 	2. 让其执行A类中的func
# class C(A):
#     pass
# c1.func()
# # 	3. 让其执行B类中的func
# class C(B):
#     pass
# c1.func()
# # 	4. 让其既执行C类中的func，又执行A类中的func
# class C(A):
#     def func(self):
#         super().func()
#         print('in C')
# c1 = C()
# c1.func()
# # 	5. 让让其既执行C类中的func，又执行B类中的func
# class C(B):
#     def func(self):
#         super().func()
#         print('in B')
```

```python
# 下面代码执行结果是什么？为什么？

class Parent:#1
    def func(self):#2
        print('in Parent func')

    def __init__(self):#3#7
        self.func()#8

class Son(Parent):#4#6
    def func(self):#5#9
        print('in Son func')#10

son1 = Son()#6
#in Son func  因为实例化Son的时候执行了其父类的__init__方法，然后就调用了func方法，
#首先在子类中去寻找该方法，，找到了就print出来了。
```

```python
#4
class A:
    name = []

p1 = A()
p2 = A()
p1.name.append(1)
print(p1.name)
print (p2.name)
print (A.name)
# 分别是什么？
#[1] [1] [1]  因为p1和p2都是实例化的对象，对象可以得到一切
p1.age = 12  #这个通过实例的p1写进p1开辟的新的空间中
print (p1.age)
# print (p2.age)   #p2开辟的空间里面找不到，所以报错
# print (A.age)    #A中也没有age所以找不到就报错了
# 分别又是什么？为什么？
# 12 报错 报错
```

```python
# 写出下列代码执行结果：

class Base4:
    def f1(self):
        print('base4.4')

class Base3:
    def f1(self):
        print('base3.f3')

class Base1:
    def f1(self):
        print('base1.f1')

    def f2(self):
        print('base1.f2')

    def f3(self):
        print('base1.f3')
        self.f1()
        print (self)


class Base2:
    def f1(self):
        print('base2.f1')


class Foo(Base1,Base2,Base3,Base4):
    def f0(self):
        print('foo.f0')
        self.f3()

obj = Foo()
print (Foo.mro()[0])
obj.f0()
# foo.f0  base1.f3  base1.f1  为什么打印的是Base1的而不是Base2的呢？因为
#C3算法中父类不继承的就是按照子类继承父类的顺序来执行。
```

```python
# 看代码写结果：
class Parent:
    x = 1

class Child1 (Parent):
    pass

class Child2(Parent):
    pass


print(Parent.x,Child1.x,Child2.x)
#1 1 1
Child2.x = 2
print(Parent.x,Child1.x,Child2.x)
#1 1 2
Child1.x = 3
print(Parent.x,Child1.x,Child2.x)
#1 3 2
```

```python
# 有如下类：
class A:
    pass

class B(A):
    pass

class C(A):
    pass

class D(A):
    pass

class E(B,C):
    pass

class F(C,D):
    pass

class G(D):
    pass

class H(E,F):
    pass

class I(F,G):
    pass

class K(H,I):
    pass

#新式类：过程
print (K.mro())
```

