---
title: 第二十讲——面向对象 初识
id: 20
date: 2019-8-8 20:00:00
tags: Python
comment: true
---

### 学习大纲

- 面向对象编程初始
- 进阶版日志
- 练习

<!-----more----->

### 面向对象编程（OOP）初始

- 面向过程式编程：就是没有使用函数，就是一步步的往下走的那种。（len()的实现）
- 面向函数式编程（FP）：封装重复的代码。（len()的实现，封装），相比较面向过程式编程：节俭了代码同时增强了代码的可读性。
- 面向对象编程，是一种封装代码的方法。代码的封装，其I是就是隐藏实现功能的具体代码，仅留给用户使用的接口，这样用户就不知道其内部运行的原理。

**面向对象初步了解**

```python
面向函数式编程
def login():
	pass
def register():
	pass
def chang_pwd():
	pass
def shopping_car():
	pass
def check_paid_goods():
	pass
def check_unpaid_goods():
	pass
面向对象式编程
class Auth:
	def login(self):
		pass
	def register(self):
		pass
	def chang_pwd(self):
		pass
class Shoping:
	def shopping_car(self):
		pass
	def check_paid_goods(self):
		pass
	def check_unpaid_goods(self):
		pass
#我们可以发现上面的6个函数，前面的3个是和用户的操作相关的，可以分为一类，后面的
#3个函数适合购物相关的，是可以分为一类的。
```

总结一：面向对象的第一个特点：对相似功能的函数，同一业务逻辑下的函数进行分类。

下面我们需要有这样的一个思想：学习面向对象必须站在一个上帝的角度去分析问题（就是要有大局观）

什么是类什么是对象？

类：就是具有相同属性和功能的一类事物（这句话就把类的结构说出来了，属性和功能）

对象：某个类的具体实现

```python
举个栗子：乌龟是个类，具体的龟就是一个对象
我们设计一个游戏，设计一个乌龟的角色，那么怎么定义和实现呢？我们将从下面的两个方面去设计：
从表面的特征来描述：绿色的，有4条腿，重10kg，有外壳等等（属性.名词）
从所具有的行为来描述：它会爬，会吃饭，会睡觉等等(行为.动词)
```

总结二：面向对象的第二个特点：我们需要站在上帝的角度构建代码，类就是一个公共的模板，对象就是从实例化出来的，**得到对象就得到了一切**（得到对象就得到了一切。这一句话就是类的核心）。

**面向对象的结构**

```python
面向对象的结构
类名的构建:
1,驼峰状的
2,具有意义
class Human:
	"""
	类的具体构造
	"""
	#第一部分
	#类的属性  （也叫做静态属性，静态字段，比较老了）
	main = "有思想"
	langage = "使用语言"

	#第二部分
	#动态方法
	def work(self):
		print ("人类都会工作。")
	def eat(self):
		print ("人类都需要吃饭。")
```

**从类名的角度研究类**

```python
 从类名的角度研究类
# 	类名操作类中的属性
# 		类名查看类中所有的内容
# 		print (Human.__dict__)
		# 类名操作类中的静态属性  万能的 .
		# 	#增
		# 	Human.body = "有头和四肢"
		# 	print (Human.__dict__)
		# 	#删
		# 	del Human.main
		# 	print (Human.__dict__)
		# 	#改
		# 	Human.body = "有头发"
		# 	#查
		# 	print (Human.body)
	# 类名调用类中的方法
	# 	Human.work(self)
```

总结：一般类名就是操作类中的属性

**从对象角度研究类**

- ```python
  obj = Human() #实例化对象
  #得到一个返回值，这个返回值就是对象（实例）
  print (obj)
  #>>><__main__.Human object at 0x000001980CB16390>
  
  现在我们分析分析上面实例化的操作都干了什么：
  实际上，实例化一个对象一共发生了3件事情
  """
  1,开辟一个对象空间（就是obj地址指向的空间）。
  2,自动化执行__init__(self)方法,并将对象地址传递给self
  3,运行__init__()方法内的代码给对象空间封装属性
  """
  解释上面的3个步骤:
      首先在内存中开启一个空间，空间的名字就是Human，这个空间里面就是属性变量和值以及方法名与地址的对应关系表；然后实例化的时候，我们就产生了一个obj的空间，刚开始里面是空的，然后就执行到__init__这个特殊的方法，然后self就和obj进行了绑定，这样这个对象就都是类里所有方法的参数（self），我们就可以利用它对类里面所有的东西进行操作。（所以说，得到了对象就是得到了一切。）
  我们看看这个实例化对象之后能做一些什么事情：
  基本操作
  class Human:
  	"""
  	"""
  	#类的属性  （也叫做静态属性，静态字段，比较老了）
  	mind = "有思想"
  	language = "使用语言"
  
  	def __init__(self,name,age):
  		self.name = name
  		self.age = age
  
  	#动态方法
  	def work(self): #def work(obj)
  		print ("人类都会工作。")
  	def eat(self): ##def eat(obj)
  		print ("人类都需要吃饭。")
  obj = Huamn("pl",23)  #self.name = pl  self.age=23
  obj.name  #pl
  obj.age #23
  
  对象操作对象空间的属性：
  obj = Human("pl",23)
  # 	print (obj.__dict__)
  # 	#--对象操作对象空间的属性
  # 	obj = Human("pl",23)
  # 	#增
  # 	obj.sex = "男"
  # 	#删
  # 	del obj.sex
  # 	#改
  # 	obj.age = 22
  # 	#查
  # 	print (obj.age)
  
  对像查看类中的属性
  # 	obj = Human("pl",23)
  # 	print (obj.mind)  #只可查看类里面的属性不能修改
  # #对象调用类中的方法
  # 	obj = Human("pl",23)
  # 	obj.work() #隐性传参>>>类方法里面的self都是obj的内存地址
  # #Self本身来说就是类中方法的第一个位置参数，他会自动接收对象内存地址
  
  一个类可以实例化多个对象
  # obj1 = Human('pl1',1)
  # obj2 = Human('pl2',2)
  # obj3 = Human('pl3',3)
  
  补充：注意的地方。# 对象只能查看类中不可变的数据类型的属性，如果类的属性是可变的，可以通过实例修改类的属性。
  
  ```

### 进阶版日志

请看详细版本的：https://blog.csdn.net/qq_40890660/article/details/98482170

```python
日志的分类：
#--系统日志：记录操作系统、服务器的硬件性能（cpu，网卡，内存运行等）将获得的
	#数据以文件的形式保存在文件里面(一般是运维人员来做的)，记录运维人员的命令。
#--网站日志：用户的访问次数，用户的停留时间，访问量
	#各地区的访问量等等（开发用的多）
#--开发辅助日志：debug，info模式，代替print
	#try except下面的日志记录
#用户信息日志：记录用户的转账，流水等用户对系统的操作。
"""
logging配置
"""
import os
import logging.config
# 定义三种日志输出格式 开始

standard_format = '[%(asctime)s][%(threadName)s:%(thread)d][task_id:%(name)s][%(filename)s:%(lineno)d]' \
                  '[%(levelname)s][%(message)s]' #其中name为getlogger指定的名字

simple_format = '在 %(asctime)s %(message)s'

id_simple_format = '[%(levelname)s][%(asctime)s] %(message)s'


# log文件的全路径
logfile_path = 'all2.log'

# log配置字典
LOGGING_DIC = {
    'version': 1,
    'disable_existing_loggers': False,
    'formatters': {
        'standard': {
            'format': standard_format
        },
        'simple': {
            'format': simple_format
        },
    },
    'filters': {},
    'handlers': {
        #打印到终端的日志
        'stream': {
            'level': 'DEBUG',
            'class': 'logging.StreamHandler',  # 打印到屏幕
            'formatter': 'simple'
        },
        #打印到文件的日志,收集info及以上的日志
        'file': {
            'level': 'DEBUG',
            'class': 'logging.handlers.RotatingFileHandler',  # 保存到文件
            'formatter': 'standard',
            'filename': None,  # 日志文件
            'maxBytes': 1024*1024*1024,  # 日志大小 5M
            'backupCount': 5,
            'encoding': 'utf-8',  # 日志文件的编码，再也不用担心中文log乱码了
        },
    },
    'loggers': {
        #logging.getLogger(__name__)拿到的logger配置
        '': {
            'handlers': ['stream', 'file'],  # 这里把上面定义的两个handler都加上，即log数据既写入文件又打印到屏幕
            'level': 'DEBUG',
            'propagate': True,  # 向上（更高level的logger）传递
        },
    },
}


def get_logger():
    path = r'F:\s24\day21\liye.log'
    LOGGING_DIC['handlers']['file']['filename'] = path
    logging.config.dictConfig(LOGGING_DIC)  # 导入上面定义的logging配置
    logger = logging.getLogger(__name__)  # 生成一个log实例
    return logger



def save():
    logger = get_logger()
    logger.info(f'{} 存入300元')  # 记录该文件的运行状态

save()
```

### 练习

```python
# 作业：
# 完成下列功能:
# 1. 创建一个人类Person,再类中创建3个静态变量(静态字段)
#        animal = '高级动物'
#        soul = '有灵魂'
#        language = '语言'
# 2. 在类中定义三个方法,吃饭,睡觉,工作.
# 3. 在此类中的__init__方法中,给对象封装5个属性:国家,姓名,性别,年龄,  身高.
# 4. 实例化四个人类对象:
#        第一个人类对象p1属性为:中国,alex,未知,42,175.
#        第二个人类对象p2属性为:美国,武大,男,35,160.
#        第三个人类对象p3属性为:你自己定义.
#        第四个人类对象p4属性为:p1的国籍,p2的名字,p3的性别,p2的年龄,p3  的身高.
# 5. 通过p1对象执行吃饭方法,方法里面打印:alex在吃饭.
# 6. 通过p2对象执行吃饭方法,方法里面打印:武大在吃饭.
# 7. 通过p3对象执行吃饭方法,方法里面打印:(p3对象自己的名字)在吃饭.
# 8. 通过p1对象找到Person的静态变量 animal
# 9. 通过p2对象找到Person的静态变量 soul
# 10. 通过p3对象找到Person的静态变量 language

# class Person:
# 	animal = '高级动物'
# 	soul = '有灵魂'
# 	language = '语言'
#
# 	def __init__(self,country,name,sex,age,height):
# 		self.country = country
# 		self.name = name
# 		self.sex = sex
# 		self.age = age
# 		self.height = height
#
# 	def eat(self):
# 		print (f'{self.name}在吃饭')
# 	def work(self):
# 		print(f'{self.name}在吃饭')
# 	def sleep(self):
# 		print(f'{self.name}在吃饭')
#
# p1 = Person('中国','alex','未知',42,175)
# p2 = Person('美国','武大','男',35,160)
# p3 = Person("china","pl","男",23,172)
# p4 = Person('中国','武大','男',35,172)
# p1.eat()
# p2.eat()
# p3.eat()
# print (p1.animal)
# print (p2.soul)
# print (p3.language)
```

```python
# 通过自己创建类,实例化对象
# 在终端输出如下信息
# 小明，10岁，男，上山去砍柴
# 小明，10岁，男，开车去东北
# 小明，10岁，男，最爱大保健
# 老李，90岁，男，上山去砍柴
# 老李，90岁，男，开车去东北
# 老李，90岁，男，最爱大保健
# 老张…

class Person:
	def __init__(self,name,age,sex,):
		self.name = name
		self.age = age
		self.sex = sex

	def chop_wood(self):
		print (f'{self.name},{self.age},{self.sex}上山砍柴')
	def drive_car(self):
		print(f'{self.name},{self.age},{self.sex}开车去东北')
	def Healthcare(self):
		print(f'{self.name},{self.age},{self.sex}最爱大保健')

p1 = Person('小明',"10岁",'男')
p1.chop_wood()
p1.drive_car()
p1.Healthcare()
p2 = Person('老李',"90岁",'男')
p2.chop_wood()
p2.drive_car()
p2.Healthcare()
```

```python
class Car:
	power = "动力驱动"
	wheel = "具有四个或以上车轮"
	function = "主要用途载运人员或货物"

	def __init__(self,color,license_plate,type):
		self.color = color
		self.license_plate = license_plate
		self.type = type

	def fun(self):
		pass
	def transfer(self):
		pass
p1 = Car("red","88888","货车")
```

```python
# 模拟英雄联盟写一个游戏人物的类（升级题）.
# 要求:
#
# 1. 创建一个 Game_role的类.
# 2. 构造方法中给对象封装name,ad(攻击力),hp(血量).三个属性.
# 3. 创建一个attack方法,此方法是实例化两个对象,互相攻击的功能:
#        例: 实例化一个对象 盖伦,ad为10, hp为100
#        实例化另个一个对象 剑豪 ad为20, hp为80
#        盖伦通过attack方法攻击剑豪,此方法要完成 '谁攻击谁,谁掉了多少血,  还剩多少血'的提示功能.
class GameRole:
	count = 1
	def __init__(self,name,ad,hp):
		self.name = name
		self.ad = ad
		self.hp = hp

	def attack(self):
		if self.name == "盖伦":
			print (f"{self.name}攻击压缩,压缩掉了10血,还剩{self.hp}血")
		else:
			print(f"{self.name}攻击盖伦,盖伦掉了20血,还剩{self.hp}血")
count = 1
galen = GameRole("盖伦",10,100)
sword_hero = GameRole("剑豪",20,80)
while True:
	hp1 = 100 - count*20
	hp2 = 80 - count*10
	if galen.hp > 0 and sword_hero.hp > 0:
		count += 1
		sword_hero.hp = hp1
		galen.hp = hp2
		galen.attack()
		sword_hero.attack()
	else:
		break
```