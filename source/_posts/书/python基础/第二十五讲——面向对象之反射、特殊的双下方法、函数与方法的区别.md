---
title: 第二十五讲——面向对象之反射、特殊的双下方法、函数与方法的区别
id: 25
date: 2019-8-13 20:00:00
tags: Python
comment: true
---

### 学习大纲

- 反射
- 特殊的双下方法
- 函数与方法的区别

<!-----more----->

### 反射

**什么是反射？**

- 通过字符换去操作对象的一种方式。这也是程序对自己内部代码的一种自省方式。

**反射的使用范围**

- 实例对像
- 类       ***
- 本模块内部
- 其他模块    ***

**使用的4个内置函数**

- hasattr  ***
- getattr   ***
- setattr
- delattr

**从四个方面分析反射**

一、总计人从实例对象的角度分析反射

```python
class A:
	country = "中国"

	def __init__(self,name,age):
		self.name = name
		self.age = age

	def func(self):
		print ("in A func")

obj = A("pl",18)
#hasattr判断是否含有某属性
print (hasattr(obj,"name"))
print (hasattr(obj,"country"))
print (hasattr(obj,"func"))
#getattr获取属性
print (getattr(obj,"name"))
print (getattr(obj,"country"))
print (getattr(obj,"func"))
getattr(obj,"sex",None)
#第三个参数是默认值，如果obj中没有该属性返回None。getattr的第三个参数是默认参数。

#setattr和delattr：设置和删除属性
setattr(obj,"name"，"pl1")
print (obj.name)
#pl1
delattr(obj,"name")
print (obj.__dict__)
#{'age': 18}
#对类的反射
#对当前模块的反射
#对其他模块的反射
```

二、从类的角度分析反射

```python
# 从类的角度分析反射
class A:
	country = "中国"

	def __init__(self,name,age):
		self.name = name
		self.age = age

	def func(self):
		print ("in A func")

#hasattr
print (hasattr(A,"country"))
print (hasattr(A,"func"))
#getattr
g = getattr(A,"func")
g("随意参数")
# 实际应用
if hasattr(A,"country"):
	print (getattr(A,"country"))
if hasattr(A,"func"):
	obj = A("pl",18)
	getattr(A,"func")("随意参数")
```

三、从其他的模块分析反射

```python
#从当前模块研究反射
a = "666"
def func():
	print ("in func1")

class A:
	b = "888"

	def __init__(self,name):
		self.name =name

	def func(self):
		print ("in A func")

import sys
print (sys.modules[__name__])  #获取当前模块的名称
print (getattr(sys.modules[__name__],'a'))
getattr(sys.modules[__name__],'func')()
print (getattr(sys.modules[__name__],'A'))#取得类模块
print (getattr(sys.modules[__name__].A,'b'))#取得类模块里面的属性
print (getattr(sys.modules[__name__].A,'func'))#取得类里面的方法
```

四、从当前模块分析反射

```python
#_26_test.py
#__*__coding:utf-8__*__
name = 'pl'

def func():
    print('in tbjx func')


class C:
    area = '北京'

    def __init__(self,name):
        self.name = name

    def func(self):
        print('in B func')
```

```python
# 从其他模块的角度研究反射（26_test.py)
import _26_test
#取全局属性
if hasattr(_26_test,"name"):
	print (getattr(_26_test,"name"))
	#pl
#取函数
if hasattr(_26_test,"func"):
	getattr(_26_test,"func")()
	#in tbjx func
#取类
if hasattr(_26_test,"C"):
	g = getattr(_26_test,"C")
	#方法一
	obj = g("pl")  #实例化类的对象
	print (obj.area)  #取得类的属性
	if hasattr(obj,"name"):
		print (getattr(obj,"name")) #取得实例化对象的属性
	#方法二
	print (getattr(_26_test,"C"))
	print(getattr(_26_test.C, "area"))
	obj = getattr(_26_test,"C")('pl')
	print(getattr(obj,"name"))
```

### 特殊的双下方法

**____new____**

```python
#__new__
# 构造方法
# 功能：new一个对象，就是我们实例化对象的时候的操作。

class A:
	def __init__(self):
		self.x = 1
		print ('in init function')

	def __new__(cls, *args, **kwargs):
		print ("in new function")
		#继承object类的__new__()
		return object.__new__(A,*args,**kwargs)
a = A()
print (a.x)
# in new function
# in init function
# 1
#流程：首先触发object类的__new__方法，次方法在内存中开辟了一个对象空间
	   # 然后执行__init__方法，给对象封装属性

    
# __new__进阶：单例模式（非常的重要）
"""
什么是单例模式？
单例模式是一种常用的软件设计模式，在它的核心结构中只包含了一个被称为单例类的特殊类。
通过单例模式可以保证系统中一个类只有一个实例而且该实例易于外界访问。从而方便对实例个数的控制并
节约系统的资源。如果希望系统中某个类的对象只能存在一个，单例模式是最好解决方案。
"""
class A:
	__instance = None

	def __init__(self, name: object) -> object:
		self.name =name

	def __new__(cls, *args, **kwargs):
		if not cls.__instance:
			cls.__instance = object.__new__(cls)
		return cls.__instance
obj = A("pl")
print (id(obj))
#2601595677496
obj1 = A("pl1")
print (id(obj1))
#2601595677496
obj2 = A("pl2")
print (id(obj2))
#2601595677496
```

```
单例模式
【采用单例模式动机、原因】
对于系统中的某些类来说，只有一个实例很重要，例如，一个系统中可以存在多个打印任务，但是只能有一个正在工作的任务；一个系统只能有一个窗口管理器或文件系统；一个系统只能有一个计时工具或ID(序号)生成器。如在Windows中就只能打开一个任务管理器。如果不使用机制对窗口对象进行唯一化，将弹出多个窗口，如果这些窗口显示的内容完全一致，则是重复对象，浪费内存资源；如果这些窗口显示的内容不一致，则意味着在某一瞬间系统有多个状态，与实际不符，也会给用户带来误解，不知道哪一个才是真实的状态。因此有时确保系统中某个对象的唯一性即一个类只能有一个实例非常重要。
如何保证一个类只有一个实例并且这个实例易于被访问呢？定义一个全局变量可以确保对象随时都可以被访问，但不能防止我们实例化多个对象。一个更好的解决办法是让类自身负责保存它的唯一实例。这个类可以保证没有其他实例被创建，并且它可以提供一个访问该实例的方法。这就是单例模式的模式动机。
【单例模式优缺点】
【优点】
一、实例控制
单例模式会阻止其他对象实例化其自己的单例对象的副本，从而确保所有对象都访问唯一实例。
二、灵活性
因为类控制了实例化过程，所以类可以灵活更改实例化过程。
【缺点】
一、开销
虽然数量很少，但如果每次对象请求引用时都要检查是否存在类的实例，将仍然需要一些开销。可以通过使用静态初始化解决此问题。
二、可能的开发混淆
使用单例对象（尤其在类库中定义的对象）时，开发人员必须记住自己不能使用new关键字实例化对象。因为可能无法访问库源代码，因此应用程序开发人员可能会意外发现自己无法直接实例化此类。
三、对象生存期
不能解决删除单个对象的问题。在提供内存管理的语言中（例如基于.NET Framework的语言），只有单例类能够导致实例被取消分配，因为它包含对该实例的私有引用。在某些语言中（如 C++），其他类可以删除对象实例，但这样会导致单例类中出现悬浮引用
```

**____call____**

```python
#__call__（重要）
# 功能：构造方法__new__的执行是由创建对象触发的，也就是 对象=类名()
# 但是对于__call__方法的执行是由对象后加()触发的。即：对象()或类名()()
class Foo:
	def __init__(self):
		pass
	def __call__(self, *args, **kwargs):
		print ("__call__")

obj = Foo()  #执行__init__
obj()    #执行__call__
#__call__
```

**____len____**

```python
#__len__
class B:
	def __init__(self):
		self.a = 1
		self.b = 2

	def __len__(self):
		return len(self.__dict__)

a = B()  #a是实例化对象，现在它的里面有两个属性，a和b
print(len(a))  #调用__len__，返回a对象里面属性的个数
#2
```

**____hash____**

```python
#__hash__
class B:
	def __init__(self):
		self.a = 1
		self.b = 2

	def __hash__(self):
		return hash(str(self.a) + str(self.b))
a = B()
print (hash(a))
#9083472802315503267 哈希值
```

**____str____**

```python
#__str__
#功能：如果一个类中定义了__str__方法，那么打印对象时，默认输出该方法的返回值。
class A:
	def __init__(self):
		pass

	def __str__(self):
		return "pl"

a = A()
print(a)
#pl
```

**____repr____**

```python
#__repr__
#功能：如果一个类中类定义了__repr__方法，那么在repr（对象）时，默认输出该方法的返回值
class A:
	def __str__(self):
		pass
	def __repr__(self):
		return "pl"
a = A()
print (repr(a))
#pl

```

**____eq____**

```python
#__eq__
#重载符号==
class A:
	def __init__(self):
		self.a = 1
		self.b = 2
	def __eq__(self, other):
		if self.a == other.a and self.b == other.b:
			return True

a = A()
b = A()
print (a == b)
#True
```

**____del____**

```
析构方法，当对戏那个在内存中被释放时，自动触发执行。
注：此方法一般无须定义，因为Python是一门高级语言，程序员在使用时无需关心内存的分配和释放，因为此工作都是交给Python解释器来执行，所以，析构函数的调用是由解释器在进行垃圾回收时自动触发执行的。
```

**____item____ **   系列和  ____delattr____（4个）

```python
#__item__系列（__getitem__,__setitem__,__delitem__）
#功能：对对象做类似于字典的操作。
class Foo:
	def __init__(self,name):
		self.name = name

	def __getitem__(self, item):
		print(self.__dict__[item])

	#字典的增，改
	def __setitem__(self, key, value):
		self.__dict__[key] = value

	def __delitem__(self, key):
		print ("del obj[key]时，我执行")
		self.__dict__.pop(key)
	def __delattr__(self, item):
		print ("del obj.key时，我执行")
		self.__dict__.pop(item)
f1 = Foo("pl")
f1["age"] = 18 #字典的增
# f1["age1"] = 20
# del f1.age1 #字典的删
# del f1["age1"]
# f1["name"] = "lp"c#字典的改
print (f1.__dict__)
```

**上下文管理(____enter____和____exit____)**

```python
#with语句类似于
try:
except:
finally:
    但是with语句更加简洁。而且安全。代码量少。
    
    
#with上下文管理(__enter__,__exit__)
#功能：实例化的第二种方法with obj as f: 必须基于__enter__和__exit__方法
class A:
	def __init__(self,text):
		print("每次我都是第一个执行，因为我在实例化的时候就操作了")
	def foo(self):
        print ("foo")
        
	def __enter__(self):  #开启上下文管理器对象时触发此方法	
        print("进入")
        #return self   #返回对象绑定f1
		
	def __exit__(self, exc_type, exc_val, exc_tb): #执行完上下文管理器对象f1时触发此方法
        print("退出")
		

with A("pl") as f1:
	print (f1.type(f1))
    #f1.foo()
情况1
'''
return self的情况下：
每次我都是第一个执行，因为我在实例化的时候就操作了
进入
<__main__.A object at 0x000001DFD3EB63C8> <class '__main__.A'>
退出
'''
情况2
'''
return self注掉的情况下：
每次我都是第一个执行，因为我在实例化的时候就操作了
进入
None <class 'NoneType'>
退出
'''
情况3
'''
有return self的情况下，在with下面执行f1.foo()：
每次我都是第一个执行，因为我在实例化的时候就操作了
进入
<__main__.A object at 0x00000198700F6860> <class '__main__.A'>
foo
退出
'''
情况4
'''
在没有return self的情况下执行with下面恶f1.foo()：
报错。
'''
```

**____iter____**

```python
#__iter__
#功能：将不可迭代的对象变成可迭代对象
class A:
	def __init__(self,num):
		self.num = num

	def __iter__(self):
		for i in self.num:
			yield i


f = A("plp")
for i in f:
	print (i)
#p
#l
#p
```

**总结：**

| 双下方法    | 调用方式               | 功能                                                         |
| ----------- | ---------------------- | ------------------------------------------------------------ |
| __len__     | print (len(obj))       | 定义当被 len() 调用时的行为                                  |
| __repr__    | print(repr(obj))       | 定义当被 repr() 调用时的行为                                 |
| __hash__    | print(hash(obj))       | 定义当被 hash() 调用时的行为                                 |
| __str__     | print(obj)             | 定义当被 str() 调用时的行为                                  |
| __new__     | obj.属性               | 1. **new** 是在一个对象实例化的时候所调用的第一个方法 2. 它的第一个参数是这个类，其他的参数是用来直接传递给 **init** 方法 3. **new** 决定是否要使用该 **init** 方法，因为 **new** 可以调用其他类的构造方法或者直接返回别的实例对象来作为本类的实例，如果 **new** 没有返回实例对象，则 **init** 不会被调用 4. **new** 主要是用于继承一个不可变的类型比如一个 tuple 或者 string |
| __call__    | obj()                  | 允许一个类的实例像函数一样被调用                             |
| __eq__      | obj a == obj b         | 定义等于号的行为：x == y                                     |
| __del__     | 自动销毁               | 析构器，当一个实例被销毁的时候调用的方法                     |
| __getitem__ | obj[key]               | 定义获取容器中指定元素的行为，相当于 self[key]               |
| __setitem__ | obj[key] =value        | 定义设置容器中指定元素的行为，相当于 self[key] = value,相当于 del self[key] |
| __delitem__ | del obj[key]           | 定义删除容器中指定元素的行为                                 |
| __delattr__ | del obj.key            | 定义当一个属性被删除时的行为                                 |
| __enter__   | 上下文管理器进入       | 1. 定义当使用 with 语句时的初始化行为 2. **enter** 的返回值被 with 语句的目标或者 as 后的名字绑定 |
| __exit__    | 上下文管理器退出       | 1. 定义当一个代码块被执行或者终止后上下文管理器应该做什么 2. 一般被用来处理异常，清除工作或者做一些代码块执行完毕之后的日常工作 |
| __iter__    | for i in obj:print (i) | 定义当迭代容器中的元素的行为                                 |
### 函数与方法的区别

**判断函数与方法**

- 通过打印函数（方法名）确定


```python
def func():
    pass

print(func)  
# <function func at 0x00000260A2E690D0>


class A:
    def func(self):
        pass
    
print(A.func)  
# <function A.func at 0x0000026E65AE9C80>
obj = A()
print(obj.func) 
# <bound method A.func of <__main__.A object at 0x00000230BAD4C9E8>>
```

- 通过types模块验证


```python
from types import FunctionType
from types import MethodType

def func():
    pass


class A:
    def func(self):
        pass

obj = A()

print(isinstance(func,FunctionType))  # True
print(isinstance(A.func,FunctionType))  # True
print(isinstance(obj.func,FunctionType))  # False
print(isinstance(obj.func,MethodType))  # True
```

- 静态方法是函数


```python
from types import FunctionType
from types import MethodType

class A:
    
    def func(self):
        pass
    
    @classmethod
    def func1(self):
        pass
    
    @staticmethod
    def func2(self):
        pass
obj = A()

# 静态方法其实是函数
# print(isinstance(A.func2,FunctionType))  # True
# print(isinstance(obj.func2,FunctionType))  # True
```

**总结**

1. 函数式显式传递数据的。就像我们的len()函数，我们需要传递一些要处理的数据。
2. 方法中的数据是隐式传递参数的。
3. 方法可以操作类内部的数据。
4. 方法根对象是关联的。
5. 注：我们在日常生活中会口语化陈谷函数和方法时不严谨，但是我们心中要知道二者之间的区别。在其他的语言中，java中只有方法，c中只有函数等等。

### 相关面试题

```python
class StarkConfig:
    def __init__(self,num):
        self.num = num
    
    def run(self):
        self()
    
    def __call__(self, *args, **kwargs):
        print(self.num)

class RoleConfig(StarkConfig):
    def __call__(self, *args, **kwargs):
        print(345)
    def __getitem__(self, item):
        return self.num[item]

v1 = RoleConfig('alex')
v2 = StarkConfig('太白金星')
# print(v1[1])
# print(v2[2])
v1.run()


class UserInfo:
    pass


class Department:
    pass


class StarkConfig:
    def __init__(self, num):
        self.num = num
    
    def changelist(self, request):
        print(self.num, request)
    
    def run(self):
        self.changelist(999)


class RoleConfig(StarkConfig):
    def changelist(self, request):
        print(666, self.num)


class AdminSite:
    
    def __init__(self):
        self._registry = {}
    
    def register(self, k, v):
        self._registry[k] = v


site = AdminSite()
site.register(UserInfo, StarkConfig)
# 1 
# obj = site._registry[UserInfo]()

# 2
obj = site._registry[UserInfo](100)
obj.run()


class UserInfo:
    pass

class Department:
    pass

class StarkConfig:
    def __init__(self,num):
        self.num = num

    def changelist(self,request):
        print(self.num,request)

    def run(self):
        self.changelist(999)

class RoleConfig(StarkConfig):
    def changelist(self,request):
        print(666,self.num)


class AdminSite:

    def __init__(self):
        self._registry = {}

    def register(self,k,v):
        self._registry[k] = v(k)

site = AdminSite()
site.register(UserInfo,StarkConfig)
site.register(Department,RoleConfig)

for k,row in site._registry.items():
    row.run()


class A:
    list_display = []
    
    def get_list(self):
        self.list_display.insert(0,33)
        return self.list_display

s1 = A()
print(s1.get_list())


class A:
    list_display = [1, 2, 3]
    def __init__(self):
        self.list_display = []
    def get_list(self):
        self.list_display.insert(0, 33)
        return self.list_display


s1 = A()
print(s1.get_list())


class A:
    list_display = []

    def get_list(self):
        self.list_display.insert(0,33)
        return self.list_display

class B(A):
    list_display = [11,22]


s1 = A()
s2 = B()
print(s1.get_list())
print(s2.get_list())
```

