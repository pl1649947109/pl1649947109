---
title: 第十七讲——模块二
id: 17
date: 2019-8-5 20:00:00
tags: Python
comment: true
---

### 学习大纲

- 序列化
- os模块
- sys模块
- hashlib模块
- connections模块
- 具体模块内容见blog：https://blog.csdn.net/qq_40890660/article/details/98214433

<!-----more----->

### 序列化

```python
import json
import pickle
#序列化与反序列化(2组4个方法）
#dumps：将对象序列化（转换成）字符串
#loads：将字符串反序列化成对象本身
	# lst = [1,2,55,6,3,32345,45,45]
	# lst1 = json.dumps(lst)
	# print (lst1,type(lst1))
	# lst2 = json.loads(lst1)
	# print (lst2,type(lst2))
	# #[1, 2, 55, 6, 3, 32345, 45, 45] <class 'str'>
	# #[1, 2, 55, 6, 3, 32345, 45, 45] <class 'list'>
	# dic = {"1":"中国","2":22,"3":3}
	# dic1 = json.dumps(dic)
	# print (dic1,type(dic1))
	# #关闭ascll码,不然中文转不了
	# dic1_1 = json.dumps(dic,ensure_ascii=False)
	# print(dic1_1, type(dic1_1))
	# dic2 = json.loads(dic1)
	# print (dic2,type(dic2))
	# #{"1": "\u4e2d\u56fd", "2": 22, "3": 3} <class 'str'>
	# #{"1": "中国", "2": 22, "3": 3} <class 'str'>
	# #{'1': '中国', '2': 22, '3': 3} <class 'dict'>

#dump和load（操作文件）
#dump:将对象序列化（转换成）字符串类型
	#load：将文件中的
	# lst = [1,2,5,23,6,555,56,4,64,15,4,'asd','中文']
	# dic = {"1":"中国","2":22,"3":3}
	# f = open('info','w',encoding='utf-8')
	# # json.dump(lst,f,ensure_ascii=False)
	# json.dump(dic, f, ensure_ascii=False)
	# f.close()
#load:将字符串类型反序列化成对象
	# f1 = open('info','r',encoding='utf-8')
	# # lst1 = json.load(f1)
	# #只能是一行数据
	# # dic1 = json.load(f1)
	# #当数据是多行的时候，这么处理
	# for  i in f1:
	# 	dic1 = json.loads(i)
	# 	print(dic1)
	# f1.close()
	# # print (lst)

#pickle：序列化（pytohn所有对象进行转换）--python自带的，只有python自己可以用
#也是两组4个方法（dumps/loads/dump/load）用法和json一样，不过支持python的所有的数据类型
#dumps和loads
	#列表，字符串
	# lst = [1,2,46,13,"ss",'中国']
	# lst1 = pickle.dumps(lst)
	# print (lst1,type(lst1))
	# #b'\x80\x03]q\x00(K\x01K\x02K.K\rX\x02\x00\x00\x00ssq\x01X\x06\x00\x00\x00\xe4\xb8\xad\xe5\x9b\xbdq\x02e.' <class 'bytes'>
	# print (pickle.loads(lst1))
	#字典
	# dic = {"user":"郭宝元"}
    # t_list = pickle.dumps(dic) # 转换成类似字节
    # print(t_list)
    # print(pickle.loads(t_list))
	#函数
    # def func():
    #     print(111)

    # import json
    # fun = json.dumps(func)
    # print(fun)

	# fun = pickle.dumps(func)
    # print(fun)
    # pickle.loads(fun)()
#dump和load
	# dic = {"usern":"baoyuian"}
	# dic = {"usern":"宝元"}
	# pickle.dump(dic,open("info","wb"))
	# print(pickle.load(open("info","rb")))

	# import pickle
	# dic = {"user":"123"}
	# pickle.dump(dic,open("info","ab"))

	# import pickle
	# dic = {"1":2}
	# f = open("info","wb")
	# s = "\n".encode("utf-8")
	# f.write(pickle.dumps(dic)+ s)
	# f.write(pickle.dumps(dic)+ s)
	# f.write(pickle.dumps(dic)+ s)
	# f.close()

	# f1 = open("info","rb")
	# for i in f1:
	#     print(pickle.loads(i))
#总结：推荐使用json（因为json在各种语言中是通用的）
```

### os模块

```python
import os
#os（4组）
	#工作目录
	# print (os.getcwd()) #查看当前路径  ***
	#C:\Users\pl\PycharmProjects\北京培训笔记\笔记作业
	# os.chdir("path")  #切换路径
	# print(os.curdir)    #.
	# print(os.pardir)    #..
	#文件夹
	# os.mkdir("文件路径") #创建文件夹    ***
	# os.rmdir("文件路径") #删除文件夹    ***
	# os.makedirs("tt/ss/nn")  #递归创建文件夹，就是文件夹的嵌套    ***
	# os.removedirs("tt/ss/nn")  #递归删除文件夹（空的就删掉，不空就停掉）    ***
	# print (os.listdir("F://老师blog"))  #获取当前文件夹下的所有文件名    ***
	#文件
	# os.rename("旧名称","新名称") #修改文件名称    ***
	# os.remove("文件")  #删除文件        ***
	#路径
	# print (os.path.abspath("三国.txt")) #通过相对路径返回绝对路径    ***
	# print(os.path.split(os.path.abspath("三国.txt")))  #返回元组，切最后一个反斜杠
	# C:\Users\pl\PycharmProjects\北京培训笔记\笔记作业\三国.txt
	# ('C:\\Users\\pl\\PycharmProjects\\北京培训笔记\\笔记作业', '三国.txt'
	# print(os.path.dirname(r"C:\Users\pl\PycharmProjects\北京培训笔记\笔记作业\三国.txt") ) #获取文件路径    ***
	# print (os.path.basename("三国.txt")  )#获取文件名
	# print(os.path.exists("F:"))  #判断文件路径是否存在    ***
	# print(os.path.isdir("E:"))  #判断是不是路径    ***
	# print (os.path.isfile("三国.txt")) #判断是不是文件    ***
	# print (os.path.isabs(""))  #判断是不是绝对路径
	# print(os.path.join("F:\\","pl","baba"))  #路径拼接    ****
	# print (os.path.getatime("F:老师blog"))  #返回时间戳，最后的修改时间
	# print(os.path.getsize("文件路径"))  #返回文件的大小，但是不准    ***
```

### sys模块

```python
import sys
#sys  和python解释器交互的接口
	# print (sys.argv)  #返回当前文件的路径  很有用    ***
	# print (sys.exit(1)) #状态码，当程序错误返回的状态码是1,zhineng
	# print (sys.version)  #返回版本号
	# print (sys.path)  #添加自定义模块查找路径，解释器的   ***
	# print(sys.platform) #返回解释器的系统信息    *** 区分操作系统然后进行相关的逻辑操作
```

### hashlib模块

```python
#hashlib（加密和校验）
'''
只要明文相同密文就是相同的
只要明文不相同密文就是不相同的
hash不能进行反逆（不能解密）--md5已经被中国人破解了
'''
#加密：将加密的内容转换成字节
	# md5:32位长
	# sha1:40位长（其他的同理）
	# md5 = hashlib.md5()  #步骤一：初始化
	# #sha1 = hashlib.sha1()
	# # md5.update("pl123".encode('utf-8'))
	# md5.update("pl123".encode('gbk'))  #步骤二:放入内容
	# print (md5.hexdigest())  #步骤三：做转换
	#可见加密编码的方式没关系都是一样的，只要内容是一样的
	#14e44c50482e8c85caf7a481ae581f81
#最常用的是md5，平时加密的时候使用sha1
#多重加密：叫做加盐
#加盐：
	#固定加盐，可以把这个固定的内容改成动态的
	md5 = hashlib.md5("pl".encode('utf-8'))
	md5.update("123456".encode('utf-8'))
	print (md5.hexdigest())
	#动态加盐
	# user = input("username:")
	# pwd = input("password")

	# import hashlib
	# md5 = hashlib.md5(user.encode("utf-8"))
	# md5.update(pwd.encode("utf-8"))
	# print(md5.hexdigest())
#文件的一致性校验
#需求：我们在安装python解释器的时候,在安装python解释器的时候计算本地的md5值是否一致,一致安装,不一致的删除.
	# def file_check(file_path):
	# 	with open(file_path, mode='rb') as f1:
	# 		sha256 = hashlib.md5()
	# 		while 1:
	# 			content = f1.read(1024)
	# 			if content:
	# 				sha256.update(content)
	# 			else:
	# 				return sha256.hexdigest()
	# print(file_check('python-3.6.6-amd64.exe'))
```

### connections模块

```python
'''
在内置数据类型（dict、list、set、tuple）的基础上，collections模块还提供了几个额外的数据类型：Counter、deque、defaultdict、namedtuple和OrderedDict等。
1.namedtuple: 生成可以使用名字来访问元素内容的tuple，命名元组
2.deque: 双端队列，可以快速的从另外一侧追加和推出对象
3.Counter: 计数器，主要用来计数
4.OrderedDict: 有序字典
5.defaultdict: 带有默认值的字典

#namedtuple
我们知道tuple可以表示不变数据，例如，一个点的二维坐标就可以表示成：p = (1, 2)
但是，看到(1, 2)，很难看出这个tuple是用来表示一个坐标的。这时，namedtuple就派上了用场：
from collections import namedtuple
Point = namedtuple('Point', ['x', 'y'])
p = Point(1, 2)
print(p)
结果：Point(x=1, y=2)

类似的，如果要用坐标和半径表示一个圆，也可以用namedtuple定义：
namedtuple('名称', [属性list]):
Circle = namedtuple('Circle', ['x', 'y', 'r'])
deque
使用list存储数据时，按索引访问元素很快，但是插入和删除元素就很慢了，因为list是线性存储，数据量大的时候，插入和删除效率很低。
deque是为了高效实现插入和删除操作的双向列表，适合用于队列和栈：
from collections import deque
q = deque(['a', 'b', 'c'])
q.append('x')
q.appendleft('y')
q
deque(['y', 'a', 'b', 'c', 'x'])
deque除了实现list的append()和pop()外，还支持appendleft()和popleft()，这样就可以非常高效地往头部添加或删除元素。

OrderedDict
使用dict时，Key是无序的。在对dict做迭代时，我们无法确定Key的顺序。
如果要保持Key的顺序，可以用OrderedDict：
from collections import OrderedDict
d = dict([('a', 1), ('b', 2), ('c', 3)]) # 另一种定义字典的方式
print(d)
# 结果:
{'a': 1, 'c': 3, 'b': 2}
od = OrderedDict([('a', 1), ('b', 2), ('c', 3)])
print(od)
# 结果:
OrderedDict([('a', 1), ('b', 2), ('c', 3)])
注意，OrderedDict的Key会按照插入的顺序排列，不是Key本身排序：

>>> od = OrderedDict()
>>> od['z'] = 1
>>> od['y'] = 2
>>> od['x'] = 3
>>> od.keys() # 按照插入的Key的顺序返回
['z', 'y', 'x']

defaultdict
有如下值集合 [11,22,33,44,55,66,77,88,99,90...]，将所有大于 66 的值保存至字典的第一个key中，将小于 66 的值保存至第二个key的值中。
即： {'k1': 大于66 , 'k2': 小于66}
li = [11,22,33,44,55,77,88,99,90]
result = {}
for row in li:
    if row > 66:
        if 'key1' not in result:
            result['key1'] = []
        result['key1'].append(row)
    else:
        if 'key2' not in result:
            result['key2'] = []
        result['key2'].append(row)
print(result)
from collections import defaultdict
values = [11, 22, 33,44,55,66,77,88,99,90]
my_dict = defaultdict(list)
for value in  values:
    if value>66:
        my_dict['k1'].append(value)
    else:
        my_dict['k2'].append(value)
使用dict时，如果引用的Key不存在，就会抛出KeyError。如果希望key不存在时，返回一个默认值，就可以用defaultdict：
from collections import defaultdict
dd = defaultdict(lambda: 'N/A')
dd['key1'] = 'abc'
 # key1存在
print(dd['key1'])
dd['key2'] # key2不存在，返回默认值
print(dd['key2'])

Counter   ***
Counter类的目的是用来跟踪值出现的次数。它是一个无序的容器类型，以字典的键值对形式存储，其中元素作为key，其计数作为value。计数值可以是任意的Interger（包括0和负数）。Counter类和其他语言的bags或multisets很相似。
c = Counter('abcdeabcdabcaba')
print c
输出：Counter({'a': 5, 'b': 4, 'c': 3, 'd': 2, 'e': 1})
'''
```