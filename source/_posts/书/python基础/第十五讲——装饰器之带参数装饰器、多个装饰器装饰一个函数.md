---
title: 第十五讲——装饰器之带参数装饰器、多个装饰器装饰一个函数
id: 15
date: 2019-8-3 20:00:00
tags: Python
comment: true
---

### 今日学习大纲

- 有参数的装饰器
- 多个装饰器装饰一个函数
- 练习

<!-----more----->

### 有参数的装饰器

一、简述：装饰器其实就是一个闭包函数，说的简单一点就是两层函数。有参装饰器的本质就是在装饰器的基础上再套一层函数。

二、@auth(参数)   这个语法糖拆开等价于。

wrapper = auth(choose)   #今天加入的外层函数。

func = wrapper(func)   #回到了昨天的装饰器。

```python
#需求：现在我们需要做登录验证，但是我们有几种登录的方式：分别是qq、微信、抖音。默认不输入选择自动进入邮箱输入验证。现在我们就去实现。
dic_login = {          #1
	"flag":False,
	"username":""
}
def auth(argv):  #2
	def wrapper(f): #5
		def inner(*args,**kwargs): #7
			if dic_login["flag"]: #11
				f(*args,**kwargs) #12
			else: #11
				if argv == "QQ": #12
					print ("欢迎进入qq登录界面：")
					while True:
						username = input("username:")
						password = input("password:")
						if username == "pl" and password
                        == "123":
							f(*args,**kwargs)
							break
						else:
							print ("输入的用户名或密码错误。")
				elif argv == "微信":
					pass
				elif argv == "抖音":
					pass
				else:
					pass
		return inner #8
	return wrapper #6
print("--------登录方式列表---------")
print(format("QQ","^20"))
print(format("微信","^20"))
print(format("抖音","^20"))
print("----------------------------")
login_way = input("请输入你的登录方式：").upper() #3
@auth(login_way)#4
def func(*args,**kwargs): #9
	print ("我只是一个被调用的函数。")
#语法糖拆开
# wrapper = auth(login_way)  #添加的最外层的函数和参数
# func = wrapper(func)   #内层函数，就是昨天学的语法糖的拆开
func() #10
```

### 多个装饰器装饰一个函数

1. 先执行离被装饰的函数最近的语法糖。
2. 进入多层装饰器从上往下走，走到最后一个装饰器执行被装饰函数；然后返回执行语法从下往上走。

```python
def wrapper1(func):
	def inner1(*args,**kwargs):
		print ("这是第一个装饰器开始。")
		func(*args,**kwargs)
		print ("这是第一个装饰器结束")
	return inner1

def wrapper2(func):
	def inner2(*args,**kwargs):
		print ("这是第二个装饰器开始。")
		func(*args,**kwargs)
		print ("这是第二个装饰器结束")
	return inner2

@wrapper1
@wrapper2
def func(*args,**kwargs):
	print ("我只是一个函数啊。")
#两个装饰器的拆开
# func = wrapper2(func) #func=inner2
# func = wrapper1(func) #func=wrapper1(inner2)
func()
#>>>这是第一个装饰器开始。
#>>>这是第二个装饰器开始。
#>>>我只是一个函数啊。
#>>>这是第二个装饰器结束
#>>>这是第一个装饰器结束
```
### 练习

```python
# 1.请实现一个装饰器，限制该函数被调用的频率，如10秒一次（面试题）
def wrapper(f):
	def inner():
		print(time.time())
		time.sleep(10)
		f()
		print(time.time())
	return inner

@wrapper
def func():
	print ("他还只是一个孩纸啊！")

func()

改版：（重要）
def wrapper(f):
	def inner():
		count = 0
		if time.time() - count >= 2:
			count = time.time()
			f()
	return inner

@wrapper
def func():
	print ("他还只是一个孩纸啊！")


while True:
	func()
	time.sleep(2)
	func()
	time.sleep(2)
	func()
这道题的含义是进入程序先不让sleep，而是自己在外面循环里面自己设定。就像游戏里的冷却。不去触发技能就一直等着，知道函数的执行，也就是触发
```

```python
#2.请写出下列代码片段的输出结果：
def say_hi(func):
	def wrapper(*args,**kwargs):
		print("HI")
		ret=func(*args,**kwargs)
		print("BYE")
		return ret
	return wrapper

def say_yo(func):
	def wrapper(*args,**kwargs):
		print("Yo")
		return func(*args,**kwargs)
	return wrapper
@say_hi
@say_yo
def func():
	print("ROCK&ROLL")
func()
#>>>HI Yo ROCK&ROLL BYE
```

```python
# 3.编写装饰器完成下列需求:
# 用户有两套账号密码,一套为京东账号密码，一套为淘宝账号密码分别保存在两个文件中。
# 设置四个函数，分别代表 京东首页，京东超市，淘宝首页，淘宝超市。
# 启动程序后,呈现用户的选项为:
# 1,京东首页
# 2,京东超市
# 3,淘宝首页
# 4,淘宝超市
# 5,退出程序
# 四个函数都加上认证功能，用户可任意选择,用户选择京东超市或者京东首页,只要输入一次京东账号和密码并成功,则这两个函数都可以任意访问;用户选择淘宝超市或者淘宝首页,只要输入一次淘宝账号和密码并成功,则这两个函数都可以任意访问.
# 相关提示：用带参数的装饰器。装饰器内部加入判断，验证不同的账户密码。

print ("1,京东首页\n"
       "2,京东超市\n"
       "3,淘宝首页\n"
       "4,淘宝超市\n"
       "5,退出程序\n")
flag = True
meun = ["京东首页","京东超市","淘宝首页","淘宝超市"]
list_meun = list(enumerate(meun))
while flag:
	def auth(argv,name):
		def wrapper(func):
			def inner():
				print (f"--------欢迎来到{name[-1]}登陆界面--------")
				username = input("username:")
				password = input("password:")
				if argv in [1,2]:
					lst = []
					with open('jingdong','r',encoding='utf-8') as f:
						for i in f:
							lst.append(i.split(":"))
					for i in lst:
						if username == i[0] and password == i[1]:
							func()
						else:
							print ("用户名或密码错误。")
				if argv in [3,4]:
					lst1 = []
					with open('taobao', 'r', encoding='utf-8') as f:
						for i in f:
							lst1.append(i.split(":"))
					for i in lst1:
						if username == i[0] and password == i[1]:
							func()
						else:
							print("用户名或密码错误。")
			return inner
		return wrapper
	while True:
		select = input("请输入选择的序号：")
		if select.isdecimal():
			select = int(select)
			break
		else:
			print ("输入错误，重新输入.")
	@auth(select,list_meun[0])
	def jingdongindex():
		print ("京东首页")

	@auth(select,list_meun[1])
	def jingdongsupermarkat():
		print ("京东超市")

	@auth(select,list_meun[2])
	def taobaoindex():
		print ("淘宝首页")

	@auth(select,list_meun[3])
	def taobaosupermarkat():
		print ("淘宝超市")

	while True:
		if select == 1:
			jingdongindex()
			break
		elif select == 2:
			jingdongsupermarkat()
			break
		elif select == 3:
			taobaoindex()
			break
		elif select == 4:
			taobaosupermarkat()
			break
		elif select == 5:
			flag = False
			break
		else:
			print ("输入的序号有误。")
			break
            
#改版（把两个用户绑定到一起）
print ("1,京东首页\n"
       "2,京东超市\n"
       "3,淘宝首页\n"
       "4,淘宝超市\n"
       "5,退出程序\n")
flag = True
a = False
b = False
meun = ["京东首页","京东超市","淘宝首页","淘宝超市"]
list_meun = list(enumerate(meun))
while flag:
	def auth(argv,name):
		def wrapper(func):
			def inner():
				global a
				global b
				if argv in [3, 4] and b == True:
					func()
					a = False
				if argv in [1, 2] and a == True:
					func()
					b = False
				if argv in [1,2] and a == False:
					print(f"--------欢迎来到{name[-1]}登陆界面--------")
					username = input("username:")
					password = input("password:")
					lst = []
					with open('jingdong','r',encoding='utf-8') as f:
						for i in f:
							lst.append(i.split(":"))
					for i in lst:
						if username == i[0] and password == i[1]:
							a = True
							b = False
							func()
						else:
							print ("用户名或密码错误。")

				if argv in [3,4] and b == False:
					print(f"--------欢迎来到{name[-1]}登陆界面--------")
					username = input("username:")
					password = input("password:")
					lst1 = []
					with open('taobao', 'r', encoding='utf-8') as f:
						for i in f:
							lst1.append(i.split(":"))
					for i in lst1:
						if username == i[0] and password == i[1]:
							b = True
							a = False
							func()
						else:
							print("用户名或密码错误。")
			return inner
		return wrapper
	while True:
		select = input("请输入选择的序号：")
		if select.isdecimal():
			select = int(select)
			break
		else:
			print ("输入错误，重新输入.")
	@auth(select,list_meun[0])
	def jingdongindex():
		print ("京东首页")

	@auth(select,list_meun[1])
	def jingdongsupermarkat():
		print ("京东超市")

	@auth(select,list_meun[2])
	def taobaoindex():
		print ("淘宝首页")

	@auth(select,list_meun[3])
	def taobaosupermarkat():
		print ("淘宝超市")

	while True:
		dic_flag = {1:a,2:a,3:b,4:b}
		if select == 1:
			jingdongindex()
			break
		elif select == 2:
			jingdongsupermarkat()
			break
		elif select == 3:
			taobaoindex()
			break
		elif select == 4:
			taobaosupermarkat()
			break
		elif select == 5:
			flag = False
			break
		else:
			print ("输入的序号有误。")
			break
```

```python
# 4.给l1 = [1,1,2,2,3,3,6,6,5,5,2,2]去重，不能使用set集合（面试题）。
l1 = [1,1,2,2,3,3,6,6,5,5,2,2]
l2 = []
for i in l1:
	if i not in l2:
		l2.append(i)
l1 = l2
print (l1)
```

```python
#5.用递归函数完成斐波那契数列（面试题）：
# 斐波那契数列：1，1，2，3，5，8，13，21..........(第三个数为前两个数的和，
# 但是最开始的1，1是特殊情况，可以单独讨论)

a = b = 1
lst = [1,1]
def func():
	while lst[-1] < int(num):
		a = lst[-1] + lst[-2]
		lst.append(a)
		func()

while True:
	num = input("输入数字：")
	if num.isdecimal():
		if int(num) == 1:
			print([1])
			break
		elif int(num) == 2:
			print ([1,1])
			break
		else:
			func()
			lst.pop()
			print (lst)
			break
	else:
		print ("输入的数字有误，请重新输入。")



lst = [1,1]
def func():
	while lst[-1] < 20000:
		a = lst[-1] + lst[-2]
		lst.append(a)
		func()
```

```python
#6.用户输入序号获取对应的斐波那契数字：比如输入6，返回的结果为8.
while True:
	num = input("输入数字：")
	if num.isdecimal():
		if int(num) == 1:
			print(1)
			break
		elif int(num) == 2:
			print (1)
			break
		else:
			func()
			lst.pop()
			print (lst)
			print (lst[int(num)-1])
			break
	else:
		print ("输入的数字有误，请重新输入。")
```
