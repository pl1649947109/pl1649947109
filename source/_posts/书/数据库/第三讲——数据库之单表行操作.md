---
title: 第三讲——数据库之行的操作
id: 3
date: 2019-9-2 20:00:00
tags: mysql
comment: true
---

### 学习大纲

- 行记录的增删改
- 行记录的查
- 聚合函数补充

### 行记录的增删改

增加insert

```mysql
#增加一个值
insert into 表名（字段） value(值);

#增加好多值
insert into 表名(字段1，字段2，字段3...) values(值1，值2，值3);

#将表2中查出来的数据插入到表1中
insert into 表1(字段1，字段2，字段3...) 
			select (字段1，字段2，字段3) from 表2 
			where ...;
```
<!----more---->
修改update

```mysql
update 表名 set 
		字段1=值，
		字段2=值... 
		where ...;
示例：
    UPDATE mysql.user SET password=password(‘123’) 
        where user=’root’ and host=’localhost’; #这句话是对myslq这个库中的user表中的user字段为'root'并且host字段为'localhost'的这条记录的password字段的数据进行修改，将passord字段的那个数据改为password('123')这个方法对123加工后的密码数据，password()这个方法是mysql提供的密码进行加密用的方法。
        定位到某个记录，并把这个记录中的某项内容更改掉
#注意：执行没有 WHERE 子句的 UPDATE 要慎重，再慎重。
```

删除delete

```mysql
#清空表中所有的数据
方法一：
delete from 表名; #不会重置自增字段
方法二：
truncate 表名;  #自增字段会重置

#删除指定的数据
delete from 表名 where ...
```

### 行记录的查

**单表查询**

关键字的执行优先级（**重点**）

```mysql
from
where分组之前过滤
group by分组
having分组之后过滤
select
distinct去重
order by排序
limit限制显示的记录条数
```

简单查询

```mysql
#四则运算
select 字段*12 from 表名;

自定义表格的格式
select concat("姓名",name,"年薪",月薪字段*12) as 新表名 from 
数据来源表;
```

where约束

```mysql
#比较运算> < != <>(不等于) <= >=
select name from 表名 where post="pl";

#between...and...(这是一个闭区间)
select * from 表名 where id between 10 and 20;

#in（把in里面的对应的全找出来）/not in
select * from 表名 where id in(10,20,30);

#like  通配符_%, 模糊查询
'''
注意：一个_只能匹配一个字符，%可以匹配任意多字符
'''
#以penglin为例
select * from 表名 where name like "peng%";
select * from 表名 where name like "peng_" ; #空结果
select * from 表名 where name like "peng___" #查到penglin

#逻辑运算and or not
select * from 表名 where id>10 and name like "peng%";
select * from 表名 where not id>10;

#is(判断某个字段是否为NULL不能用等号，需要用IS)) /not is
select * from 表名 where 字段名 is null;#如果这个下是空的记录找出来
```

distinct去重

```mysql
去重
select distict 字段 from table_name;
select distinct 字段1,字段2 from table_name;（两个字段都一样）,就相当于host_ip和host_port同时满足。
#我们需要查询某个字段不重复的记录，这是需要使用到它，但实际中我们往往使用distinct来返回不重复字段的条数count(distinct 字段)，原因是distinct只能返回它的目标字段，无法返回其他字段
 select count(distinct age) from employee;
```

group by分组查询

```mysql
'''
首先明确一点，分组是发生在where之后的；分组指的是将所有记录按照某个相同字段进行归类。
为什么要分组？
	是因为我们有时候会需要以组为单位来统计一些数据或者进行一些计算。比如我们取每个部门的最高工资，部门的员工数之类的。
'''
#注意：分组完毕后，，我们只能查查询字段的信息，如果想要查看组内的信息，就需要借助聚合函数。



#需求：统计每个岗位的名称以及最高工资
select post,max(salary) from 表名 group by post;
#注：分组时可以跟多个 条件，那么这多个条件同时重复才算作一组，group by后面条件用逗号分隔
select post,max(salary) from 表名 group by post,id;

ONLY_FULL_GROUP_BY模式
set global sql_mode='ONLY_FULL_GROUP_BY';
如果设置了这个模式,那么select后面只能写group by后面的分组依据字段和聚合函数统计结果

聚合函数
SELECT COUNT(*) FROM employee;  #count是统计个数用的
SELECT COUNT(*) FROM employee WHERE depart_id=1;  #后面跟where条件的意思是统计一下满足depart_id=1这个的所有记录的个数
SELECT MAX(salary) FROM employee;  #max（）统计分组后每组的最大值，这里没有写group by，那么就是统计整个表中所有记录中薪资最大的，薪资的值
SELECT MIN(salary) FROM employee;
SELECT AVG(salary) FROM employee;
SELECT SUM(salary) FROM employee;
SELECT SUM(salary) FROM employee WHERE depart_id=3;

group_concat函数：
单独使用GROUP BY关键字分组
    SELECT post FROM employee GROUP BY post;
    注意：我们按照post字段分组，那么select查询的字段只能是post，想要获取组内的其他相关信息，需要借助函数GROUP BY关键字和GROUP_CONCAT()函数一起使用,比如说我想按部门分组，每个组有哪些员工，都显示出来，怎么搞
    SELECT post,GROUP_CONCAT(name) FROM employee GROUP BY post;#按照岗位分组，并查看组内所有成员名，通过逗号拼接在一起
    SELECT post,GROUP_CONCAT(name,':',salary) as emp_members FROM employee GROUP BY post;
```

HAVING过滤

```mysql
select post,max(salary) from 表名 group by post having max(salary)>2000;
#having过滤后面的条件可以使用聚合函数

#对比having和where：
having和where的语法格式是一模一样的，只不过having是在分组之后进行的进一步的过滤，where不能使用聚合函数，having可以使用分组的字段，无法直接取到其他字段。
```

order by查询排序

```mysql
order by ...（asc）默认升序
order by ... desc降序

select * from employee order by age;
select * from employee order by age asc;
#上面这两种写法都是按照age字段来进行升序排列
select * from employee order by age desc;

#多条件排序
#按照age字段升序,age相同的数据,按照salary降序排列
	select * from employee order by age asc ,salary esc;
#注意：多条件排序首先按照前面的那个条件先排序，排完之后再按照后面的条件
在前面的基础上对其进行排序。反正一行行的数据是不会改变的。
```

limit限制查询的记录数

```mysql
#需求：取出工资最高的前三位
    SELECT * FROM employee ORDER BY salary DESC 
        LIMIT 3;    #默认初始位置为0,从第一条开始顺序取出三条 
    
    SELECT * FROM employee ORDER BY salary DESC
        LIMIT 0,5; #从第0开始，即先查询出第一条，然后包含这一条在内往后查5条 

    SELECT * FROM employee ORDER BY salary DESC
        LIMIT 5,5; #从第5开始，即先查询出第6条，然后包含这一条在内往后查5条
```

regexp使用正则表达式查询

```mysql
#模糊不够正则来凑
SELECT * FROM employee WHERE name REGEXP '^ale';

SELECT * FROM employee WHERE name REGEXP 'on$';

SELECT * FROM employee WHERE name REGEXP 'm{2}';

小结：对字符串匹配的方式
WHERE name = 'egon';
WHERE name LIKE 'yua%';
WHERE name REGEXP 'on$';
```

练习

```mysql
1 查出所有员工的名字，薪资,格式为
<名字:egon> <薪资:3000>
select concat("名字:",name,"薪资：",salary) as new_table from employee;

2 查出所有的岗位（去掉重复）
select distinct post from employee;

3 查出所有员工名字，以及他们的年薪,年薪的字段名为annual_year
select concat("name:",name,"  ","annual_year:",salary *12) as new_table from employee;
 
4. 查看岗位是teacher的员工姓名、年龄
select name,age from employee where post="teacher";

5. 查看岗位是teacher且年龄大于30岁的员工姓名、年龄
select name,age from employee where post="teacher" and age>30;

6. 查看岗位是teacher且薪资在9000-1000范围内的员工姓名、年龄、薪资
select name,age,salary from employee where post="teacher"and salary between 9000.00 and 10000.00;

7. 查询各岗位内包含的员工个数小于2的岗位名、岗位内包含员工名字、个数
select post,GROUP_CONCAT(name),1 from employee group by post having count(post)<2 ;


8. 查询各岗位平均薪资大于10000的岗位名、平均工资
select post,avg(salary) from employee group by post having avg(salary)>10000;

9. 查询各岗位平均薪资大于10000且小于20000的岗位名、平均工资
select post,avg(salary) from employee group by post having avg(salary) between 10000 and 20000;
```

### 聚合函数补充

函数用好了就可以做很多的事情，他们常常结合**having**和**group by**一起使用。

**substring():字符串截取**

**1、从左开始截取字符串** left（str, length） 说明：left（被截取字段，截取长度） 

例：

```
select left(content,200) as abstract from my_content_t 
```

**2、从右开始截取字符串**

```
select right(content,200) as abstract from my_content_t 
```

**3、截取字符串** substring（str, pos） substring（str, pos, length） 说明：substring（被截取字段，从第几位开始截取） substring（被截取字段，从第几位开始截取，截取长度） 

例：

```
select substring(content,5) as abstract from my_content_t 
select substring(content,5,200) as abstract from my_content_t 
```

（注：如果位数是负数 如-5 则是从后倒数位数，到字符串结束或截取的长度） 

 **4、按关键字截取字符串** substring_index（str,delim,count） 说明：substring_index（被截取字段，关键字，关键字出现的次数） 

例：

```
select substring_index("www.w3cschool.cn",".",2) as abstract from wiki_user 
```

**EXTRACT() 函数**用于返回日期/时间的单独部分，比如年、月、日、小时、分钟等等。

**NOW()  CURDATE()  CURTIME()**

| NOW()               | CURDATE()  | CURTIME() |
| :------------------ | :--------- | :-------- |
| 2008-11-11 12:45:34 | 2008-11-11 | 12:45:34  |

**DATEDIFF() **函数返回两个日期之间的天数。

**DATE_SUB() **函数从日期减去指定的时间间隔。

**DATE_ADD()** 函数向日期添加指定的时间间隔。

