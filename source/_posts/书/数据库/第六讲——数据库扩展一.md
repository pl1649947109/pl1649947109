---
title: 第六讲——数据库扩展一
id: 6
date: 2019-9-5 20:00:00
tags: mysql
comment: true
---

### 分页查询方法及优化

**问题**

```mysql
select * from orders_history where type=8 limit 100,100;
select * from orders_history where type=8 limit 1000,100;
select * from orders_history where type=8 limit 10000,100;
select * from orders_history where type=8 limit 100000,100;
select * from orders_history where type=8 limit 1000000,100;
结果：
查询100偏移：25ms 24ms 24ms
查询1000偏移：78ms 76ms 77ms
查询10000偏移：3092ms 3212ms 3128ms
查询100000偏移：3878ms 3812ms 3798ms
查询1000000偏移：14608ms 14062ms 14700ms
```

分析：随着查询的偏移的增大，尤其查询偏移大于100000以后，查询的时间急剧增加。这种分页查询方式会从数据库的第一条记录开始扫描，所以越往后查询速度越慢，而且查询的数据越多，也会拖慢总查询速度。

**解决**

方式一：使用子查询优化

这种方式先定位偏移位置的 id，然后往后查询，这种方式适用于 id 递增的情况。

```mysql
select * from orders_history where type=8 limit 100000,1;

select id from orders_history where type=8 limit 100000,1;

select * from orders_history where type=8 and 
id>=(select id from orders_history where type=8 limit 100000,1) 
limit 100;

select * from orders_history where type=8 limit 100000,100;
结果：
第1条语句：3674ms

第2条语句：1315ms
第3条语句：1327ms

第4条语句：3710ms
分析：
1、比较第1条语句和第2条语句：使用 select id 代替 select * 速度增加了3倍

2、比较第2条语句和第3条语句：速度相差几十毫秒

3、比较第3条语句和第4条语句：得益于 select id 速度增加，第3条语句查询速度增加了3倍

这种方式相较于原始一般的查询方法，将会增快数倍。
```
<!----more---->
方式二：使用id限定优化

```mysql
select * from orders_history where type=2 
and id between 1000000 and 1000100 limit 100;
#查询时间：15ms 12ms 9ms
select * from orders_history where id >= 1000001 limit 100;
```

### **union all和union的区别**

UNION和UNION ALL的功能都是将两个结果集合并为一个，但是这两个关键字不管从使用还是效率上来说，都是有一定区别的。

使用上：

1、对重复结果的处理：UNION在进行表链接后会筛选掉重复的记录，而Union All则不会去除重复记录。

2、对排序的处理：Union将会按照字段的顺序进行排序；UNION ALL只是将两个结果合并后就返回，并不会进行排序处理。

效率上：

从效率上说，UNION ALL的处理效率要比UNION高很多，所以，如果可以确认合并的两个结果集中，且不包含重复数据和不需要进行排序的话，推荐使用UNION ALL。

### 对比postgresql和mysql

**postgresql的优势：**

- 在sql的标准现实上比mysql完善，而且功能实现比较严谨；
- 储存过程的功能支持要比mysql好，具备本地缓存执行计划的能力；
- 对表连接支持比较完整，优化器的功能比较完整，支持的索引类型更多，复杂查询的能力更强；
- postgresql主表采用堆表存放，mysql采用索引组织表，能够支持比MySQL更大的数据量；
- postgresql的主备复制属于物理复制，相对于mysql基于binlog的逻辑复制，数据的一致性更加可靠，复制性能更高，对主机性能的影响也更小；
- mysql的储存引擎插件化机制，存在锁机制，存在锁机制复杂影响并发的问题，而postgresql不存在。

**mysql的优势**

- innodb的基于回滚段实现的mvcc机制，相对于pg新老数据一起存放的基于xid的mvcc机制，是占优势的。新老数据一起存放，需要定时触发VACUUM，会带来多余的IO和数据库对象加锁开销，引起数据库整体的并发能力下降。而且VACUUM清理不及时，还可能会引发数据膨胀；
- mysql采用索引组织表，这种储存方式非常适合基于主键匹配的查询、删除操作，但是对标结构设计存在约束；
- mysql的优化器比较简单，系统表、运算符U、数据类型的实现都很精简，非常适合简单的查询操作；
- mysql分区表的实现要优于PG的基于继承表的分区实现，主要体现在分区个数达到上千上万后的处理性能差异较大。
- MySQL的存储引擎插件化机制，使得它的应用场景更加广泛，比如除了innodb适合事务处理场景外，myisam适合静态数据的查询场景。

**总结**

总的来说，开源数据库都还不是很完善，和这两者相比，商业数据库oracle无论在架构还是功能方面都要完善很多。

postgresql和mysql相比，postgresql更加适合**严格的企业应用场景**（比如金融、电信、ERP、CRM），而MySQL则是更加**适合业务逻辑相对简单、对数据可靠性要求比较低**的互联网场景（比如google、facebook、alibaba）。

### sql注入

什么是sql注入？

所谓的sql注入，就是通过命令插入到web表单递交或输入域名或页面请求的查询字符串，最终欺骗服务器执行恶意的sql命令。

**我们永远不要信任用户的输入，我们必须认定用户输入的数据都是不安全的，我们都需要对用户输入的数据进行过滤处理。**

**防止sql的几点经验：**

- 1.永远不要信任用户的输入。对用户的输入进行校验，可以通过正则表达式，或限制长度；对单引号和 双"-"进行转换等。
- 2.永远不要使用动态拼装sql，可以使用参数化的sql或者直接使用存储过程进行数据查询存取。
- 3.永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。
- 4.不要把机密信息直接存放，加密或者hash掉密码和敏感的信息。
- 5.应用的异常信息应该给出尽可能少的提示，最好使用自定义的错误信息对原始错误信息进行包装
- 6.sql注入的检测方法一般采取辅助软件或网站平台来检测，软件一般采用sql注入检测工具jsky，网站平台就有亿思网站安全平台检测工具。MDCSOFT SCAN等。采用MDCSOFT-IPS可以有效的防御SQL注入，XSS攻击等。

### 锁

**什么是数据库的锁机制？**

简单的说就是数据库为了保证数据的一致性，而使各种共享资源在被并发访问变得有序所设计的一种规则。

**表级锁定**

特性：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低；

**行级锁定**

特性：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高；    

**页级锁定**

特性：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。

**适用**：从锁的角度来说，表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web应用；而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统。　　

外链：https://www.cnblogs.com/clschao/articles/10463743.html#part1

**死锁是怎么产生的**：在InnoDB中，除单个SQL组成的事务外，锁是逐步获得的，当两个事务都需要获得对方持有的排他锁才能继续完成事务，这种循环锁等待就是典型的死锁。（和多线程的死锁是一样的）

**解决死锁问题**：首先查出死锁的进程，然后杀死这个进程。

### b+树和hash

hash类型的索引：查询单条快，范围查询慢。

btree：b+树，层数越多，数据量指数级增长（innoDB默认支持它），聚焦索引和辅助索引在底层实现的都是b+树索引。

外链：https://www.iteye.com/blog/uule-2429508

### 事务

### 执行计划

### sql优化

外链：https://www.cnblogs.com/clschao/articles/10463743.html#part_1

### 视图

### 触发器

### 储存过程函数

外链：https://www.cnblogs.com/clschao/articles/10034539.html