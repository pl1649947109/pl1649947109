---
title: 第五讲——数据库之索引优化
id: 5
date: 2019-9-4 20:00:00
tags: mysql
comment: true
---

### 学习大纲

- 索引
- 创建用户和授权
- 锁和事务

外链：https://www.cnblogs.com/clschao/articles/10049133.html

### 索引

```
普通索引：index（加速查找）
唯一索引：
	主键索引：primary key:加速查找+约束（不为空、不能重复）
	唯一索引：unique:加速查找+约束（不能重复）
联合索引：
	primary key(id,name):联合主键索引
	unique(id,name):联合唯一索引
	index(id,name):联合普通索引
```

##### 为什么要有索引？

一般的应用系统，读写的比例一般在10:1左右，而且插入操作和一般更新操作很少出现性能问题，在生产环境中我们遇到最多的，也是最容易出现问题的，还是一些复杂的查询操作，因此查询语句的优化显然是重中之重。说哦起加速查询，就不得不提到索引了。

<!----more---->

##### 什么是索引？

```
　　　索引在MySQL中也叫做“键”或者"key"（primary key，unique key，还有一个index key），是存储引擎用于快速找到记录的一种数据结构。索引对于良好的性能非常关键，尤其是当表中的数据量越来越大时，索引对于性能的影响愈发重要，减少io次数，加速查询。（其中primary key和unique key，除了有加速查询的效果之外，还有约束的效果，primary key 不为空且唯一，unique key 唯一，而index key只有加速查询的效果，没有约束效果）
　　　　索引优化应该是对查询性能优化最有效的手段了。索引能够轻易将查询性能提高好几个数量级。
　　　　索引相当于字典的音序表，如果要查某个字，如果不使用音序表，则需要从几百页中逐页去查。
```

　　　**强调：一旦为表创建了索引，以后的查询最好先查索引，再根据索引定位的结果去找数据**

##### 索引的原理

　**本质都是：通过不断地缩小想要获取数据的范围来筛选出最终想要的结果，同时把随机的事件变成顺序的事件，也就是说，有了这种索引机制，我们可以总是用同一种查找方式来锁定数据。**

　　　　数据库也是一样，但显然要复杂的多，因为不仅面临着等值查询，还有范围查询(>、<、between、in)、模糊查询(like)、并集查询(or)等等。数据库应该选择怎么样的方式来应对所有的问题呢？我们回想字典的例子，能不能把数据分成段，然后分段查询呢？最简单的如果1000条数据，1到100分成第一段，101到200分成第二段，201到300分成第三段......这样查第250条数据，只要找第三段就可以了，一下子去除了90%的无效数据。但如果是1千万的记录呢，分成几段比较好？稍有算法基础的同学会想到搜索树，其平均复杂度是lgN，具有不错的查询性能。但这里我们忽略了一个关键的问题，复杂度模型是基于每次相同的操作成本来考虑的。而数据库实现比较复杂，一方面数据是保存在磁盘上的，另外一方面为了提高性能，每次又可以把部分数据读入内存来计算，因为我们知道访问磁盘的成本大概是访问内存的十万倍左右，所以简单的搜索树难以满足复杂的应用场景。

注意：

**为什么说索引的字段要尽量小**，因为每个磁盘块的大小是一定的，那么意味着我们单个数据库里面的单个数据的大小越大越好还是越小越好，你想啊，你现在叶子节点的磁盘块，两个数据就沾满了，你数据要是更大的话，你这一个磁盘块就只能放一个数据了亲，这样随着你数据量的增大，你的树就越高啊，我们应该想办法让树的层数低下来，效率才高啊，所以我们应该让每个数据的大小尽可能的小，那就意味着，你每个磁盘块存的数据就越多，你树的层级就越少啊，树就越低啊，对不对。并且数据的数量越大，你需要的磁盘块越多，磁盘块越多，你需要的树的层级就越高，所以我们应该尽可能的用更少的磁盘块来装更多的数据项，这样树的高度才能降下来，怎么才能装更多的数据项啊，当然是你的数据项越小，你的磁盘块盛放的数据量就越多了，所以如果一张表中有很多的字段，我们应该用什么字段来建立索引啊，如果你有id字段、name字段、描述信息字段等等的，你应该用哪个来建立索引啊，当然是id字段了，你想想对不对，因为id是个数字，占用空间最少啊。

**索引的最左匹配特性**：简单来说就是你的数据来了以后，从数据块的左边开始匹配，再匹配右边的。

- 在表中有大量数据的前提下，创建索引速度会很慢

- 在索引创建完毕后，对表的查询性能会发幅度提升，但是写性能会降低

**聚焦索引（主键）**

- 添加主键索引

创建的时候添加：添加索引的时候需要注意，给字段里面数据比较小的字段添加，给字段里面数据区分度高的字段添加。

- 聚焦索引的添加几种方式

```mysql
#方式一
create table t1(
	id int primary key,
	name char(10)
);
#方式二
create table t1(
	id int,
	name char(10),
	primary key(id)
);
#方式三:创建完表之后添加
alter table t1 add primary key(id);

聚集索引的好处之一：它对主键的排序查找和范围查找速度非常快，叶子节点的数据就是用户所要查询的数据。如用户需要查找一张表，查询最后的10位用户信息，由于B+树索引是双向链表，所以用户可以快速找到最后一个数据页，并取出10条记录　　
```

- 删除主键索引

```mysql
alter table t1 drop primary key;
```

- 聚合索引的好处
  - **聚集索引的好处之一：它对主键的排序查找和范围查找速度非常快，叶子节点的数据就是用户所要查询的数据。**　　
  - **聚集索引的好处之二：范围查询（range query），即如果要查找主键某一范围内的数据，通过叶子节点的上层中间节点就可以得到页的范围，之后直接读取数据页即可**

- 辅助索引
  - 就是我们在查询的时候，where后面需要写id之外的其他字段名称来进行查询，比如说是where name=xx，没法用到主键索引的效率，怎么办，就需要我们添加辅助索引了，给name添加一个辅助索引。表中除了聚集索引外其他索引都是辅助索引（Secondary Index，也称为非聚集索引）（unique key啊、index key啊），与聚集索引的区别是：辅助索引的叶子节点不包含行记录的全部数据。

**唯一索引（unique）**

- 唯一索引创建的几种方式

```mysql
#方式一
create table t1(
	id int unique
);
#方式二
create table t1(
	id int,
	unique key unique_name(id)
);
#方式三
alter table t1 add unique key unique_name(id);
```

- 删除索引

```mysql
alter table t1 drop index unique_name;
```

**普通索引**

- 创建普通索引

```mysql
#方式一
create table t1(
	id int,
	index index_name(id)
);
#方式二
alter table t1 add index index_name(id);
#方式三
create index index_name on t1(id);
```

- 删除索引

```mysql
#方式一
alter table t1 drop index index_name;
#方式二
drop index index_name on 表名;
```

**联合索引**

创建联合索引（联合主键\联合唯一\联合普通索引）

```mysql
create table t1(
	id  int,
	name char(10),
	Index index_name(id,name)
);
```

 **索引的两大类型hash与btree**

```
#我们可以在创建上述索引的时候，为其指定索引类型，分两类
hash类型的索引：查询单条快，范围查询慢
btree类型的索引：b+树，层数越多，数据量指数级增长（我们就用它，因为innodb默认支持它）

#不同的存储引擎支持的索引类型也不一样
InnoDB 支持事务，支持行级别锁定，支持 B-tree、Full-text 等索引，不支持 Hash 索引；
MyISAM 不支持事务，支持表级别锁定，支持 B-tree、Full-text 等索引，不支持 Hash 索引；
Memory 不支持事务，支持表级别锁定，支持 B-tree、Hash 等索引，不支持 Full-text 索引；
NDB 支持事务，支持行级别锁定，支持 Hash 索引，不支持 B-tree、Full-text 等索引；
Archive 不支持事务，支持表级别锁定，不支持 B-tree、Hash、Full-text 等索引；
```

### 创建用户和授权

**对新用户增删改**

```
1.创建用户:
# 指定ip：192.118.1.1的chao用户登录
create user 'chao'@'192.118.1.1' identified by '123';
# 指定ip：192.118.1.开头的chao用户登录
create user 'chao'@'192.118.1.%' identified by '123';
# 指定任何ip的chao用户登录
create user 'chao'@'%' identified by '123';

2.删除用户
drop user '用户名'@'IP地址';


3.修改用户
rename user '用户名'@'IP地址' to '新用户名'@'IP地址';

4.修改密码
set password for '用户名'@'IP地址'=Password('新密码');
```

**对当前的用户授权管理**

```
#查看权限
show grants for '用户'@'IP地址'

#授权 chao用户仅对db1.t1文件有查询、插入和更新的操作
grant select ,insert,update on db1.t1 to "chao"@'%';

# 表示有所有的权限，除了grant这个命令，这个命令是root才有的。chao用户对db1下的t1文件有任意操作
grant all privileges  on db1.t1 to "chao"@'%';
#chao用户对db1数据库中的文件执行任何操作
grant all privileges  on db1.* to "chao"@'%';
#chao用户对所有数据库中文件有任何操作
grant all privileges  on *.*  to "chao"@'%';
 
#取消权限
 
# 取消chao用户对db1的t1文件的任意操作
revoke all on db1.t1 from 'chao'@"%";  

# 取消来自远程服务器的chao用户对数据库db1的所有表的所有权限

revoke all on db1.* from 'chao'@"%";  

取消来自远程服务器的chao用户所有数据库的所有的表的权限
revoke all privileges on *.* from 'chao'@'%';
```

### mysqldump备份

- 备份

```mysql
mysqldump -u root -p -B -d 备份的库名>路径(c:\back\back.sql)
```

- 还原

```mysql
mysql -u root -p < 路径(C:\back\back.sql)
```

### 锁和事务

**锁**

```
　数据库锁定机制简单来说，就是数据库为了保证数据的一致性，而使各种共享资源在被并发访问变得有序所设计的一种规则。对于任何一种数据库来说都需要有相应的锁定机制，所以MySQL自然也不能例外。MySQL数据库由于其自身架构的特点，存在多种数据存储引擎，每种存储引擎所针对的应用场景特点都不太一样，为了满足各自特定应用场景的需求，每种存储引擎的锁定机制都是为各自所面对的特定场景而优化设计，所以各存储引擎的锁定机制也有较大区别。MySQL各存储引擎使用了三种类型（级别）的锁定机制：表级锁定，行级锁定和页级锁定。
```

**innodb储存引擎默认储存是行级别的**

排他锁设置

```mysql
select * from xx where xx=xx for uppdate;
```

**事务**

链接：https://www.cnblogs.com/clschao/articles/10463743.html

```
原子性：事务是一个不可分割的整体，事务中的sql操作要么全部发生，要么全部不发生。

一致性：事务发生的前后，数据的完整性必须保持一致。

隔离性：一个事务的执行不能被其他的事务干扰。

持久性：一个事务一旦提交，它对数据库中数据的改变将是永久性的，就算出了错误，事务也不能撤销。
```

事务常见的问题

```
更新丢失（Lost Update）
　　　　　　原因：当多个事务选择同一行操作，并且都是基于最初选定的值，由于每个事务都不知道其他事务的存在，就会发生更新覆盖的问题。类比github提交冲突。

脏读（Dirty Reads）
　　　　　　原因：事务A读取了事务B已经修改但尚未提交的数据。若事务B回滚数据，事务A的数据存在不一致性的问题。

不可重复读（Non-Repeatable Reads）
　　　　　　原因：事务A第一次读取最初数据，第二次读取事务B已经提交的修改或删除数据。导致两次读取数据不一致。不符合事务的隔离性。

幻读（Phantom Reads）
　　　　　　原因：事务A根据相同条件第二次查询到事务B提交的新增数据，两次数据结果集不一致。不符合事务的隔离性。

　　　　幻读和脏读有点类似
　　　　脏读是事务B里面修改了数据，
　　　　幻读是事务B里面新增了数据
```

事务控制语句

```mysql
BEGIN或START TRANSACTION；显式地开启一个事务；
COMMIT；                  也可以使用COMMIT WORK，不过二者是等价的。COMMIT会提交事务，并使已对数据库进行的所有修改成为永久性的；
ROLLBACK；                有可以使用ROLLBACK WORK，不过二者是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改；
SAVEPOINT identifier；    SAVEPOINT允许在事务中创建一个保存点，一个事务中可以有多个SAVEPOINT；
RELEASE SAVEPOINT identifier；    删除一个事务的保存点，当没有指定的保存点时，执行该语句会抛出一个异常；
ROLLBACK TO identifier；   把事务回滚到标记点；
SET TRANSACTION；   用来设置事务的隔离级别。InnoDB存储引擎提供事务的隔离级别有READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ和SERIALIZABLE。

  用 BEGIN, ROLLBACK, COMMIT来实现
  BEGIN 开始一个事务
  ROLLBACK 事务回滚
  COMMIT 事务确认
  直接用 SET 来改变 MySQL 的自动提交模式:
  SET AUTOCOMMIT=0或者off 禁止自动提交
  SET AUTOCOMMIT=1或者on 开启自动提交
```

