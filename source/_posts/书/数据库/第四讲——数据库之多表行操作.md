---
title: 第四讲——数据库之多表行操作
id: 4
date: 2019-9-3 20:00:00
tags: mysql
comment: true
---

### 多表查询

**笛卡尔级**：将两张表所有的数据一一对应，生成一张大表。

```mysql
#将两张表拼在一起，生成一张大表
select * form dep,eemp;

#找到两张表之间的对应关系
select * from emp,dep where dep.id = emp.dep_id;

#筛选部门名称为技术的大表中的记录
select * from emp,dep where dep.id = emp.dep_id and dep.name="技术";

#拿到筛选后的记录的员工姓名字段数据
select emp.name from dep,emp where dep.id = emp.dep_id and dep.name = "技术";
```

<!----more---->

**连表查询：**

inner join:**内连接**(只连接匹配的行)

```mysql
#连表（将有关联的数据提取出来放到一张表里面）
select * from dep inner join emp on dep.id=emp.dep_id;
#过滤（将上表中name=技术的记录留下来）
select * from dep inner join emp on dep.id=emp.dep_id where  dep.name='技术';
#找对应字段的数据（具体的数据）
select emp.name from dep inner join emp on dep.id=emp.dep_id where  dep.name='技术';
```

left join:**左连接**（left join左边的表为主表，主表记录必须全部显示，join右边的是辅表，辅表没办法对应上的，就通过null来补全）

```mysql
select * from dep left join emp on dep.id = emp.dep
```

right join:**右连接**（和上面的相反）

```mysql
select * from emp left join dep on dep.id = emp.dep
```

union：**全连接**(显示左右两个表全部的记录)

```mysql
select * from dep left join emp on dep.id = emp.dep_id
union
select * from dep right join emp on dep.id = emp.dep_id;
```

**子查询**：(一个条件作为另一个条件的查询条件)

```mysql
select name from emp where dep_id = (select id from where name = "技术");
```

带IN关键字的字查询：

```mysql
#查询员工平均年龄在25岁以上的部门名，可以用连表，也可以用子查询，我们用子查询来搞一下
#子查询
select id,name from dep where id in (select dep_id from emp group by dep_id having avg(age) > 25);
#连表查询
select dep.name from dep inner join emp on dep.id = emp.dep_id group by dep.name having avg(age)>25;

总结：子查询的思路和解决问题一样，先解决一个然后拿着这个的结果再去解决另外一个问题，连表的思路是先将两个表关联在一起，然后在进行group by啊过滤啊等等操作，两者的思路是不一样的
```

带比较运算符的子查询：

```mysql
#比较运算符：=、!=、>、>=、<、<=、<>
select name,age from emp where age > (select avg(age) from emp);
```

带EXISTS关键字的子查询：

```mysql
#EXISTS关键字表示存在，在使用它时，内层查询语句不返回查询的记录，而是返回一个真假值，True或者False。当返回True时，外层查询语句将进行查询；返回False时，外层查询语句不尽兴查询，还可以写not exists。
select * from emp where exists (select id from dep where id=2000);
```

SQL关键字的执行顺序：

```mysql
(7)     SELECT 
(8)     DISTINCT <select_list>
(1)     FROM <left_table>
(3)     <join_type> JOIN <right_table>
(2)     ON <join_condition>
(4)     WHERE <where_condition>
(5)     GROUP BY <group_by_list>
(6)     HAVING <having_condition>
(9)     ORDER BY <order_by_condition>
(10)    LIMIT <limit_number>
```

链接：https://www.cnblogs.com/clschao/articles/9995815.html

### Navicat工具的使用

```
掌握：
测试+链接数据库
新建库
新建表：新增字段+类型+约束
设计表：外键
新建查询
备份库/表
批量加注释：ctrl+？
批量去注释：ctrl+shift+?
```

### pymysql的使用

```mysql
#1，我们可以再创建游标的时候，在cursor里面加上一个参数：cursor=conn.cursor(cursor=pymysql.cursors.DictCursor)获取的结果就是字典格式的，fetchall或者fetchmany取出的结果是列表套字典的数据形式

#2，游标
我们的数据取一次是不是就没有了啊，实际上不是的，这个取数据的操作就像读取文件内容一样，每次read之后，光标就移动到了对应的位置，我们可以通过seek来移动光标
同样，我们可以移动游标的位置，继续取我们前面的数据,通过cursor.scroll(数字，模式)，第一个参数就是一个int类型的数字，表示往后移动的记录条数，第二个参数为移动的模式，有两个值：absolute：绝对移动，relative：相对移动
#绝对移动：它是相对于所有数据的起始位置开始往后面移动的
#相对移动：他是相对于游标的当前位置开始往后移动的
#绝对移动的演示
#print(cursor.fetchall())
#cursor.scroll(3,'absolute') #从初始位置往后移动三条，那么下次取出的数据为第四条数据
#print(cursor.fetchone())

#相对移动的演示
#print(cursor.fetchone())
#cursor.scroll(1,'relative') #通过上面取了一次数据，游标的位置在第二条的开头，我现在相对移动了1个记录，那么下次再取，取出的是第三条，我相对于上一条，往下移动了一条
#print(cursor.fetchone())
```

sql注入

```python
#我对于sql注入的理解就是，通过输入特殊的字符串，执行该语言的特殊功能，从而达到修改该段代码绕过认证而去操作数据库，达到自己的一些目的。
uname = input('请输入用户名：')
pword = input('请输入密码：')

sql = "select * from userinfo where username='%s' and password='%s';"%(uname,pword)
print(sql)
res = cursor.execute(sql) #res我们说是得到的行数，如果这个行数不为零，说明用户输入的用户名和密码存在，如果为0说名存在，你想想对不

print(res) #如果输入的用户名和密码错误，这个结果为0，如果正确，这个结果为1
if res:
    print('登陆成功')
else:
    print('用户名和密码错误！')
#运行看结果：居然登陆成功
请输入用户名：chao' -- xxx
请输入密码：
select * from userinfo where username='chao' -- xxx' and password='';
1
登陆成功

我们来分析一下：
此时uname这个变量等于什么，等于chao' -- xxx,然后我们来看我们的sql语句被这个字符串替换之后是个什么样子：
select * from userinfo where username='chao' -- xxx' and password=''; 其中chao后面的这个'，在进行字符串替换的时候，我们输入的是chao',这个引号和前面的引号组成了一对，然后后面--在sql语句里面是注释的意思，也就是说--后面的sql语句被注释掉了。也就是说，拿到的sql语句是select * from userinfo where username='chao';然后就去自己的数据库里面去执行了，发现能够找到对应的记录，因为有用户名为chao的记录，然后他就登陆成功了，但是其实他连密码都不知道，只知道个用户名。。。，他完美的跳过了你的认证环节。
```

有些网站直接在你输入内容的时候，是不是就给你限定了，你不能输入一些特殊的符号，因为有些特殊符号可以改变sql的执行逻辑，其实不光是--，还有一些其他的符号也能改变sql语句的执行逻辑，这个方案我们是在客户端给用户输入的地方进行限制，但是别人可不可以模拟你的客户端来发送请求，是可以的，他模拟一个客户端，不按照你的客户端的要求来，就发一些特殊字符，你的客户端是限制不了的。所以单纯的在客户端进行这个特殊字符的过滤是不能解决根本问题的，那怎么办？我们服务端也需要进行验证，可以通过正则来将客户端发送过来的内容进行特殊字符的匹配，如果有这些特殊字符，我们就让它登陆失败。

解决方案：pymysql已经做好了封装

```python
# 原来是我们对sql进行字符串拼接
# sql="select * from userinfo where name='%s' and password='%s'" %(user,pwd)
# print(sql)
# res=cursor.execute(sql)

#改写为（execute帮我们做字符串拼接，我们无需且一定不能再为%s加引号了）
sql="select * from userinfo where name=%s and password=%s" #！！！注意%s需要去掉引号，因为pymysql会自动为我们加上
res=cursor.execute(sql,[user,pwd]) #pymysql模块自动帮我们解决sql注入的问题，只要我们按照pymysql的规矩来。
```

获取插入的最后一条数据的自增ID

```python
import pymysql
conn=pymysql.connect(host='localhost',user='root',password='123',database='egon')
cursor=conn.cursor()

sql='insert into userinfo(name,password) values("xxx","123");'
rows=cursor.execute(sql)
print(cursor.lastrowid) #在插入语句后查看

conn.commit()

cursor.close()
conn.close()
```

链接：https://chpl.top/2019/08/22/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97/pymysql%E2%80%94%E2%80%94%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%A4%E4%BA%92%E7%9A%84%E6%A8%A1%E5%9D%97/