---
title: 第二讲——数据库之表的操作
id: 2
date: 2019-8-30 20:00:00
tags: mysql
comment: true
---

### 学习大纲

- 表相关的操作
- 完整性约束
- 表中字段增删查改及外键的操作
- 复制表

### 创建表

**创建表**

```mysql
create table table_name(
	字段1 类型[(宽度) 约束条件],
	字段2 类型[(宽度) 约束条件],
	...
	z字段n 类型[(宽度) 约束条件]
);
```

#### 数据类型

**数值类型**

整型类型

```mysql
'''最常用的是int类型'''
创建有符号的数值类型
create table t1(num tinyint);
创建无符号的数值类型
create table t1(num tinyint unsigned);
#何止了数据类型就会有一个约束效果，只能表示自己范围内的数，如果是宽松模式，超出范围会提醒警告，并以临界的数值插入表中。如果是严格模式，就会报错。在工作中，我们使用的模式必须为严格模式。下面我们会讲解sql_mode（数据库模式）！
```

<!----more---->

浮点型

```mysql
create table t1(num float(60,30));
create table t1(num decimal(60,30));

```

| **数据类型**    | **描述**                                                     |
| --------------- | ------------------------------------------------------------ |
| TINYINT(size)   | 带符号-128到127 ，无符号0到255。                             |
| SMALLINT(size)  | 带符号范围-32768到32767，无符号0到65535, size 默认为 6。     |
| MEDIUMINT(size) | 带符号范围-8388608到8388607，无符号的范围是0到16777215。 size 默认为9 |
| **INT(size)**   | 带符号范围-2147483648到2147483647，无符号的范围是0到4294967295。 size 默认为 11 |
| BIGINT(size)    | 带符号的范围是-9223372036854775808到9223372036854775807，无符号的范围是0到18446744073709551615。size 默认为 20 |
| FLOAT(size,d)   | 带有浮动小数点的小数字。在 size 参数中规定显示最大位数。在 d 参数中规定小数点右侧的最大位数。 |
| DOUBLE(size,d)  | 带有浮动小数点的大数字。在 size 参数中规显示定最大位数。在 d 参数中规定小数点右侧的最大位数。 |
| DECIMAL(size,d) | 作为字符串存储的 DOUBLE 类型，允许固定的小数点。在 size 参数中规定显示最大位数。在 d 参数中规定小数点右侧的最大位数。 |

**日期类型**

```mysql
create table t1(d1 year,d2 date,d3 datetime);
insert into t1 values(now(),now(),now());
```

| **数据类型**   | **描述**                                                     |
| -------------- | ------------------------------------------------------------ |
| **DATE()**     | 日期。格式：YYYY-MM-DD**注释：**支持的范围是从 '1000-01-01' 到 '9999-12-31' |
| **DATETIME()** | 日期和时间的组合。格式：YYYY-MM-DD HH:MM:SS**注释：**支持的范围是从 '1000-01-01 00:00:00' 到 '9999-12-31 23:59:59' |
| TIMESTAMP()    | 时间戳。TIMESTAMP 值使用 Unix 纪元('1970-01-01 00:00:00' UTC) 至今的秒数来存储。格式：YYYY-MM-DD HH:MM:SS**注释：**支持的范围是从 '1970-01-01 00:00:01' UTC 到 '2038-01-09 03:14:07' UTC |
| **TIME()**     | 时间。格式：HH:MM:SS**注释：**支持的范围是从 '-838:59:59' 到 '838:59:59' |
| **YEAR()**     | 2 位或 4 位格式的年。**注释：**4 位格式所允许的值：1901 到 2155。2 位格式所允许的值：70 到 69，表示从 1970 到 2069。 |

`即便 DATETIME 和 TIMESTAMP 返回相同的格式，它们的工作方式很不同。在 INSERT 或 UPDATE 查询中，TIMESTAMP 自动把自身设置为当前的日期和时间。TIMESTAMP 也接受不同的格式，比如 YYYYMMDDHHMMSS、YYMMDDHHMMSS、YYYYMMDD 或 YYMMDD。`

**字符串类型**

```mysql
char(5) vs varchar(5)
需求：存3个人名 pl pl1 pl123
char:
	优点：简单粗暴，不管数据有多长，我就按照规定的长度来存，5个5个		的存，就像这样：pl   pl1  pl123中间以空格填充。
	缺点：貌似浪费空间，并且我们将来储存的数据的长度可能会参差不			齐。
varchar:
	varchar的储存原理：varchar类型不定长存储数据，更加精简和节省空间，因为它在储存数据的时候，会在每个数据前面加一个头，这个头是1-2bytes的数据，这个数据值的是后面跟的这个数据的长度，1bytes表示2**8=256个字符，2bytes表示2**16=65536个字符，所以它储存上面的数据就是1btes+pl+1bytes+pl1+1bytes+pl123,所以存的时候比char麻烦，导致效率比char低。
	优点:节省一些硬盘空间，（单也不一定，比如储存的数据正好和规定的		长度差不多时，加上前面的统计长度的字符就不一定比char少			了）。
	缺点：储存和读取的速度都很慢。
总结：我们在选择储存类型的时候需要根据业务来选择用哪种类型来存。
　　　　其实在多数的用户量少的工作场景中char和varchar效率差别不是很大，最起码给用户的感知不是很大，并且其实软件级别的慢远比不上硬件级别的慢，所以你们公司的运维发现项目慢的时候会加内存、换nb的硬盘，项目的效率提升的会很多，但是我们作为专业人士，我们应该提出来这样的技术点来提高效率。

　　　　但是对于InnoDB数据表，内部的行存储格式没有区分固定长度和可变长度列（所有数据行都使用指向数据列值的头指针），因此在本质上，使用固定长度的CHAR列不一定比使用可变长度VARCHAR列性能要好。因而，主要的性能因素是数据行使用的存储总量。由于CHAR平均占用的空间多于VARCHAR，因此使用VARCHAR来最小化需要处理的数据行的存储总量和磁盘I/O是比较好的。

　　　　所以啊，两个选哪个都可以，如果是大型并发项目，追求高性能的时候，需要结合你们服务器的硬件环境来进行测试，看一下char和varchar哪个更好，这也能算一个优化的点吧~~~~
```

| **数据类型**      | **描述**                                                     |
| ----------------- | ------------------------------------------------------------ |
| **CHAR(size)**    | 保存固定长度的字符串（可包含字母、数字以及特殊字符）。在括号中指定字符串的长度。最多 255 个字符。 |
| **VARCHAR(size)** | 保存可变长度的字符串（可包含字母、数字以及特殊字符）。在括号中指定字符串的最大长度。最多 65535个字节。 |
| TINYTEXT          | 存放最大长度为 255 个字符的字符串。                          |
| **TEXT**          | 存放最大长度为 65,535 个字符的字符串。                       |
| BLOB              | 用于 BLOBs（Binary Large OBjects）。存放最多 65,535 字节的数据。 |
| MEDIUMTEXT        | 存放最大长度为 16,777,215 个字符的字符串。                   |
| MEDIUMBLOB        | 用于 BLOBs（Binary Large OBjects）。存放最多 16,777,215 字节的数据。 |
| **LONGTEXT**      | 存放最大长度为 4,294,967,295 个字符的字符串。                |
| LONGBLOB          | 用于 BLOBs (Binary Large OBjects)。存放最多 4,294,967,295 字节的数据。 |

**枚举和集合类型**

```mysql
枚举类型（enum）
说明：枚举列最多可以有65535个不同元素。（实际限值小于3000）
实例：
create table shirts(
	name varchar(40),
	size ENUM('x-small','large','x-large')
);
insert into shirts(name,size) values('t-shirt','large'),('dress','large');

结合类型（set）
说明：集合列最多可以有64个不同的成员。
实例：
create table myset(
	col SET('a','b','c','d')
);
#插入重复的会自动去重
insert into myset(col) values('a,d'),('a,b,c')
```

| ENUM(x,y,z,etc.) | 允许您输入可能值的列表。可以在 ENUM 列表中列出最大 65535 个值。如果列表中不存在插入的值，则插入空值。注释：这些值是按照您输入的顺序排序的。可以按照此格式输入可能的值： ENUM('X','Y','Z') |
| ---------------- | ------------------------------------------------------------ |
| SET              | 与 ENUM 类似，不同的是，SET 最多只能包含 64 个列表项且 SET 可存储一个以上的选择。 |

#### sql_mode

说明：sql_mode是个很容易被忽略的变量，默认值是空值，在这种设置下可以允许一些非法操作的，比如允许一些非法数据的插入。在生产环境必须将这个值设置为**严格模式**，所以开发、测试环境的数据库也必须要设置，这样在开发测试阶段就可以发现问题。

**sql_mode的常用值如下**

```mysql
ONLY_FULL_GROUP_BY:对于GROUP BY聚合操作,如果在SELECT中的列,没有在GROUP BY中出现,那么这个SQL是不合法的,因为列不在	GROUP BY从句中

NO_AUTO_VALUE_ON_ZERO:该值影响自增长列的插入。默认设置下,插入0或NULL代表生成下一个自增长值。如果用户 希望插入的值为0,而该列又是自增长的,那么这个选项就有用了。

STRICT_TRANS_TABLES:在该模式下,如果一个值不能插入到一个事务表中,则中断当前的操作,对非事务表不做限制

NO_ZERO_IN_DATE:在严格模式下,不允许日期和月份为零

NO_ZERO_DATE:设置该值,mysql数据库不允许插入零日期,插入零日期会抛出错误而不是警告。

ERROR_FOR_DIVISION_BY_ZERO:在INSERT或UPDATE过程中,如果数据被零除,则产生错误而非警告。如 果未给出该模式,那么数据被零除时MySQL返回NULL

NO_AUTO_CREATE_USER:禁止GRANT创建密码为空的用户

NO_ENGINE_SUBSTITUTION: 如果需要的存储引擎被禁用或未编译,那么抛出错误。不设置此值时,用默认的存储引擎替代,并抛出一个异常

PIPES_AS_CONCAT:将"||"视为字符串的连接操作符而非或运算符,这和Oracle数据库是一样的,也和字符串的拼接函数Concat相类似

ANSI_QUOTES:启用ANSI_QUOTES后,不能用双引号来引用字符串,因为它被解释为识别符

宽松模式和严格模式
 如果设置的是宽松模式，那么我们在插入数据的时候，即便是给了一个错误的数据，也可能会被接受，并且不报错，例如：我在创建一个表时，该表中有一个字段为name，给name设置的字段类型时char(10)，如果我在插入数据的时候，其中name这个字段对应的有一条数据的长度超过了10，例如'1234567890abc'，超过了设定的字段长度10，那么不会报错，并且取前十个字符存上，也就是说你这个数据被存为了'1234567890',而'abc'就没有了，但是我们知道，我们给的这条数据是错误的，因为超过了字段长度，但是并没有报错，并且mysql自行处理并接受了，这就是宽松模式的效果，其实在开发、测试、生产等环境中，我们应该采用的是严格模式，出现这种错误，应该报错才对，所以MySQL5.7版本就将sql_mode默认值改为了严格模式，并且我们即便是用的MySQL5.6，也应该自行将其改为严格模式，而你记着，MySQL等等的这些数据库，都是想把关于数据的所有操作都自己包揽下来，包括数据的校验，其实好多时候，我们应该在自己开发的项目程序级别将这些校验给做了，虽然写项目的时候麻烦了一些步骤，但是这样做之后，我们在进行数据库迁移或者在项目的迁移时，就会方便很多，这个看你们自行来衡量。mysql除了数据校验之外，你慢慢的学习过程中会发现，它能够做的事情还有很多很多，将你程序中做的好多事情都包揽了。
 
改为严格模式后可能会存在的问题：
    若设置模式中包含了NO_ZERO_DATE，那么MySQL数据库不允许插入零日期，插入零日期会抛出错误而不是警告。例如表中含字段TIMESTAMP列（如果未声明为NULL或显示DEFAULT子句）将自动分配DEFAULT '0000-00-00 00:00:00'（零时间戳），也或者是本测试的表day列默认允许插入零日期 '0000-00-00' COMMENT '日期'；这些显然是不满足sql_mode中的NO_ZERO_DATE而报错。
```

**严格模式的3中设置方法**

```mysql
   方式一：先执行select @@sql_mode,复制查询出来的值并将其中的NO_ZERO_IN_DATE,NO_ZERO_DATE删除，然后执行set sql_mode = '修改后的值'或者set session sql_mode='修改后的值';，例如：set session sql_mode='STRICT_TRANS_TABLES';改为严格模式

此方法只在当前会话中生效，关闭当前会话就不生效了。

    方式二：先执行select @@global.sql_mode,复制查询出来的值并将其中的NO_ZERO_IN_DATE,NO_ZERO_DATE删除，然后执行set global sql_mode = '修改后的值'。

此方法在当前服务中生效，重新MySQL服务后失效了。

 

    方法三：在mysql的安装目录下，或my.cnf文件(windows系统是my.ini文件)，新增 sql_mode = ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION，

添加my.ini(my.cnf)如下：    sql_mode=ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER
然后重启mysql。
    此方法永久生效.当然生产环境上是禁止重启MySQL服务的，所以采用方式二加方式三来解决线上的问题，那么即便是有一天真的重启了MySQL服务，也会永久生效了。
```

#### 完整性约束

**not null**:不为空

注意：只给一个字段传值了，**那么也是生成一整条记录**，这条记录的其他字段的值如果可以为空，那么他们就都是null空值，如果不能为空，就会报错。

```mysql
create table t1(name int not null,num int not null);
insert into t1(num) values(10);  #报错，因为name没传值，不能为空
```

**default**：默认值

```mysql
create table t1(name int not null default 10,num int not null);
insert into t1(num) values(10);  #这样把name设置默认值就不会报错了
```

**unique**：唯一（唯一键），字段数据不能重复，比如id，身份证号等

```mysql
两种设置方法
方法一：
create table t1(
	id int,
	name varchar(20) unique,
);

方法二：
create table t1(
	id int,
	name varchar(20),
	constraint uk_name unique(name)
);
```

联合唯一

```mysql
create table t1(
	id int primayr key auto_inncrement,
	name varchar(20),
	host varchar(15) not null,
	port int not null,
	unique(host,port)#联合唯一,就是不能host和post同时重复
);
```

**primary key**：主键，约束效果：不为空且唯一not null+unique

说明：从约束角度看Primary key字段的值不为空且唯一，那么 我们直接使用not null+unique不就可以么。但是主键primary key是innoDB储存引擎组织数据的依据，innoDB称之为索引组织表，**一张表中必须且有一个主键。**

```
关于主键的强调内容：
        1.一张表中必须有，并且只能由一个主键字段：innodb引擎下存储表数据的时候，会通过你的主键字段的数据来组织管理所有的数据，将数据做成一种树形结构的数据结构，帮你较少IO次数，提高获取定位数据、获取数据的速度，优化查询。
            解释：如果我们在一张表中没有设置primary key，那么mysql在创建表的时候，会按照顺序从上到下遍历你设置的字段，直到找到一个not null unique的字段，自动识别成主键pri，通过desc可以看到，这样是不是不好啊，所以我们在创建表的时候，要给他一个主键，让他优化的时候用，如果没有pri也没有not null unique字段，那么innodb引擎下的mysql被逼无奈，你没有设置主键字段，主键又有不为空且唯一的约束，又不能擅自给你的字段加上这些约束，那么没办法，它只能给你添加一个隐藏字段来帮你组织数据，如果是这样，你想想，主键是不是帮我们做优化查询用的啊，这个优化是我们可以通过主键来查询数据：例如：如果我们将id设置为主键，当我们查一个id为30的数据的时候，也就是select * from tb1 where id=30；这个查询语句的速度非常快，不需要遍历前面三十条数据，就好像我们使用的字典似的，找一个字，不需要一页一页的翻书，可以首先看目录，然后看在哪一节，然后看在哪一页，一步步的范围，然后很快就找到了，这就像我们说的mysql的索引(主键、唯一键)的工作方式，一步一步的缩小范围来查找，几步就搞定了，所以通过主键你能够快速的查询到你所需要的数据，所以，如果你的主键是mysql帮你加的隐藏的字段，你查询数据的时候，就不能将这个隐藏字段作为条件来查询数据了，就不能享受到优化后的查询速度了，对么
        
        2.一张表里面，通常都应该有一个id字段，而且通常把这个id字段作为主键，当然你非要让其他的字段作为主键也是可以的，看你自己的设计，创建表的时候，一般都会写create table t1(id int primary key);id int primary key这个东西在建表的时候直接就写上
```

单列主键

```mysql
方法一：
create table t1(
	id int not null unique,#主键
	name varchar(20)
);
方法二：
create table t1(
	id int primayr key,#主键
    name varchar(20)
);
方法三：
create table t1(
	id int,
    name varchar(20),
    constraint pk_name primayrkey(id) #创建主键并将其命名为pk_name
);
```

联合主键

```mysql
create table t1(
	id int,
	port int,
	primary key(id,port)
);
+-------+---------+------+-----+---------+-------+
| Field | Type    | Null | Key | Default |Extra  |
+-------+---------+------+-----+---------+-------+
| id    | int(11) | NO   | PRI | 0       |       | 
| port  | int(11) | NO   | PRI | 0       |       |
+-------+---------+------+-----+---------+-------+
#解释：看key，id和port都写的是pri，连个联合起来作为主键，他们两个坐位子一个主键，不能再有其他的主键了，也就是在创建表的时候，只能出现一次pri方法。和上面的唯一键的联合是一样的。
```

**auto_increment**：自增

说明：约束字段为自动增长，被约束的字段必须同时被key约束，也就是说只能给约束成key的字段加自增属性，默认起始位置为1，步长也为1。

```mysql
#不指定id，则自动增长
create table student(
id int primary key auto_increment,
name varchar(20),
sex enum('male','female') default 'male'
);

mysql> desc student;
+-------+-----------------------+------+-----+---------+----------------+
| Field | Type                  | Null | Key | Default | Extra          |
+-------+-----------------------+------+-----+---------+----------------+
| id    | int(11)               | NO   | PRI | NULL    | auto_increment |
| name  | varchar(20)           | YES  |     | NULL    |                |
| sex   | enum('male','female') | YES  |     | male    |                |
+-------+-----------------------+------+-----+---------+----------------+
mysql> insert into student(name) values
    -> ('egon'),
    -> ('alex')
    -> ;

mysql> select * from student;
+----+------+------+
| id | name | sex  |
+----+------+------+
|  1 | egon | male |
|  2 | alex | male |
+----+------+------+


#也可以指定id
mysql> insert into student values(4,'asb','female');
Query OK, 1 row affected (0.00 sec)

mysql> insert into student values(7,'wsb','female');
Query OK, 1 row affected (0.00 sec)

mysql> select * from student;
+----+------+--------+
| id | name | sex    |
+----+------+--------+
|  1 | egon | male   |
|  2 | alex | male   |
|  4 | asb  | female |
|  7 | wsb  | female |
+----+------+--------+


#对于自增的字段，在用delete删除后，再插入值，该字段仍按照删除前的位置继续增长
mysql> delete from student;
Query OK, 4 rows affected (0.00 sec)

mysql> select * from student;
Empty set (0.00 sec)

mysql> insert into student(name) values('ysb');
mysql> select * from student;
+----+------+------+
| id | name | sex  |
+----+------+------+
|  8 | ysb  | male |
+----+------+------+

#应该用truncate清空表，比起delete一条一条地删除记录，truncate是直接清空表，在删除大表时用它
mysql> truncate student;
Query OK, 0 rows affected (0.01 sec)

mysql> insert into student(name) values('egon');
Query OK, 1 row affected (0.01 sec)

mysql> select * from student;
+----+------+------+
| id | name | sex  |
+----+------+------+
|  1 | egon | male |
+----+------+------+
row in set (0.00 sec)

auto_increment测试
```

**foreign key**：外键，建立表关系使用的约束条件

说明：外键就是标明表与表之间的关系，表和表之间如果有关系的话就三种：一对一关系、多对一关系、多对多关系。

**多对一关系**

![](http://9017499461.linshutu.top/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%9A%E5%AF%B9%E4%B8%80.png)

```mysql
在多的表里面添加一个字段,并给这个字段加foreign key,比如:
出版社对应书籍是多对一的关系
1.先创建出版社表  publish表
2.创建书籍表,外键写法:
	create table book(
		id int primary key,
		name char(10),
		pid int,
		foreign key(pid) references publish(id)
		);
```

**多对多关系**

![](http://9017499461.linshutu.top/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%9A%E5%AF%B9%E5%A4%9Apng.png)

```mysql
作者表和书籍表
需要借助第三张表来完整两者的关系记录
第三张表后创建
create table authortobook(
		id int primary key,
		author_id int,
		book_id int,
		foreign key(author_id) references author1(id),
		foreign key(book_id) references book1(id)
		);
```

**一对一关系**

![](http://9017499461.linshutu.top/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%80%E5%AF%B9%E4%B8%80.png)

```mysql
一对一关系
学生表(student)和客户表(customer)
create table student(
		id int primary key,
		name char(10),
		cid int unique,
		foreign key(cid) references customer(id)
		);
```

　**我们总结一下foreign key的下面几个约束作用：**

　　　　1、先要建立被关联的表才能建立关联表

　　　　2、在插入数据记录的时候，要先想被关联表中插入数据，才能往关联表里面插入数据

　　　　3、更新或者删除数据的时候，都需要考虑关联表和被关联表的关系

　　　　　　解决方案：

　　　　　　　　a.删除表的时候，先删除关联表，再删除被关联表

　　　　　　　　b.重建表的时候，在加外键关联的时候加上这两句：on delete cascade 和 on update cascade

```
了解：将来你们接触某一些大型项目的时候，尽量不要给表建立外键关系，因为外键直接在数据库级别就变成耦合的了，那么我们要拓展或者删除或者更改某些数据库或者数据表的时候，拓展起来就比较难，我们可以自己从自己的程序代码的逻辑层面上将这些关联关系建立好，有很多公司就是这么做的，利于拓展，如果我们加了很多的foreign key ，那么当你想删除一个表的时候，可能会牵一发而动全身，了解一下就可以了
```

练习：

![](http://9017499461.linshutu.top/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%83%E4%B9%A0.png)

```mysql
#创建班级表
mysql> create table class(
	->cid int primary key,  #关联需要定义主键
	->caption varchar(20));
#创建学生表 
mysql> create table student(
    -> sid int,
    -> sname varchar(20),
    -> gender varchar(5),
    -> class_id int,
    -> foreign key(class_id) references class(cid));
#创建老师表
mysql> create table teacher(
    -> tid int primary key,
    -> tname varchar(20));
#创建课程表
mysql> create table course(
    -> cid int primary key,
    -> cname varchar(20),
    -> teacher_id int,
    -> foreign key(teacher_id) references teacher(tid));
#创建成绩表
mysql> create table score(
    -> sid int primary key,
    -> student_id int,
    -> corse_id int,
    -> num int,
    -> foreign key(student_id) references teacher(tid),
    -> foreign key(corse_id) references course(cid));
```

### 表中字段增删查改及外键的操作

#### 删除或修改被关联字段

```mysql
需求：book表和publish表为多对一关系，book表的pid字段外键关联到publish表的id字段
1，查看外键关系的名称：
show create table book;
| book  | CREATE TABLE `book` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` char(20) DEFAULT NULL,
  `pid` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `pid` (`pid`),
  CONSTRAINT `book_ibfk_1` FOREIGN KEY (`pid`) REFERENCES `publish` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 |
#book_ibfk_1就是我们找到的外键的名字

2，首先删除外键关系
	alter table book drop forign key book_ibfk_1;
3，删除字段
	alter table publish drop id;
4,添加字段
	alter table publish add id int primary key auto_increment;
5，创建表完成后，添加外键
	默认外键名：alter table book add foreign key(id) references publish(id);
	指定外键名：alter table book add constraint book_publish_fk foreign key(pid) references publish(id);
	
创建外键时指定外键名称
	create table t1(
    id int,
    pid int,
    constraint fk_t1_publish foreign key(pid) references publish(id)
    );
```

#### 外键约束的三种约束模式（都是针对父表的约束）

**模式一：**district严格约束(默认的),父表不能删除或者更新已经被子表数据引用的记录。

**模式二：**cascase级联模式，父表的操作 ，对应的子表关联的数据也跟着操作。

**模式三：**set  null置空模式，父表操作之后，子表对应的数据（外键字段）也跟着置空。

通常的一个合理的约束模式就是：删除的时候子表置空；更新表的时候子表级联。

**指定的语法模式：**

foreign key(外键字段) references 父表(主键字段) **on delete 模式 on update 模式**;

注意：删除置空的前提条件是外键字段允许为空，不然外键会创建失败。外键的功能虽然强大，能够进行各种约束，但是外键的约束降低了数据的可控性和拓展性。通常在时间开发中很少使用外键来约束。

#### 表中字段增删改查

修改表名

```mysql
alter table old_table_name rename new_table_name;
```

增加字段

```mysql
#增加到表的末尾
alter table 表名 add 字段1 数据类型 约束条件,add 字段2 数据类型 约束条件......;

#增加到表的最开始的位置
alter table 表名 add 字段 数据类型 约束条件 first;

#插入到任意的位置
alter table 表名 add 字段2 数据类型 约束条件 after 指定插入到的字段的后面;
```

删除字段

```mysql
alter table 表名 drop 字段名称;
```

修改的

```mysql
只修改字段名称
alter table 表名 change 旧字段 新字段 旧的数据类型 约束条件;
修改字段名，数据类型，完整性约束
alter table 表名 change 旧字段 新字段 新的数据类型 约束条件;

#注意：在mysql里面表名是不区分大小写的，如果将一个名为t1的修改成大写的T1，是完全没用的，因为在数据库里面表的名字都是小写的。
```

### 复制表

复制表

```mysql
create table 新表 select * from 被复制的表;
注意：key不会复制
```

复制表结构

```mysql
create table new_table select * from old_table where 1=2;（只要where的条件为假就会复制表的结构）

方法二：create table new_table like old_table;
```