---
title: 第二讲——解决验证码问题
id: 2
date: 2019-9-16 20:30:00
tags: 爬虫
comment: true
---

**什么是验证码？**

验证码是一种区分用户是计算机还是人的公共全自动程序。验证码可以防止：恶意破解密码、刷票、论坛灌水，有效防止某个黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试，实际上用验证码是现在很多网站通行的方式，我们利用比较简易的方式实现了这个功能。**这是一种反爬机制。**

**介绍一种解决的方案**

利用云打码平台识别验证码：http://www.yundama.com/demo.html

**识别验证码的操作流程**

```
#识别验证码的操作：
	#人工识别（肯定不会用啊，费眼）
	#第三方自动识别
	#第三方的平台（云打码：http://yundama.com/demo.html)
#云打码的使用流程：
	#注册：普通和开发者模式
	#pl12346（我的账号：普通和开发者都是这个）
	#登录：
		#普通用户的登录：查积分是否有剩余
		#开发者用户的登录：
			#创建一个软件：我的软件》添加新的软件》录入软件信息》提交（获取软件的id和密钥）
			#下载实例代码：开发文档》点击下载云打码接口dll》实例下载
			#下载的实例加载到pycharm，使用实例3进行学习
#实战：识别登录古诗文网登录页面的验证码
# 使用打码平台识别验证的编码流程：
# 	--将验证码下载到本地
# 	--在本地的示例中破解
#封装函数方便调用

注意：使用该平台识别验证码，必须将验证码事先下载到本地，然后再将本地存储的验证码提交给平台的示例程序进行识别操作。
```

<!----more---->

**云打码下载的demo**

加载一

```python
'''
将下载的demo的这部分内容拿出来封装到一个自定义函数中，并放到我们的代码文件中。
'''
# 用户名
username = 'username'
# 密码
password = 'password'                            
# 软件ＩＤ，开发者分成必要参数。登录开发者后台【我的软件】获得！
appid = 1                                     
# 软件密钥，开发者分成必要参数。登录开发者后台【我的软件】获得！
appkey = '22cc5376925e9387a23cf797cb9ba745'    
# 图片文件
filename = 'getimage.jpg'                        
# 验证码类型，# 例：1004表示4位字母数字，不同类型收费不同。请准确填写，否则影响识别率。在此查询所有类型 http://www.yundama.com/price.html
codetype = 1004
# 超时时间，秒
timeout = 60                                    
# 检查
if (username == 'username'):
    print('请设置好相关参数再测试')
else:
    # 初始化
    yundama = YDMHttp(username, password, appid, appkey)
    # 登陆云打码
    uid = yundama.login();
    print('uid: %s' % uid)
    # 查询余额
    balance = yundama.balance();
    print('balance: %s' % balance)
    # 开始识别，图片路径，验证码类型ID，超时时间（秒），识别结果
    cid, result = yundama.decode(filename, codetype, timeout);
    print('cid: %s, result: %s' % (cid, result))

```

加载二

```python
#这个是验证码识别转换的实现类，供封装函数的调用
#讲这个文件放到和自己的代码文件同级的目录下，等待调用
import http.client, mimetypes, urllib, json, time, requests

######################################################################

class YDMHttp:
	apiurl = 'http://api.yundama.com/api.php'
	username = ''
	password = ''
	appid = ''
	appkey = ''

	def __init__(self, username, password, appid, appkey):
		self.username = username
		self.password = password
		self.appid = str(appid)
		self.appkey = appkey

	def request(self, fields, files=[]):
		response = self.post_url(self.apiurl, fields, files)
		response = json.loads(response)
		return response

	def balance(self):
		data = {'method': 'balance', 'username': self.username, 'password': self.password, 'appid': self.appid,
		        'appkey': self.appkey}
		response = self.request(data)
		if (response):
			if (response['ret'] and response['ret'] < 0):
				return response['ret']
			else:
				return response['balance']
		else:
			return -9001

	def login(self):
		data = {'method': 'login', 'username': self.username, 'password': self.password, 'appid': self.appid,
		        'appkey': self.appkey}
		response = self.request(data)
		if (response):
			if (response['ret'] and response['ret'] < 0):
				return response['ret']
			else:
				return response['uid']
		else:
			return -9001

	def upload(self, filename, codetype, timeout):
		data = {'method': 'upload', 'username': self.username, 'password': self.password, 'appid': self.appid,
		        'appkey': self.appkey, 'codetype': str(codetype), 'timeout': str(timeout)}
		file = {'file': filename}
		response = self.request(data, file)
		if (response):
			if (response['ret'] and response['ret'] < 0):
				return response['ret']
			else:
				return response['cid']
		else:
			return -9001

	def result(self, cid):
		data = {'method': 'result', 'username': self.username, 'password': self.password, 'appid': self.appid,
		        'appkey': self.appkey, 'cid': str(cid)}
		response = self.request(data)
		return response and response['text'] or ''

	def decode(self, filename, codetype, timeout):
		cid = self.upload(filename, codetype, timeout)
		if (cid > 0):
			for i in range(0, timeout):
				result = self.result(cid)
				if (result != ''):
					return cid, result
				else:
					time.sleep(1)
			return -3003, ''
		else:
			return cid, ''

	def report(self, cid):
		data = {'method': 'report', 'username': self.username, 'password': self.password, 'appid': self.appid,
		        'appkey': self.appkey, 'cid': str(cid), 'flag': '0'}
		response = self.request(data)
		if (response):
			return response['ret']
		else:
			return -9001

	def post_url(self, url, fields, files=[]):
		for key in files:
			files[key] = open(files[key], 'rb')
		res = requests.post(url, files=files, data=fields)
		return res.text
```

**实例**

需求：登录古诗文网

https://so.gushiwen.org/user/login.aspx?from=http://so.gushiwen.org/user/collect.aspx

实现思路

- 对当前页url发起请求，爬取携带验证码图片的当前页面源码数据
- 对页面源码进行数据解析，解析出验证码图片的url
- 对验证码图片数据进行请求，且将验证码图片持久化存储到本地
- 调用云打码平台的示例代码对保存本地的验证码图片进行识别处理

```python
import requests
from lxml import etree
from ClassCode import YDMHttp  #就是引入破解验证码的文件
#实战：识别登录古诗文网登录页面的验证码
# 使用打码平台识别验证的编码流程：
# 	--将验证码下载到本地
# 	--在本地的示例中破解
#封装函数方便调用
def getCodeText(img_path,code_type):
    # 用户名
    username = 'pl12346'
    # 密码
    password = 'xxx'
    # 软件ＩＤ，开发者分成必要参数。登录开发者后台【我的软件】获得！
    appid = 8396
    # 软件密钥，开发者分成必要参数。登录开发者后台【我的软件】获得！
    appkey = 'b4ba006c7c8c0d7ce005575b15859cb7'
    # 图片文件
    filename = img_path
    # 验证码类型，# 例：1004表示4位字母数字，不同类型收费不同。请准确填写，否则影响识别率。在此查询所有类型 http://www.yundama.com/price.html
    codetype = code_type
    # 超时时间，秒
    timeout = 60
    # 检查
    result = None
    if (username == 'username'):
        print('请设置好相关参数再测试')
    else:
        # 初始化
        yundama = YDMHttp(username, password, appid, appkey)
        # 登陆云打码
        uid = yundama.login()
        print('uid: %s' % uid)
        # 查询余额
        balance = yundama.balance()
        print('balance: %s' % balance)
        # 开始识别，图片路径，验证码类型ID，超时时间（秒），识别结果
        cid, result = yundama.decode(filename, codetype, timeout)
        print('cid: %s, result: %s' % (cid, result))
    return result


#将验证码下载到本地
if __name__ == '__main__':
	headers = {
		'User-Agent': "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36",
		}
	url = "https://so.gushiwen.org/user/login.aspx?from=http://so.gushiwen.org/user/collect.aspx"
	page_text = requests.get(url=url,headers=headers).text
	tree = etree.HTML(page_text)
	#标签可以直接在网站上面copy，xpath的标签同样可以copy
	code_img_url = tree.xpath('//*[@id="imgCode"]/@src')[0]
	print (code_img_url)
	img_url = 'https://so.gushiwen.org'+code_img_url
	img_data = requests.get(url=img_url,headers=headers).content
	with open('./code.jpg','wb') as fp:
		fp.write(img_data)

	#调用云打码平台进行图片的识别
	code_text = getCodeText('./code.jpg',1004)
	print(code_text)
```

