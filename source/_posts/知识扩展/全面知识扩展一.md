---
title: 全面知识扩展一
id: 1
date: 2019-9-24 20:30:00
tags: 知识扩展
comment: true
---

**涉及范围：面想对象（类和对象）、并发编程**

### 学习大纲：

- 一切皆对象
- 魔法函数
- python一个经典的错误
- 深入类编程
- 元类编程
- 并发编程
- asyncio的并发编程

<!----more---->

### 前言

python是基于协议的，就是我们实现了某些协议的就可以干什么，这个协议就是我们的魔法函数。所以说弄懂了魔法函数也就算是弄懂了我们的python。这篇文章的内容有一些的松散，但是里面包含的知识点还是很多的，以及一些思想还是很重要的。

### 一切皆对象

type、object、class三者之间的关系：话说的再多都没有一张图来的实在

![](http://9017499461.linshutu.top/type_object_class.JPG)

记住两句话：

- 所有的类都集继承object，包括type

- type实例化一切，包括自己

**内置的数据类型**

- None（全局只有一个，地址都是一样的）
- 迭代类型
- 序列类型
- 映射类型：字典
- 集合:set的性能是非常高的（最高的是dict）

### 魔法函数

先上图：

![](http://9017499461.linshutu.top/%E9%AD%94%E6%B3%95%E5%87%BD%E6%95%B0.png)

- 魔法函数作为独立的存在，他们可以再任何的类函数中去，通过它们可以了解python语法的原理做高级的开发。

- 魔法方法只要定义了就不需要我们去调用，python解释器就会自动去触发他们。

- len()方法的特殊性：不会遍历数据，而是直接调用cpython内部维护的长度。因此，它并不是一个普通的方法。

### python一个经典的错误

```python
class A(object):
    def __init__(self,name,friend_list=[]):
        self.name = name
        self.friend_list = friend_list
    def add(self,name):
        self.friend_list.append(name)
if __name__ == "__main__":
    f1 = A("xiaoming",["xiaoming","xiaohong"])
    f1.add("xiaojun")
    print(A.__init__.__defaults__)
#([],)
    print(f1.friend_list)
#['xiaoming', 'xiaohong', 'xiaojun']  
    f2 = A("xiaoming")
    f2.add("xiaojun")
    print(A.__init__.__defaults__)  #查看A的init里面的默认值
#(['xiaojun'],)
    print(f2.friend_list)
#['xiaojun']
    f3 = A("xiaoming")
    f3.add("xiaolan")
    print(A.__init__.__defaults__)
#(['xiaojun', 'xiaolan'],)
    print(f2.friend_list)
    print(f3.friend_list)
#['xiaojun', 'xiaolan']
#['xiaojun', 'xiaolan']
分析：；我们发现，我们f1传递数据的时候，传入了我们自己的列表数据，这个时候打印的列表数据是没有问题的。然后我们的f2没有传入列表数据，而是使用了默认的空列表，在我们打印的时候，也是没有问题的。但是在我们f3对象的时候，也是使用默认的列表，这个时候打印出来就出现了问题，f2中有xiaolan，f3中有xiaojiu，他们两个不是应该都只有一个数据的吗？这就是一个传参的经典错误。
因为我们不传入自己定义的列表的时候，它就使用自己默认的列表，这个时候就会出现数据混乱的情况。
通过上面的A.__init__.__defaults__我们可以查看，默认列表的默认值一致在增加，而且对象之间是共享的。所以这样就不安全。
```

总结：我们传递给函数或者类对象的时候尽量不要传递可变的数据类型，例如list,dict，他们可能会被修改

### 深入元类编程

#### 鸭子类型

鸭子类型：一只鸟走起来像鸭子，叫起来像鸭子，那么这只鸟就是鸭子。贯穿我们的python，就是动态语言设计时候的一种特点，就是多态。你看啊，像我们的len()函数里面传递的可以是各种类型，而不是指定特定的对象，就像java这样的静态语言指定特定的数据类型对象。因此鸭子就可以看做python这种动态语言的特性，也就是多态，这也是静态语言所不具备的。

#### 鸭子类型和魔法方法就实现了我们python语言的基础

- **抽象基类（abc模块）：**
- 抽象基类不能实例化，在什么时候去使用他们呢？我们希望在知道对象的类型的时候（isinstance()方法）；设计抽象基类，指定基类必须执行某些方法(两种方法，其中一种就是使用ABC类另一种就是子类初始化执行某方法，没有就去父类中继承，这个时候就报错)。还是不太推荐使用。

- 尽量多去使用鸭子类型，上面的抽象基类最好使用多继承去实现。

- isinstance和type的区别：推荐使用isinstance,为什么呢？针对的是面向对象里面的东西。在判断类型的时候使用，不是获取的时候。

- **自省机制**：通过一定的机制（这个机制就是__dict__和dir方法）查询到对象的内部结构

```python
class Person:
    name = "pl"

class Student(A):
	def __init__(self,age)
		self.age = age

if __name__ == "__main__":
    user = Student(18)
    
    print (user.__dict__)
    user.__dict__["sex"] = "NaN"
    print (user.sex)
    print (Person.__dict__)
    print (user.name)
	print (dir(user))
这个自省机制就是__dict__和dir这两个东西。
```

- super()本质就是调用我们的父类super(B,self).是python2中的用法。在python3中简化了。为什么还去调用super()：重用父类的代码。

- with语句：就是为了简化try语句而产生的。上下文管理器就是我们的with语句。上下文管理器协议：和魔法函数挂钩,__enter__和__exit__这种结构就组成了我们的协议。

```python
class A:
	def __enter__(self):
        print ("enter")
   	def __exit__(self):
        print ("exit")
    def do_something(self):
        print ("do_something")
with A() as a:
    a.do_something()
```

简化上下文管理器的方法，使用内置模块

```python
import contextlib
@contextlib.contextmanager
def file_open(fiel_name):
    print ("file open")
    yield
   	print ("file end")
with file_open("body.text") as f:
    print ("file processing")
    
结果：
file open 
file processing
file end
```

### 自定义序列类

序列：从更高的维度去总结数据类型

- **分类**：

  容器系列：list/tuple/deque

  扁平序列：str/bytes/bytearry/array.array(数组：指的是里面数据类型相同，和list不同)

- from collection import abc
- Sequence和 MutableSequence（不可变的）构成了我们python序列类型的协议，我们的序列类型的方法都是在他们里面实现的。他们都是继承abc这个基类来的。

- 序列+、+=和extend的区别：+=是”就地加“，它就是extend来迭代进来的。

- 切片的原理：功能非常强大，我们只是学习了关于它的用法，但是它使怎么实现的呢，其实都是通过魔法方法实现的，都是封装在collection模块下的abc中。

- isect维护已排序的序列：import bisect,使用的是二分查找的算法

```python
import bisect

inter_list = []
bisect.insort(inter_list,3)
bisect.insort(inter_list,5)
bisect.insort(inter_list,1)
bisect.insort(inter_list,96)
bisect.insort(inter_list,74)
print (inter_list)

结果：[1,3,5,74,96]
相同的元素后来的插入后面，只要是可变的序列类型都可以使用该模块维护，这样我们后期维护的时候就非常方便。
```

- 什么时候我们不该去使用列表：引入deque和array（效率比list高），array就是我们c中的数组，它的存储是连续的空间

- import array：array和list的区别：array只能存放指定的数据类型

- 列表生成式的性能要比list高，但是不能违背python的原则，就是代码的可读性，当生成式非常复杂的时候，不容易理解就不要去使用

- dict和set：Mapping和MutableMapping(不可变的)，dict属于Mapping类型，dict的拷贝是浅拷贝  ，get方法

- dict和set的实现原理：  

  dict查找的性能远远比list块；list随着查询的总体数据的增大，时间越长，dict不会出现这个情况，将（键+随机数与运算）并哈希并映射到数组（所以说为什么是可hash的数据才能做键）中，连续的空间，但是当表的空的空间<1/3的时候就会开辟新的空间

![](F:\七牛云图片\hash取值.JPG)

set也是走的hash表，所以说，set的值都是可哈希的。也就是不能被修改的数据类型。

dict的内存花销大，自定义的对象或者python内部的对象都是用dict包装的；dict的储存顺序和元素添加顺序有关，添加的数据可能改变已有的数据顺序

- python的变量是什么？实际上就是一个指针，一个形象的便利贴，它可以贴在任何的对象上面。a = 1，这个过程就是生成对象1，然后把a贴在1这个对象上面。而java的变量就相当于一个盒子，和python是不一样的。

- python的基础实现都是基于魔法函数的:a = [1,2,3] b = [1,2,3] a==b返回true，其实他们在里面实现了__eq__这个魔法函数

- 迭代器和生成器：迭代协议：就是指我们的迭代器，什么是迭代器？迭代器是访问集合内元素的一种方式，一般用来遍历数据。__iter__方法

  abc中的Iterable（可迭代）和Iterator（迭代器），Iterator才是我们的迭代器，它继承了前面的iterable，在它的下面实现了__next__魔法函数，所以有它才是迭代器，不然只有__iter__就只能是一个可迭代对象。

- 只要有yield这个关键字，那么这个函数就是生成器函数。

```python
def func():
	yield 1
if __name__ == "__main__":
    #生成器对象：python编译字节码的时候就产生了。
	gen = func()
```

生成器的原理：首先了解函数的工作原理：python.exe会使用一个叫做pyEval_EvalFramEx(c函数)去执行我们定义的函数，首先会创建一个栈帧（上下文）-->python一切皆对象，所以栈帧也是对象，字节码也是对象。所有的栈帧都是分配在堆内存中，这就决定了栈帧可以独立于调用者存在生成器可以控制函数的暂停和开始，这也是协程的理论基础。

### 元类编程

- 在类的里面的单下划线的意义：就是不想对外暴露，一种编程规范。其实通过对象也可以取到。

```python
__getattr__和__getattribute__
魔法函数是python动态的根本原因。
__getattr__：查找不到属性的时候触发，我们可以在里面灵活的添加我们的逻辑。
__getattribute__：比上面的更高级，只要属性访问，就会触发它。无条件的触发。
```

- **元类实现一个简单的orm**

```python
#需求：
class Field:
    pass
#属性描述符（就是赋值的时候做参数检查)    
class IntField(Field):
    def __init__(self,db_column,min_value=None,max_value=None):
        self._value = None
        self.db_column = column
        self.min_value = min_value
        self.max_value = max_value
        if min_value is not None:
            if not isinstance(value,numbers.Integral):
                 raise ValueError("min_value must be int")
            elif min_value < 0:
            	raise ValueError("min_value must be positive int")
        if max_value is not None:
            if not isinstance(value,numbers.Integral):
                 raise ValueError("max_value must be int")
            elif max_value < 0:
            	raise ValueError("max_value must be positive int")
		if min_value is not None and max_value is not None:
            if min_value > max_value:
                raise ValueError("max_value must be bigger then min_value")  
    def __get__(self,instance,owner):
        return self._value
    def __set__(self,instance,value):
        if not isinstance(value,numbers.Integral):
            raise ValueError("int value need")
        if value < self.min_value or value > self.max_value:
            raise ValueError("positive value need")
		self._value = value
#属性描述符(就是赋值的时候做参数检查)    
class CharField(Field):
    def __init_(self,value,db_column,max_length=None):
        self._value = value
        self.db_column = column
        id max_length is None:
            raise ValueError("you must spcify max_length for charfielld")
    def __get__(self,instance,owner):
        return self._value
    def __set__(self,instance,value):
        if not isinstance(value,str):
            raise ValueError("string value need")
        if len(value) > self.max_length:
            raise ValueError("value len excess len of max_length")
		self._value = value
class ModelMetaClass(type):
    self __new__(cls,name,bases,attrs,**kwargs)
    	if name = "BaseModel":
            return super().__new__(cls,name,bases,attrs,**kwargs)
        fields = {}
        for key,value in attrs.items():
            if isinstance(value,Field):
                _meta = {}
                db_table = name.lower()
                if attrs_meta is not None:
                    getattr(attrs_meta,"db_table",None)
                    if table is not None:
                        db_table = table
                    -meta["db_table" = db_table]
                    attrs["_meta"] = _meta
                    attrs["fields"] = fields
                    def attrs["Meta"]
                    return super().__new__(cls,name,bases,attrs,**kwargs)

class BaseModel(metaclass = ModelMetaClass):
    def __init__(self,*args,**kwargs):
        for key,value in kwargs.items():
            setatts(self,key,value)
        return super().__init__()
    def save(self):
        fields = {}
        values = []
        for key,value in self.fields.items():
            db_column = value.db_column
            if db_columnis None:
                db_column = key.lower()
                fields.append(db_column)
                value = getattr(self,key)
                values.append(str(value)
        sql = "insert {db_name}({fields}) value({values})".format(
        db_table=self._meta["db_table"],fields=",".join(fields),values=",".join(values))
    
class User(BaseModel):
    #定义的是列
    name = CharField(db_cliumn="",max_length=10)
    age = Intfield(db_cloumn="",min_value=0,max_value=100)
    class Meat:
        #为了和表区分，在这里定义其他的一些东西
        db_table = "uesr" 
        
if __name__ == "__main__":
    user = User()
    user.name = "pl"
    user.age = 18
```

元类编程在开发中基本不会用到，但是在框架中有很多地方有应用。很多的框架中都是使用了元类编程。

### 并发编程

- gil会根据执行的字节码行数以及时间片释放gil 或者 遇到io操作主动释放

- 线程之间的通信是queue，这个消息队列（已经做到了线程安全，在里面使用的就是dqueue双端队列，这个就是安全的），当然我们也可以使用区局变量共享的方式
- 一般倒另一个py文件里面的函数，最好直接把这个py文件导进来，再去通过这个py文件名去找到自己想要的函数。
- 线程同步：加锁解决（死锁：加多把锁；资源竞争  产生死锁）
- 条件变量（condition）：复杂的同步锁，完成复杂的消息同步的问题。它在执行完自己的任务之后就会去通知下一个线程去执行，然后自己等待别人的通知，然后在运行自己的代码。

```python
模拟小爱同学和天猫精灵之间的对话：你一言我一语对话
cond = threading.Condition()

with self.cond:
	print ("xxx")
	self.cond.notify()
	self.cond.wait()
在调用with self.cond之后才能调用notify()  wait()方法。condition有两层，一把底层锁会在线程调用wait方法的时候释放
```

- 信号量（semaphore）：控制线程并发的数量，也是一把锁。也需要释放，它的内部就是condition实现的。 线程里面的很多的功能都是调用了condition来实现的。
- from concurrent import futures这个包比较底层，专门用来创建进程和线程池的，它可以让多线程和多进程编码接口统一
- 线程池：为什么有线程池？不光可以控制线程并发的数量还可以控制线程的状态，返回值等等一系列的功能，可以管理线程池的一切，信号量就不可以，它只是控制并发的数量，单纯的。

```python
submit()提交任务（一个个的提交）
as_completed:批量的提交，并且可以返回成功的任务，map更加简单
urls = [1,2,3]  #我们的任务
for future in 线程池变量.map(任务函数，urls):
	data = future.result()
	print (data)  #我们执行成功并返回的任务

done()方法：判断某个任务是否完成
result()阻塞方法，可以获取任务的执行结果
cancle()取消任务
```

- 协程：

   并发：同一时间段内

  并行：任意时间段内

- 生成器实现协程：了解yield：send()方法、next()方法

```python
send()传递值传到生成器的内部，同时还可以重启生成器执行下一个yield，它的功能包含next()方法 ，在调用send()发送非none值前。我们必须启动一次生成器
```

- yield from的详解：

```python
def gen():
	print ("aaa")
def g1(gen):
	yield from gen
def main():
	g = g1()
	g.send(None)  #激活send()函数，也可以next()

#这里面，mian（调用方）主函数调用g1(委托生成器),gen子生成器
#yield from会调用方与子生成器之间建立一个双向通道，这里就是gen，是一个桥梁。这就是yield的最大的一个特性

为什么会有委托生成器？干嘛不直接调用gen?那么这里的yield from干了什么事情呢？
1，yield from表达式的值是子生成器终止时，传递给StopIteration异常的第一个参数
2，如果调用的时候出现StopIteration异常，委托生成器会恢复运行，同时其他的异常会向上冒泡。
说白了，yield from自动帮助我们做了很多的事情，很多异常捕获和处理它都帮助我们做好了。
```

- await和async：await其实就是yield from，但是await只能出现在async里面，主要是为了和yield区分开来

- yield实现一个协程：

```python
def gen_func():
    value = yield from  #返回值给调用方法，调用方通过send方式返回值给gen
    return "pl"
#用同步的方式编写异步代码，在适当的时候暂停函数并在适当的时候启动函数
实例：
def get_socket_data():
    yield from "boddy"
def download(url):
    html_data = yield from get_socket_data()
    操作html_data数据
def download_html(html):
    html = yield from download()
if __name__ == "__mian__":
    #协程的调度依然是事件循环+协程模式  协程是单线程模式，只要遇到耗时的操作就是用yield或者yield from出去
    pass
```

### asyncio的并发编程

实现的是TCP，UDP层的,它是python解决用于驱动解决异步IO编程的一整套解决方案

- 高并发必要的3要素：事件循环+回调（驱动生成器）+epoll(IO多路复用)

- 框架：tornado：实现了web服务器，可以直接部署，tornado+nginx部署；

  django+flask（部署：uwsgi、gunicorn+nginx），没有实现web服务器

- time.sleep()是不能是用在异步IO里面的，因为time.sleep()是同步阻塞的，所以只能一个任务执行完城之后并返回之后再去启动下一个任务的执行，那么这不就是阻塞串行了么。因此我们在异步里面可以是用await asyncio.sleep()。
- asyncio.ensure_future = loop.create_task (后者可以回调，并且前者也是基于后者实现的)

```python
from functions import partail
async def get_html():
	print ("start get url")
    await asyncio.sleep(2)
    return "boddy"
def callback(url,future):
    print (url)
    print ('send email to boddy')
if __name__ == "__main__":
    start _time = time.time()
    loop = asyncio.get_event_loop()
    task = loop.create_task(get_html('www.baidu.com'))
    task.add_done_callback(partail(callback,"www.baidu.com"))#回调函数，callback不能传参数，利用偏函数partail包装这个函数给他传参数url
    loop.run_until_complete(task)
    print (task.result())
#进阶
loop = asyncio.get_event_loop()
loop.run_forever()#永不停止
loop.run_until_complete()#会停止
loop会被放到future，取消future(task),取消任务:
```

- future和task：future就是我们的结果容器，运行完之后就去调用回调函数。task抽象，是future和我们协程之间的桥梁。它激活我们的协程还处理好了容错的一些问题 
- aiohttp：基于http实现的